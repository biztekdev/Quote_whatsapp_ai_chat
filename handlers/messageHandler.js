import dotenv from 'dotenv';
import conversationService from '../services/conversationService.js';
import WitService from '../services/witService.js';
import mongoLogger from '../services/mongoLogger.js';
import messageStatusService from '../services/messageStatusService.js';
import voiceProcessingService from '../services/voiceProcessingService.js';
import { Product, ProductCategory } from '../models/productModel.js';
import { Material } from '../models/materialModel.js';
import { ProductFinish } from '../models/finishModel.js';
import { ProcessedMessage } from '../models/processedMessageModel.js';


dotenv.config();

class MessageHandler {
    constructor(whatsappService, aiService) {
        this.whatsappService = whatsappService;
        this.aiService = aiService; // ChatGPT or Wit service
        this.witService = new WitService(); // Keep for backward compatibility
        // Remove old responseTracker - now using MessageStatusService
        
        // Create a wrapper for whatsappService.sendMessage to track all messages
        this.originalSendMessage = this.whatsappService.sendMessage.bind(this.whatsappService);
        this.whatsappService.sendMessage = this.trackedSendMessage.bind(this);
    }

    // Wrapper method to track all message sending attempts
    async trackedSendMessage(to, message, type = 'text') {
        console.log(`ðŸš¨ DIRECT MESSAGE SEND DETECTED: ${to} - ${message.substring(0, 50)}...`);
        // console.trace('Call stack for direct message send:');
        
        // Try to find messageId from the call stack or context
        // This is a fallback for direct calls that bypass sendMessageOnce
        const result = await this.originalSendMessage(to, message, type);
        
        // Log this as a potential duplicate
        await mongoLogger.warn('Direct message send detected (bypassed sendMessageOnce)', {
            to,
            message: message.substring(0, 100),
            type,
            source: 'direct-whatsapp-service-call'
        });
        
        return result;
    }

    // Check if we've already responded to a message using MessageStatusService
    async hasResponded(messageId) {
        return await messageStatusService.hasResponseBeenSent(messageId);
    }

    // Mark that we've responded to a message using MessageStatusService
    async markAsResponded(messageId, responseMessageId = null, responseType = 'text') {
        await messageStatusService.markResponseAsSent(messageId, responseMessageId, responseType);
    }

    // Send message only if we haven't already responded using MessageStatusService
    async sendMessageOnce(messageId, to, message, type = 'text') {
        try {
            // Check if we can send response
            const canSend = await messageStatusService.canSendResponse(messageId);

            if (!canSend) {
                console.log(`â­ï¸ Already responded to message ${messageId}, skipping duplicate response`);
                await mongoLogger.warn('Duplicate response prevented', {
                    messageId,
                    to,
                    message: message.substring(0, 100) + '...',
                    source: 'sendMessageOnce'
                });
                return null;
            }

            // Check if this is an auto-generated message ID (skip status tracking for these)
            const isAutoGenerated = messageId.includes('auto-generated-') || 
                                   messageId.includes('error-response-') || 
                                   messageId.includes('error-flow-') ||
                                   messageId.includes('quote-response-') ||
                                   messageId.includes('material-selection-') ||
                                   messageId.includes('material-found-') ||
                                   messageId.includes('material-bypass-') ||
                                   messageId.includes('dimension-selection-') ||
                                   messageId.includes('finish-selection-') ||
                                   messageId.includes('finish-found-') ||
                                   messageId.includes('finish-bypass-') ||
                                   messageId.includes('quantity-bypass-') ||
                                   messageId.includes('quantity-found-');

            // Mark response as sending (only for real message IDs)
            if (!isAutoGenerated) {
                await messageStatusService.markResponseAsSending(messageId);
            }

            console.log(`ðŸ“¤ Sending response for message ${messageId}${isAutoGenerated ? ' (auto-generated)' : ''}`);

            try {
                // Send the message
                const result = await this.whatsappService.sendMessage(to, message, type);

                // Mark response as sent (only for real message IDs)
                if (!isAutoGenerated) {
                    const responseMessageId = result?.messages?.[0]?.id || null;
                    await messageStatusService.markResponseAsSent(messageId, responseMessageId, type);
                }

                return result;

            } catch (sendError) {
                // Mark response as failed (only for real message IDs)
                if (!isAutoGenerated) {
                    await messageStatusService.markResponseAsFailed(messageId, sendError.message);
                }
                throw sendError;
            }

        } catch (error) {
            console.error(`âŒ Error in sendMessageOnce for message ${messageId}:`, error);
            await mongoLogger.logError(error, {
                source: 'sendMessageOnce',
                messageId,
                to,
                error: error.message
            });
            throw error;
        }
    }

    // Helper method for sending messages when we don't have a messageId (fallback)
    async sendMessageFallback(to, message, type = 'text') {
        try {
            console.log(`ðŸ“¤ Sending fallback message to ${to}`);
            const result = await this.whatsappService.sendMessage(to, message, type);
            return result;
        } catch (error) {
            console.error(`âŒ Error in sendMessageFallback:`, error);
            throw error;
        }
    }

    async handleIncomingMessage(message, value = null) {
        const messageId = message.id;
        const from = message.from;
        const messageType = message.type;

        try {
            // Check for empty text messages early
            if (messageType === 'text' && (!message.text?.body || message.text.body.trim() === '')) {
                console.log(`â­ï¸ Empty text message received from ${from}, skipping processing`);
                await mongoLogger.info('Empty text message received, skipping processing', { 
                    messageType, 
                    from, 
                    messageId,
                    messageText: message.text?.body || 'empty'
                });
                return;
            }

            await mongoLogger.logMessage(message, from);
            await mongoLogger.info('Message received', { messageType, from, messageId });

            // Check if conversation is already completed before processing
            const conversationState = await conversationService.getConversationState(from);
            if (conversationState.conversationData?.completed || conversationState.currentStep === 'completed') {
                console.log(`â­ï¸ Conversation already completed for ${from}, skipping message processing`);
                return;
            }

            // Initialize message status tracking
            await messageStatusService.initializeMessageStatus(
                messageId,
                from,
                messageType,
                message, // webhookData
                null // conversationId - can be set later if needed
            );

            // Check if message can be processed
            const canProcess = await messageStatusService.canProcessMessage(messageId);
            if (!canProcess) {
                console.log(`â­ï¸ Message ${messageId} already processed, skipping`);
                await mongoLogger.info('Message already processed, skipping', { messageId, from });
                return;
            }

            // Mark message as processing
            await messageStatusService.markAsProcessing(messageId);

            // Mark message as read
            // await this.whatsappService.markAsRead(messageId);

            await mongoLogger.info('Processing message type', { messageType });

            try {
                // Fix for webhook data sending wrong message type
                const actualMessageType = messageType === 'hi' ? 'text' : messageType;
                
                if (messageType !== actualMessageType) {
                    console.log(`ðŸ”§ Message type correction: ${messageType} â†’ ${actualMessageType}`);
                }
                
                switch (actualMessageType) {
                    case 'text':
                        await this.handleTextMessage(message, from);
                        break;
                    case 'image':
                        await this.handleImageMessage(message, from);
                        break;
                    case 'document':
                        await this.handleDocumentMessage(message, from);
                        break;
                    case 'audio':
                        await this.handleAudioMessage(message, from);
                        break;
                    case 'video':
                        await this.handleVideoMessage(message, from);
                        break;
                    case 'interactive':
                        await this.handleInteractiveMessage(message, from);
                        break;
                    default:
                        await mongoLogger.warn('Unsupported message type', { messageType });
                        await this.sendMessageOnce(
                            messageId,
                            from,
                            "Sorry, I don't support this type of message yet.",
                            'text'
                        );
                }

                // Mark message as processed successfully
                await messageStatusService.markAsProcessed(messageId);

            } catch (processingError) {
                // Mark message processing as failed
                await messageStatusService.markAsFailed(messageId, processingError.message);
                throw processingError;
            }

        } catch (error) {
            await mongoLogger.logError(error, {
                source: 'message-handler',
                messageId,
                from,
                messageType
            });

            // Try to send error message if we haven't already responded
            try {
                const hasResponded = await this.hasResponded(messageId);
                if (!hasResponded) {
                    // Provide more specific error messages based on error type
                    let errorMessage = "Sorry, I encountered an error processing your message. Please try again.";
                    
                    if (error.message && error.message.includes('timeout')) {
                        errorMessage = "The system is taking longer than expected. Please try again in a moment.";
                    } else if (error.message && error.message.includes('network')) {
                        errorMessage = "There seems to be a connection issue. Please check your internet and try again.";
                    } else if (error.message && error.message.includes('database')) {
                        errorMessage = "I'm having trouble accessing my data right now. Please try again shortly.";
                    }
                    
                    // Add restart option
                    errorMessage += "\n\nðŸ’¡ You can also type 'hi' to restart our conversation anytime.";
                    
                    await this.sendMessageOnce(
                        messageId,
                        from,
                        errorMessage,
                        'text'
                    );
                }
            } catch (sendError) {
                console.error('Error sending error message:', sendError);
            }
        }
    }

    async handleTextMessage(message, from) {
        let messageText = 'unknown';
        try {
            messageText = message.text.body;

            // Check if message is empty, null, or undefined
            if (!messageText || messageText.trim() === '') {
                console.log(`â­ï¸ Empty message received from ${from}, skipping processing`);
                await mongoLogger.info('Empty message received, skipping processing', { 
                    from, 
                    messageId: message.id,
                    messageText: messageText || 'empty'
                });
                return;
            }

            // Check if conversation is already completed - handle restart scenarios
            let conversationState = await conversationService.getConversationState(from);
            if (conversationState.conversationData?.completed || conversationState.currentStep === 'completed') {
                console.log(`ðŸ“ Conversation completed for ${from}, checking for restart/new quote requests`);
                
                // Handle simple restart/greeting messages for completed conversations
                if (this.isSimpleRestartMessage(messageText)) {
                    await this.handleCompletedConversationRestart(messageText, from, message.id);
                    return;
                }
                
                console.log(`â­ï¸ Conversation already completed and no restart detected, skipping processing`);
                return;
            }

            // Check for simple keyword messages that don't need ChatGPT processing
            if (this.isSimpleKeywordMessage(messageText, conversationState.currentStep)) {
                await this.handleSimpleKeywordMessage(messageText, from, message.id, conversationState);
                return;
            }

            // Process message with ChatGPT FIRST to extract entities before making decisions
            let aiResponse = null;
            let aiEntities = {};
            
            try {
                console.log("ðŸ¤– Processing message with ChatGPT:", messageText);
                
                // Prepare context for ChatGPT - include available materials if we have a category
                const context = {};
                if (conversationState.conversationData?.selectedCategory?.id) {
                    try {
                        // Get available materials for the selected category
                        const Material = (await import('../models/materialModel.js')).Material;
                        const availableMaterials = await Material.find({ 
                            categoryId: conversationState.conversationData.selectedCategory.id,
                            isActive: true 
                        }).sort({ sortOrder: 1, name: 1 });
                        
                        context.availableMaterials = availableMaterials;
                        context.categoryId = conversationState.conversationData.selectedCategory.id;
                        console.log(`ðŸ§± Found ${availableMaterials.length} materials for category: ${conversationState.conversationData.selectedCategory.name}`);
                    } catch (materialError) {
                        console.error("âŒ Error fetching materials for context:", materialError);
                    }
                }
                
                aiResponse = await this.aiService.processMessage(messageText, context);
                
                // Log the complete ChatGPT response
                console.log("ðŸ“Š Complete ChatGPT Response:", JSON.stringify(aiResponse, null, 2));
                
                aiEntities = aiResponse?.data?.entities || {};
                
            } catch (aiError) {
                console.error("âŒ ChatGPT processing failed:", aiError);
                await mongoLogger.error('ChatGPT processing failed', { 
                    messageText, 
                    from,
                    error: aiError.message,
                    stack: aiError.stack,
                    step: 'AI_ERROR'
                });
                
                // Continue without ChatGPT - use empty entities
                aiResponse = { data: { entities: {} } };
                aiEntities = {};
            }

            // Check if user wants to start a new quote OR is greeting (regardless of current step)
            const newQuoteKeywords = ['new quote', 'new', 'start over', 'restart', 'reset', 'begin again', 'fresh quote', 'another quote', 'new order'];
            const wantsNewQuote = newQuoteKeywords.some(keyword => 
                messageText.toLowerCase().includes(keyword.toLowerCase())
            );

            // Check if this is a greeting message
            const isGreetingMessage = this.isGreeting(messageText);
            
            // Check if message contains useful product information
            const hasProductInfo = this.hasProductInformation(messageText);
            
            console.log('ðŸ” Message analysis:', {
                message: messageText,
                wantsNewQuote: wantsNewQuote,
                isGreetingMessage: isGreetingMessage,
                hasProductInfo: hasProductInfo,
                hasEntities: Object.keys(aiEntities).length > 0
            });

            // Only reset conversation for simple greetings or explicit new quote requests
            // Don't reset if we're already in an active conversation step expecting a response
            const activeSteps = ['quote_generation', 'greeting_response', 'material_selection', 'finish_selection', 'quantity_input', 'dimension_input'];
            const isInActiveStep = activeSteps.includes(conversationState.currentStep);
            
            // Don't reset for complex messages with product information or detected entities
            // Don't reset if we're in an active conversation step expecting a response
            if (!isInActiveStep && (wantsNewQuote || (isGreetingMessage && !hasProductInfo && Object.keys(aiEntities).length === 0))) {
                console.log("User wants new quote or is simple greeting, resetting conversation");
                
                // Reset conversation to start fresh
                await conversationService.resetConversation(from);
                
                // Send greeting response for new conversation
                await this.handleGreetingResponse(messageText, from, message.id);
                return;
            }
            
            // If it's a complex message with product info OR entities detected, process it with entity extraction
            if (hasProductInfo || Object.keys(aiEntities).length > 0) {
                console.log("Complex message with product information or entities detected, processing with entity extraction");
                
                // For greeting messages with entities, reset conversation but extract entities first
                if (isGreetingMessage) {
                    console.log("Greeting with entities detected, resetting and extracting data");
                    await conversationService.resetConversation(from);
                    
                    // Get fresh conversation state after reset
                    conversationState = await conversationService.getConversationState(from);
                }
            }

            // Extract and update conversation data using improved fuzzy search approach
            // Skip entity extraction for quote_generation, material_selection, and finish_selection to prevent unwanted overrides
            // Allow entity extraction for greeting_response when it contains product info
            let updatedConversationData = conversationState.conversationData || {};
            const shouldExtractEntities = conversationState.currentStep !== 'quote_generation' && 
                                        conversationState.currentStep !== 'material_selection' &&
                                        conversationState.currentStep !== 'finish_selection' &&
                                        !(conversationState.currentStep === 'greeting_response' && 
                                          (messageText.toLowerCase().includes('yes') || messageText.toLowerCase().includes('no')));
                                          
            if (shouldExtractEntities) {
                updatedConversationData = await this.smartExtractAndUpdateConversationData(
                    messageText,
                    conversationState.conversationData || {},
                    aiResponse.data.entities
                );
                console.log("ðŸŽ¯ Smart entity extraction performed for step:", conversationState.currentStep, "message:", messageText);
            } else {
                console.log("ðŸŽ¯ Skipping entity extraction for response step:", conversationState.currentStep, "message:", messageText);
            }


            // Special case: If this is the first message and we have selectedCategory, bypass greeting
            if (conversationState.currentStep === 'start' && updatedConversationData.selectedCategory) {
                // console.log("Bypassing greeting - user provided product info in first message");
                updatedConversationData.wantsQuote = true;
            }

            // Check if we can bypass steps based on extracted data
            console.log('ðŸ” determineNextStep input:', {
                currentStep: conversationState.currentStep,
                wantsQuote: updatedConversationData.wantsQuote,
                hasSelectedCategory: !!updatedConversationData.selectedCategory?.id,
                selectedCategory: updatedConversationData.selectedCategory
            });
            
            // Skip dimension bypass if we're currently in dimension_input step
            const skipDimensionBypass = conversationState.currentStep === 'dimension_input';
            
            const nextStep = await this.determineNextStep(
                conversationState.currentStep,
                updatedConversationData,
                aiResponse.data.entities,
                skipDimensionBypass
            );
            console.log('ðŸŽ¯ determineNextStep result:', nextStep);
            
            // Don't immediately advance from dimension_input to allow proper handling
            const shouldUpdateStep = !(conversationState.currentStep === 'dimension_input' && nextStep === 'material_selection');
            
            // Update conversation state with extracted data
            if (Object.keys(updatedConversationData).length > 0) {
                // console.log("ðŸ’¾ Updating conversation state with data:", {
                //     hasSkus: !!updatedConversationData.skus,
                //     skusData: updatedConversationData.skus,
                //     dataKeys: Object.keys(updatedConversationData)
                // });
                
                const updateData = {
                    conversationData: updatedConversationData
                };
                
                // Only update step if we should advance
                if (shouldUpdateStep) {
                    updateData.currentStep = nextStep;
                }
                
                const _sss = await conversationService.updateConversationState(from, updateData);
                
                // console.log("âœ… Conversation state updated successfully");
                
                // Get the updated conversation state for processing
                conversationState = await conversationService.getConversationState(from);
                // console.log("ðŸ”„ Retrieved updated conversation state:", {
                //     hasSkus: !!conversationState.conversationData?.skus,
                //     skusData: conversationState.conversationData?.skus,
                //     currentStep: conversationState.currentStep
                // });
            }
            // Process message through our conversation flow
            
            await this.processConversationFlow(message, messageText, from, conversationState, false);

        } catch (error) {
            console.error('Error in handleTextMessage:', error);
            await mongoLogger.logError(error, {
                source: 'text-message-handler',
                from: from,
                messageText: messageText || 'unknown'
            });

            try {
                // Provide more specific error messages based on error type
                let errorMessage = "Sorry, I encountered an error processing your message. Please try again.";
                
                if (error.message && error.message.includes('timeout')) {
                    errorMessage = "The system is taking longer than expected. Please try again in a moment.";
                } else if (error.message && error.message.includes('network')) {
                    errorMessage = "There seems to be a connection issue. Please check your internet and try again.";
                } else if (error.message && error.message.includes('database')) {
                    errorMessage = "I'm having trouble accessing my data right now. Please try again shortly.";
                }
                
                // Add restart option
                errorMessage += "\n\nðŸ’¡ You can also type 'hi' to restart our conversation anytime.";
                
                await this.sendMessageOnce(
                    message.id,
                    from,
                    errorMessage
                );
            } catch (sendError) {
                console.error('Error sending error message to user:', sendError);
                await mongoLogger.logError(sendError, {
                    source: 'error-message-sender',
                    from: from
                });
            }
        }
    }

    /**
     * Parse dimension values from string with various separators
     */
    parseDimensionValues(dimensionString) {
        try {
            if (!dimensionString || typeof dimensionString !== 'string') {
                return [];
            }

            // Check if this looks like a dimension string (has dimension indicators)
            const dimensionIndicators = [
                'x', 'Ã—', '*', 'inch', 'cm', 'mm', 'size:', 'dimension', 
                'width', 'height', 'depth', 'diameter', 'w:', 'h:', 'd:', 'dia:'
            ];
            
            const lowerStr = dimensionString.toLowerCase();
            const hasDimensionIndicator = dimensionIndicators.some(indicator => 
                lowerStr.includes(indicator)
            );
            
            // If no dimension indicators, don't parse as dimensions
            if (!hasDimensionIndicator) {
                console.log(`No dimension indicators found in "${dimensionString}", skipping dimension parsing`);
                return [];
            }

            // Replace common separators with comma and clean the string
            let cleanedString = dimensionString
                .replace(/[xÃ—*]/gi, ',')  // Replace x, Ã—, or * with comma
                .replace(/\s+/g, ',')    // Replace spaces with comma
                .replace(/[,\s]+/g, ',') // Replace multiple commas/spaces with single comma
                .replace(/^,|,$/g, '');  // Remove leading/trailing commas

            // Split by comma and parse numbers
            const values = cleanedString
                .split(',')
                .map(val => val.trim())
                .filter(val => val !== '')
                .map(val => parseFloat(val))
                .filter(val => !isNaN(val) && val > 0 && val < 1000); // Reasonable dimension limits

            console.log(`Parsed dimensions from "${dimensionString}":`, values);
            return values;
        } catch (error) {
            console.error('Error parsing dimension values:', error);
            return [];
        }
    }

    /**
     * Smart entity extraction using single ChatGPT call with full context
     */
    async smartExtractAndUpdateConversationData(messageText, currentConversationData, aiEntities) {
        try {
            console.log("ðŸ§  Starting smart extraction for:", messageText);
            
            // Skip entity processing only for simple greetings without product information
            if (messageText && this.isGreeting(messageText) && !this.hasProductInformation(messageText)) {
                console.log("ðŸŽ¯ Skipping smart extraction for simple greeting message:", messageText);
                return currentConversationData;
            }

            const updatedData = { ...currentConversationData };
            let foundCategory = null;
            let foundProduct = null;

            // Step 1: Try fuzzy search for category first
            console.log("ðŸ” Step 1: Searching for category in message...");
            foundCategory = await this.fuzzySearchCategory(messageText);
            
            if (foundCategory) {
                console.log("âœ… Found category via fuzzy search:", foundCategory.name);
                updatedData.selectedCategory = {
                    id: foundCategory._id.toString(),
                    erp_id: foundCategory.erp_id,
                    name: foundCategory.name,
                    description: foundCategory.description
                };
            }

            // Step 2: If no category found, try fuzzy search for product and get its category
            if (!foundCategory) {
                console.log("ðŸ” Step 2: No category found, searching for product...");
                foundProduct = await this.fuzzySearchProduct(messageText);
                
                if (foundProduct) {
                    console.log("âœ… Found product via fuzzy search:", foundProduct.name);
                    
                    // Get category from product relationship
                    const productCategory = await this.findCategoryById(foundProduct.categoryId);
                    if (productCategory) {
                        console.log("âœ… Got category from product relationship:", productCategory.name);
                        foundCategory = productCategory;
                        updatedData.selectedCategory = {
                            id: productCategory._id.toString(),
                            erp_id: productCategory.erp_id,
                            name: productCategory.name,
                            description: productCategory.description
                        };
                    }
                    
                    updatedData.selectedProduct = {
                        id: foundProduct._id.toString(),
                        erp_id: foundProduct.erp_id,
                        name: foundProduct.name,
                        description: foundProduct.description,
                        basePrice: foundProduct.basePrice,
                        dimensionFields: foundProduct.dimensionFields
                    };
                }
            }

            // Step 3: If we have a category, make SINGLE ChatGPT call with ALL context
            if (foundCategory) {
                console.log("ðŸ§  Step 3: Making SINGLE ChatGPT call with full context...");
                
                try {
                    // Get ALL materials for this category
                    const categoryMaterials = await Material.find({
                        categoryId: foundCategory._id,
                        isActive: true
                    }).sort({ sortOrder: 1, name: 1 });

                    // Get ALL finishes for this category  
                    const categoryFinishes = await ProductFinish.find({
                        productCategoryId: foundCategory._id,
                        isActive: true
                    }).sort({ sortOrder: 1, name: 1 });

                    console.log(`ðŸ” Available materials for ${foundCategory.name}:`, categoryMaterials.map(m => `${m.name} (ID: ${m.erp_id})`));
                    console.log(`ðŸ” Available finishes for ${foundCategory.name}:`, categoryFinishes.map(f => `${f.name} (ID: ${f.erp_id})`));

                    // Create enhanced context with ALL available options
                    const enhancedContext = `
IMPORTANT: You are processing a quote request for "${foundCategory.name}" category.

AVAILABLE MATERIALS (choose ONLY from these):
${categoryMaterials.map(m => `- "${m.name}" (ID: ${m.erp_id})`).join('\n')}

AVAILABLE FINISHES (choose ONLY from these):
${categoryFinishes.map(f => `- "${f.name}" (ID: ${f.erp_id})`).join('\n')}

${foundProduct ? `DETECTED PRODUCT: "${foundProduct.name}"` : ''}

RULES:
1. For materials: ONLY select from the available materials list above
2. For finishes: ONLY select from the available finishes list above  
3. If a word like "holographic" appears, check if it matches any material name (like "PET + CD holographic PET + PE")
4. Extract quantities, dimensions, SKUs as usual
5. Return standard wit.ai format with entities

Please extract all entities from the user message, selecting materials and finishes ONLY from the provided lists.`;

                    // SINGLE ChatGPT call with full context
                    console.log(`ðŸ¤– Making SINGLE ChatGPT call: "${messageText}"`);
                    let enhancedEntities = null;
                    
                    try {
                        const enhancedAiResponse = await this.aiService.processMessage(messageText, enhancedContext);
                        console.log("ðŸ“Š SINGLE ChatGPT response:", JSON.stringify(enhancedAiResponse?.data?.entities || {}, null, 2));
                        enhancedEntities = enhancedAiResponse?.data?.entities || null;
                    } catch (chatGptError) {
                        console.error("âŒ SINGLE ChatGPT call failed:", chatGptError.message);
                        enhancedEntities = null;
                    }

                    // If ChatGPT failed, use manual extraction as fallback
                    if (!enhancedEntities) {
                        console.log("ðŸ”„ Using manual extraction as fallback");
                        enhancedEntities = await this.manualEntityExtraction(messageText, foundCategory, categoryMaterials, categoryFinishes);
                    }
                    
                    // Process entities with enhanced context
                    await this.processRemainingEntities(enhancedEntities, updatedData, messageText, foundCategory);

                } catch (contextError) {
                    console.error("âŒ Error in single ChatGPT call approach:", contextError);
                    // Fallback to manual extraction
                    const fallbackEntities = await this.manualEntityExtraction(messageText, foundCategory, [], []);
                    await this.processRemainingEntities(fallbackEntities, updatedData, messageText, foundCategory);
                }
            } else {
                console.log("âš ï¸ No category found, using manual extraction fallback");
                const fallbackEntities = await this.manualEntityExtraction(messageText, null, [], []);
                await this.processRemainingEntities(fallbackEntities, updatedData, messageText, null);
            }

            // Auto-set wantsQuote for greetings with product info
            if (messageText && this.isGreeting(messageText) && (foundCategory || foundProduct)) {
                updatedData.wantsQuote = true;
                console.log("ðŸŽ¯ Auto-setting wantsQuote=true for greeting with product info");
            }

            console.log("âœ… Smart extraction completed with SINGLE ChatGPT call:", JSON.stringify(updatedData, null, 2));
            return updatedData;

        } catch (error) {
            console.error('Error in smartExtractAndUpdateConversationData:', error);
            await mongoLogger.logError(error, {
                source: 'smart-extract-conversation-data',
                messageText: messageText
            });
            // Fallback to original extraction method
            return await this.extractAndUpdateConversationData(aiEntities, currentConversationData, messageText);
        }
    }

    /**
     * Manual entity extraction when ChatGPT fails
     */
    async manualEntityExtraction(messageText, foundCategory, categoryMaterials, categoryFinishes) {
        console.log("ðŸ”§ Starting manual entity extraction for:", messageText);
        const entities = {};
        const lowerMessage = messageText.toLowerCase();

        // Extract quantities - avoid numbers that are part of dimensions (e.g., 6x6)
        // First remove dimension patterns to avoid false quantity matches
        let quantityText = messageText;
        // Remove dimension patterns like "6x6", "5 x 5", "10Ã—8Ã—3"
        quantityText = quantityText.replace(/\d+(?:\.\d+)?\s*[xÃ—]\s*\d+(?:\.\d+)?(?:\s*[xÃ—]\s*\d+(?:\.\d+)?)?/gi, '');
        
        const quantityMatches = quantityText.match(/(\d+(?:,\d{3})*|\d+k|\d+\.\d+k)/gi);
        if (quantityMatches && quantityMatches.length > 0) {
            entities['quantities:quantities'] = quantityMatches.map(match => {
                let value = match.replace(/,/g, '');
                if (value.toLowerCase().includes('k')) {
                    const kMatch = value.match(/(\d+(?:\.\d+)?)k/i);
                    if (kMatch) {
                        value = parseFloat(kMatch[1]) * 1000;
                    }
                } else {
                    value = parseInt(value);
                }
                return {
                    body: match,
                    confidence: 0.9,
                    value: value,
                    type: "value"
                };
            });
            console.log("ðŸ“Š Manual quantity extraction (dimension-filtered):", entities['quantities:quantities']);
        }

        // Extract dimensions
        const dimensionMatches = messageText.match(/(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)/gi);
        if (dimensionMatches) {
            entities['dimensions:dimensions'] = dimensionMatches.map(match => ({
                body: match,
                confidence: 0.9,
                value: match,
                type: "value"
            }));
            console.log("ðŸ“ Manual dimension extraction:", entities['dimensions:dimensions']);
        }

        // Extract SKUs
        const skuMatches = messageText.match(/(\d+)\s*skus?/gi);
        if (skuMatches) {
            entities['skus:skus'] = skuMatches.map(match => {
                const skuNumber = match.match(/(\d+)/)[1];
                return {
                    body: skuNumber,
                    confidence: 0.9,
                    value: parseInt(skuNumber),
                    type: "value"
                };
            });
            console.log("ðŸŽ¨ Manual SKU extraction:", entities['skus:skus']);
        }

        // Extract materials (if category is available)
        if (foundCategory && categoryMaterials.length > 0) {
            const materialEntities = [];
            
            // Check for holographic specifically (highest priority)
            if (lowerMessage.includes('holographic')) {
                const holographicMaterial = categoryMaterials.find(m => 
                    m.name.toLowerCase().includes('holographic')
                );
                if (holographicMaterial) {
                    materialEntities.push({
                        body: 'holographic',
                        confidence: 0.95,
                        value: 'holographic',
                        type: "value"
                    });
                    console.log("ðŸŽ¯ Manual holographic material detection:", holographicMaterial.name);
                }
            }

            // Check for metallized/metallic
            if (lowerMessage.includes('metallized') || lowerMessage.includes('metallic')) {
                const metallicMaterial = categoryMaterials.find(m => 
                    m.name.toLowerCase().includes('mpet') || 
                    m.name.toLowerCase().includes('metallic') || 
                    m.name.toLowerCase().includes('metallized')
                );
                if (metallicMaterial) {
                    const keyword = lowerMessage.includes('metallized') ? 'metallized' : 'metallic';
                    materialEntities.push({
                        body: keyword,
                        confidence: 0.9,
                        value: keyword,
                        type: "value"
                    });
                    console.log(`ðŸ§± Manual metallic material detection: ${keyword} -> ${metallicMaterial.name}`);
                }
            }

            // Check for other material keywords
            const materialKeywords = [
                { keyword: 'kraft', searchTerms: ['kraft'] },
                { keyword: 'pet', searchTerms: ['pet'] },
                { keyword: 'pe', searchTerms: ['pe', 'polyethylene'] },
                { keyword: 'mpet', searchTerms: ['mpet'] },
                { keyword: 'foil', searchTerms: ['foil', 'alu foil', 'alfoil'] },
                { keyword: 'paper', searchTerms: ['paper'] }
            ];
            
            for (const materialKeyword of materialKeywords) {
                if (materialKeyword.searchTerms.some(term => lowerMessage.includes(term))) {
                    const foundMaterial = categoryMaterials.find(m => 
                        materialKeyword.searchTerms.some(term => 
                            m.name.toLowerCase().includes(term)
                        )
                    );
                    if (foundMaterial) {
                        // Avoid duplicates
                        const alreadyAdded = materialEntities.some(entity => 
                            entity.value === materialKeyword.keyword
                        );
                        if (!alreadyAdded) {
                            materialEntities.push({
                                body: materialKeyword.keyword,
                                confidence: 0.8,
                                value: materialKeyword.keyword,
                                type: "value"
                            });
                            console.log(`ðŸ§± Manual material detection: ${materialKeyword.keyword} -> ${foundMaterial.name}`);
                        }
                    }
                }
            }

            if (materialEntities.length > 0) {
                entities['material:material'] = materialEntities;
            }
        }

        // Extract finishes (if category is available)
        if (foundCategory && categoryFinishes.length > 0) {
            const finishEntities = [];
            
            // Define material keywords that should NOT be treated as finishes
            const materialKeywords = ['holographic', 'metallic', 'metallized', 'kraft', 'pet', 'pe', 'mpet', 'foil', 'paper', 'polyethylene'];
            
            // Common finish keywords (excluding material keywords)
            const finishKeywords = ['spot uv', 'uv coating', 'matte', 'gloss', 'emboss', 'deboss', 'varnish', 'lamination'];
            
            for (const keyword of finishKeywords) {
                if (lowerMessage.includes(keyword)) {
                    // Double check this isn't a material keyword
                    const isMaterialKeyword = materialKeywords.some(matKeyword => 
                        keyword.toLowerCase().includes(matKeyword) || 
                        lowerMessage.includes(matKeyword + ' ' + keyword) ||
                        lowerMessage.includes(keyword + ' ' + matKeyword)
                    );
                    
                    if (!isMaterialKeyword) {
                        const foundFinish = categoryFinishes.find(f => 
                            f.name.toLowerCase().includes(keyword)
                        );
                        if (foundFinish) {
                            finishEntities.push({
                                body: keyword,
                                confidence: 0.85,
                                value: keyword,
                                type: "value"
                            });
                            console.log(`âœ¨ Manual finish detection: ${keyword} -> ${foundFinish.name}`);
                        }
                    } else {
                        console.log(`ðŸš« Skipped "${keyword}" - identified as material keyword, not finish`);
                    }
                }
            }

            if (finishEntities.length > 0) {
                entities['finishes:finishes'] = finishEntities;
            }
        }

        console.log("ðŸ”§ Manual extraction completed:", JSON.stringify(entities, null, 2));
        return entities;
    }

    /**
     * Process remaining entities (dimensions, quantities, materials, finishes, SKUs)
     */
    async processRemainingEntities(entities, updatedData, messageText, foundCategory) {
        console.log("ðŸ”„ Processing remaining entities:", Object.keys(entities));

        const entityProcessingOrder = [
            'dimensions:dimensions',
            'quantities:quantities',
            'material:material',
            'finishes:finishes',
            'skus:skus'
        ];

        for (const entityType of entityProcessingOrder) {
            if (entities[entityType] && Array.isArray(entities[entityType])) {
                for (const entity of entities[entityType]) {
                    const { value, confidence, body } = entity;
                    console.log(`ðŸ” Processing ${entityType}:`, { value, confidence, body });

                    if (confidence > 0.5) {
                        await this.processEntityByType(entityType, entity, updatedData, messageText, foundCategory);
                    }
                }
            }
        }

        // Post-processing: Check if any finishes should actually be materials
        if (foundCategory && entities['finishes:finishes']) {
            await this.correctMisclassifiedMaterials(entities, updatedData, foundCategory);
        }
    }

    /**
     * Process individual entity by type
     */
    async processEntityByType(entityType, entity, updatedData, messageText, foundCategory) {
        const { value, confidence, body } = entity;

        switch (entityType) {
            case 'dimensions:dimensions':
                const dimensions = value || body;
                const dimensionValues = this.parseDimensionValues(dimensions);
                
                if (updatedData.selectedProduct && dimensionValues.length > 0) {
                    const product = await conversationService.getProductById(updatedData.selectedProduct.id);
                    if (product && product.dimensionFields) {
                        if (!updatedData.dimensions) updatedData.dimensions = [];
                        
                        product.dimensionFields.forEach((field, index) => {
                            if (dimensionValues[index] !== undefined) {
                                const existingDimension = updatedData.dimensions.find(d => d.name === field.name);
                                if (!existingDimension) {
                                    updatedData.dimensions.push({
                                        name: field.name,
                                        value: dimensionValues[index]
                                    });
                                }
                            }
                        });
                    }
                }
                break;

            case 'quantities:quantities':
                if (!this.isDimensionMessage(messageText)) {
                    const quantities = Array.isArray(entity) ? entity.map(e => e.value || e.body) : [value || body];
                    if (!updatedData.quantity) updatedData.quantity = [];
                    
                    for (const quantity of quantities) {
                        const cleanQuantity = quantity.toString().replace(/,/g, '');
                        let numericQuantity = parseInt(cleanQuantity);
                        
                        if (cleanQuantity.toLowerCase().includes('k')) {
                            const kMatch = cleanQuantity.toLowerCase().match(/(\d+(?:\.\d+)?)k/);
                            if (kMatch) {
                                numericQuantity = parseFloat(kMatch[1]) * 1000;
                            }
                        }
                        
                        if (!isNaN(numericQuantity) && !updatedData.quantity.includes(numericQuantity)) {
                            updatedData.quantity.push(numericQuantity);
                            console.log(`âœ… Added quantity: ${numericQuantity}`);
                        }
                    }
                }
                break;

            case 'material:material':
                if (confidence >= 0.5) { // Lower threshold for materials
                    const materials = Array.isArray(entity) ? entity.map(e => e.value || e.body) : [value || body];
                    
                    if (foundCategory) {
                        const foundMaterials = [];
                        for (const material of materials) {
                            const findMaterial = await this.findMaterialByName(material, foundCategory._id.toString());
                            if (findMaterial) {
                                foundMaterials.push({
                                    _id: findMaterial.erp_id.toString(),
                                    name: findMaterial.name,
                                    erp_id: findMaterial.erp_id
                                });
                                console.log("ðŸš¨ SMART-SELECTED MATERIAL:", findMaterial.name);
                            } else {
                                // Store as requested material for manual matching later
                                if (!updatedData.requestedMaterial) {
                                    updatedData.requestedMaterial = material;
                                } else {
                                    updatedData.requestedMaterial += ` + ${material}`;
                                }
                                console.log("ðŸ” Material not found in database, storing as requested:", material);
                            }
                        }
                        if (foundMaterials.length > 0) {
                            updatedData.selectedMaterial = foundMaterials;
                        }
                    }
                }
                break;

            case 'finishes:finishes':
                const finishes = value || body;
                const categoryId = foundCategory?._id?.toString();
                
                const findFinish = await this.findFinishByName(finishes, categoryId, messageText);
                if (findFinish) {
                    if (!updatedData.selectedFinish) updatedData.selectedFinish = [];
                    
                    const finishExists = updatedData.selectedFinish.some(f => f._id === findFinish.erp_id.toString());
                    if (!finishExists) {
                        updatedData.selectedFinish.push({
                            _id: findFinish.erp_id.toString(),
                            name: findFinish.name
                        });
                        console.log("ðŸš¨ SMART-SELECTED FINISH:", findFinish.name);
                    }
                }
                break;

            case 'skus:skus':
                const skuValue = value || body;
                const cleanSku = skuValue.toString().replace(/,/g, '');
                const skuNum = parseInt(cleanSku);
                
                updatedData.skus = !isNaN(skuNum) ? skuNum : skuValue;
                console.log("âœ… Stored SKU:", updatedData.skus);
                break;
        }
    }

    /**
     * Correct misclassified materials that were tagged as finishes
     */
    async correctMisclassifiedMaterials(entities, updatedData, foundCategory) {
        console.log("ðŸ” Checking for misclassified materials in finishes...");
        
        const finishEntities = entities['finishes:finishes'] || [];
        const materialKeywords = ['holographic', 'metallic', 'metallized', 'kraft', 'pet', 'pe', 'mpet', 'foil', 'paper'];
        
        for (const finishEntity of finishEntities) {
            const finishValue = (finishEntity.value || finishEntity.body).toLowerCase();
            
            // Check if this "finish" is actually a material keyword
            if (materialKeywords.some(keyword => finishValue.includes(keyword))) {
                console.log(`ðŸ”„ Checking if "${finishValue}" should be a material instead of finish...`);
                
                // Try to find this as a material
                const foundMaterial = await this.findMaterialByName(finishValue, foundCategory._id.toString());
                
                if (foundMaterial) {
                    console.log(`âœ… CORRECTED: "${finishValue}" is a material, not a finish!`);
                    
                    // Add to materials
                    if (!updatedData.selectedMaterial) {
                        updatedData.selectedMaterial = [];
                    }
                    
                    const materialExists = updatedData.selectedMaterial.some(m => m.erp_id === foundMaterial.erp_id);
                    if (!materialExists) {
                        updatedData.selectedMaterial.push({
                            _id: foundMaterial.erp_id.toString(),
                            name: foundMaterial.name,
                            erp_id: foundMaterial.erp_id
                        });
                    }
                    
                    // Remove from finishes if it was added there
                    if (updatedData.selectedFinish) {
                        updatedData.selectedFinish = updatedData.selectedFinish.filter(f => 
                            !f.name.toLowerCase().includes(finishValue)
                        );
                    }
                    
                    console.log(`ðŸš¨ MATERIAL CORRECTION: Added "${foundMaterial.name}" as material`);
                } else {
                    // Store as requested material if not found in database
                    if (!updatedData.requestedMaterial) {
                        updatedData.requestedMaterial = finishValue;
                    } else if (!updatedData.requestedMaterial.includes(finishValue)) {
                        updatedData.requestedMaterial += ` + ${finishValue}`;
                    }
                    console.log(`ðŸ” Material-like finish "${finishValue}" stored as requested material`);
                }
            }
        }
    }

    /**
     * Fuzzy search for category in message text
     */
    async fuzzySearchCategory(messageText) {
        try {
            const categories = await conversationService.getProductCategories();
            const lowerMessage = messageText.toLowerCase();
            
            // Try exact matches first
            for (const category of categories) {
                if (lowerMessage.includes(category.name.toLowerCase())) {
                    console.log(`ðŸŽ¯ Exact category match: "${category.name}"`);
                    return category;
                }
                
                // Check sub_names if available
                if (category.sub_names && category.sub_names.some(sub => 
                    lowerMessage.includes(sub.toLowerCase()))) {
                    console.log(`ðŸŽ¯ Category sub_name match: "${category.name}"`);
                    return category;
                }
            }
            
            // Try partial matches and common patterns
            const categoryKeywords = [
                { patterns: ['flat', 'pouch'], category: 'mylar bags' },
                { patterns: ['stand', 'up'], category: 'mylar bags' },
                { patterns: ['folding', 'carton'], category: 'folding cartons' },
                { patterns: ['rigid', 'box'], category: 'rigid boxes' },
                { patterns: ['label'], category: 'labels' }
            ];
            
            for (const keyword of categoryKeywords) {
                if (keyword.patterns.every(pattern => lowerMessage.includes(pattern))) {
                    const foundCategory = categories.find(cat => 
                        cat.name.toLowerCase().includes(keyword.category.toLowerCase())
                    );
                    if (foundCategory) {
                        console.log(`ðŸŽ¯ Pattern-based category match: "${foundCategory.name}"`);
                        return foundCategory;
                    }
                }
            }
            
            return null;
        } catch (error) {
            console.error('Error in fuzzySearchCategory:', error);
            return null;
        }
    }

    /**
     * Fuzzy search for product in message text
     */
    async fuzzySearchProduct(messageText) {
        try {
            const products = await Product.find({ isActive: true }).sort({ sortOrder: 1, name: 1 });
            const lowerMessage = messageText.toLowerCase();
            
            // Try exact matches first
            for (const product of products) {
                if (lowerMessage.includes(product.name.toLowerCase())) {
                    console.log(`ðŸŽ¯ Exact product match: "${product.name}"`);
                    return product;
                }
            }
            
            // Try pattern matches
            const productPatterns = [
                { pattern: /flat\s*pouch/i, name: 'flat pouch' },
                { pattern: /stand\s*up\s*pouch/i, name: 'stand up pouch' },
                { pattern: /folding\s*carton/i, name: 'folding carton' },
                { pattern: /rigid\s*box/i, name: 'rigid box' }
            ];
            
            for (const patternObj of productPatterns) {
                if (patternObj.pattern.test(messageText)) {
                    const foundProduct = products.find(p => 
                        p.name.toLowerCase().includes(patternObj.name.toLowerCase())
                    );
                    if (foundProduct) {
                        console.log(`ðŸŽ¯ Pattern-based product match: "${foundProduct.name}"`);
                        return foundProduct;
                    }
                }
            }
            
            return null;
        } catch (error) {
            console.error('Error in fuzzySearchProduct:', error);
            return null;
        }
    }

    /**
     * Extract entities from Wit.ai response and update conversation data
     */
    async extractAndUpdateConversationData(entities, currentConversationData, messageText = '') {
        try {
            // Skip entity processing only for simple greetings without product information
            if (messageText && this.isGreeting(messageText) && !this.hasProductInformation(messageText)) {
                console.log("ðŸŽ¯ Skipping entity extraction for simple greeting message:", messageText);
                return currentConversationData;
            }

            const updatedData = { ...currentConversationData };
            console.log("Processing entities:", entities);

            // Define processing order for entities
            const customOrder = [
                "category:category",
                "product:product",
                "dimensions:dimensions",
                "material:material",
                "finishes:finishes",
                "quantities:quantities",
                "skus:skus"
            ];

            // Sort entities based on custom order
            const sortedEntityEntries = Object.entries(entities).sort(([a], [b]) => {
                const indexA = customOrder.indexOf(a);
                const indexB = customOrder.indexOf(b);

                // If both are in custom order, sort by their position
                if (indexA !== -1 && indexB !== -1) {
                    return indexA - indexB;
                }
                // If only A is in custom order, A comes first
                if (indexA !== -1) {
                    return -1;
                }
                // If only B is in custom order, B comes first
                if (indexB !== -1) {
                    return 1;
                }
                // If neither is in custom order, maintain original order
                return 0;
            });

            // Process each entity type in sorted order
            for (const [entityType, entityArray] of sortedEntityEntries) {
                console.log(`ðŸ” Processing entity type: ${entityType}`, JSON.stringify(entityArray, null, 2));

                for (const entity of entityArray) {
                    try {
                        const { value, confidence, body } = entity;
                        console.log(`ðŸ“ Entity Details - Type: ${entityType}`, { 
                            value, 
                            confidence, 
                            body,
                            fullEntity: JSON.stringify(entity, null, 2)
                        });

                        if (confidence > 0.5) {
                            switch (entityType) {
                                case 'category:category':
                                    // Search for category in ProductCategory schema
                                    const foundCategory = await this.findCategoryByName(value || body);
                                    if (foundCategory) {
                                        updatedData.selectedCategory = {
                                            id: foundCategory._id.toString(),
                                            erp_id: foundCategory.erp_id,
                                            name: foundCategory.name,
                                            description: foundCategory.description
                                        };
                                        
                                        // If this is a greeting message with category, auto-set wantsQuote to true
                                        if (messageText && this.isGreeting(messageText)) {
                                            updatedData.wantsQuote = true;
                                            console.log("ðŸŽ¯ Auto-setting wantsQuote=true for greeting with category:", foundCategory.name);
                                        }
                                        
                                        // Process any stored materials now that we have a category
                                        if (updatedData.requestedMaterial && (!updatedData.selectedMaterial || updatedData.selectedMaterial.length === 0)) {
                                            console.log("ðŸ”„ Processing stored materials with newly selected category:", foundCategory.name);
                                            const storedMaterials = updatedData.requestedMaterial.split(' + ');
                                            const foundMaterials = [];
                                            let newRequestedMaterials = [];
                                            
                                            for (const material of storedMaterials) {
                                                console.log(`ðŸ” Re-processing material "${material}" with category filter: ${foundCategory._id}`);
                                                const findMaterial = await this.findMaterialByName(material.trim(), foundCategory._id.toString());
                                                if (findMaterial) {
                                                    foundMaterials.push({
                                                        _id: findMaterial.erp_id.toString(),
                                                        name: findMaterial.name,
                                                        erp_id: findMaterial.erp_id
                                                    });
                                                    console.log("ðŸš¨ CATEGORY-FILTERED MATERIAL:", findMaterial.name, "ERP ID:", findMaterial.erp_id);
                                                } else {
                                                    newRequestedMaterials.push(material);
                                                    console.log("Material not found in selected category, keeping as requested:", material);
                                                }
                                            }
                                            
                                            if (foundMaterials.length > 0) {
                                                updatedData.selectedMaterial = foundMaterials;
                                                // Clear requestedMaterial since we found matches
                                                if (newRequestedMaterials.length === 0) {
                                                    updatedData.requestedMaterial = null;
                                                } else {
                                                    updatedData.requestedMaterial = newRequestedMaterials.join(' + ');
                                                }
                                            }
                                        }
                                        
                                        // console.log("Found category:", foundCategory.name);
                                    } else {
                                        updatedData.requestedCategory = value || body;
                                        console.log("Category not found, stored as requested:", value || body);
                                    }
                                    break;

                                case 'product:product':
                                    console.log(`ðŸŽ¯ Product entity detected - Value: "${value || body}", Confidence: ${confidence}`);
                                    
                                    // Use slightly lower confidence for product detection to catch more cases
                                    if (confidence < 0.4) {
                                        console.log(`ðŸš« Product entity confidence too low (${confidence}) for auto-selection:`, value || body);
                                        // Still store as requested product for manual fallback
                                        updatedData.requestedProductName = value || body;
                                        break;
                                    }

                                    // Only update product if not already selected (prevent overriding during material/finish selection)
                                    if (!currentConversationData.selectedProduct || !currentConversationData.selectedProduct.id) {
                                        // Search for product in Product schema
                                        const foundProduct = await this.findProductByName(value || body, updatedData);
                                        if (foundProduct) {
                                            updatedData.selectedProduct = {
                                                id: foundProduct._id.toString(),
                                                erp_id: foundProduct.erp_id,
                                                name: foundProduct.name,
                                                description: foundProduct.description,
                                                basePrice: foundProduct.basePrice
                                            };
                                            const foundCategory = await this.findCategoryById(foundProduct.categoryId);
                                            if (foundCategory) {
                                                updatedData.selectedCategory = {
                                                    id: foundCategory._id.toString(),
                                                    erp_id: foundCategory.erp_id,
                                                    name: foundCategory.name,
                                                    description: foundCategory.description
                                                };
                                            }
                                            // If this is a greeting message with product, auto-set wantsQuote to true
                                            if (messageText && this.isGreeting(messageText)) {
                                                updatedData.wantsQuote = true;
                                                console.log("ðŸŽ¯ Auto-setting wantsQuote=true for greeting with product:", foundProduct.name);
                                            }
                                        } else {
                                            updatedData.requestedProductName = value || body;
                                            // console.log("Product not found, stored as requested:", value || body);
                                        }
                                    } else {
                                        console.log("Product already selected, skipping extraction to prevent override:", currentConversationData.selectedProduct.name);
                                    }
                                    break;

                                case 'dimensions:dimensions':
                                    const dimensions = value || body;

                                    // Parse dimension values from the string
                                    const dimensionValues = this.parseDimensionValues(dimensions);

                                    // Check if we have a selected product
                                    if (updatedData.selectedProduct && updatedData.selectedProduct.id) {
                                        try {
                                            // Get the product with dimension fields
                                            const product = await conversationService.getProductById(updatedData.selectedProduct.id);

                                            if (product && product.dimensionFields && dimensionValues.length > 0) {
                                                // Initialize dimensions array if not exists
                                                if (!updatedData.dimensions) {
                                                    updatedData.dimensions = [];
                                                }

                                                // Map dimension values to product dimension fields
                                                product.dimensionFields.forEach((field, index) => {
                                                    if (dimensionValues[index] !== undefined) {
                                                        // Check if dimension already exists
                                                        const existingDimension = updatedData.dimensions.find(d => d.name === field.name);
                                                        if (!existingDimension) {
                                                            updatedData.dimensions.push({
                                                                name: field.name,
                                                                value: dimensionValues[index]
                                                            });
                                                            // console.log("Added dimension:", field.name, "=", dimensionValues[index]);
                                                        }
                                                    }
                                                });

                                                // console.log("Final dimensions array:", updatedData.dimensions);
                                            } else {
                                                console.log("No product dimension fields or no valid dimension values found");
                                            }
                                        } catch (error) {
                                            console.error("Error processing dimensions:", error);
                                        }
                                    } else {
                                        // console.log("No selected product found, skipping dimension processing");
                                    }
                                    break;
                                case 'finishes:finishes':
                                    const finishes = value || body;
                                    
                                    // Get categoryId for filtering
                                    const categoryId = updatedData.selectedCategory?.id || currentConversationData.selectedCategory?.id || null;
                                    console.log("ðŸ” Searching for finish with category filter:", { finishes, categoryId, fullMessage: messageText });
                                    
                                    const findFinish = await this.findFinishByName(finishes, categoryId, messageText);
                                    if (findFinish) {
                                        // Initialize selectedFinish array if it doesn't exist
                                        if (!updatedData.selectedFinish) {
                                            updatedData.selectedFinish = [];
                                        }
                                        // Check if finish already exists to avoid duplicates
                                        const finishExists = updatedData.selectedFinish.some(f => f._id === findFinish.erp_id.toString());
                                        if (!finishExists) {
                                            // Push only _id and name
                                            updatedData.selectedFinish.push({
                                                _id: findFinish.erp_id.toString(),
                                                name: findFinish.name
                                            });
                                            console.log("ðŸš¨ AUTO-SELECTED FINISH:", findFinish.name, "ERP ID:", findFinish.erp_id);
                                        }
                                    } else {
                                        // Store as requested finish for later processing
                                        if (!updatedData.requestedFinish) {
                                            updatedData.requestedFinish = finishes;
                                        } else {
                                            updatedData.requestedFinish += ` + ${finishes}`;
                                        }
                                        console.log("Finish not found in category, storing as requested:", finishes);
                                    }
                                    break;
                                case 'material:material':
                                    // Add confidence check for material auto-selection to prevent false positives
                                    if (confidence < 0.8) {
                                        console.log(`ðŸš« Material entity confidence too low (${confidence}) for auto-selection:`, value || body);
                                        break;
                                    }

                                    const materials = Array.isArray(entities[entityType]) ? 
                                        entities[entityType].map(e => e.value || e.body) : 
                                        [value || body];
                                    
                                    console.log("ðŸš¨ MATERIAL ENTITY DETECTED:", {
                                        materials,
                                        confidence,
                                        originalEntity: entities[entityType],
                                        messageText,
                                        hasExistingMaterial: !!(currentConversationData.selectedMaterial && currentConversationData.selectedMaterial.length > 0)
                                    });
                                    
                                    // Only update materials if not already confirmed
                                    if (!currentConversationData.selectedMaterial || currentConversationData.selectedMaterial.length === 0) {
                                        // Check if we have a category to filter by
                                        const categoryId = updatedData.selectedCategory?.id || currentConversationData.selectedCategory?.id || null;
                                        
                                        if (!categoryId) {
                                            // No category selected yet - store materials as requested for later processing
                                            console.log("â³ No category selected yet, storing materials as requested for later processing");
                                            updatedData.requestedMaterial = materials.join(' + ');
                                        } else {
                                            // Category available - search for materials within that category
                                            const foundMaterials = [];
                                            let requestedMaterials = [];
                                            
                                            for (const material of materials) {
                                                console.log(`ðŸ” Material search for "${material}" with category filter: ${categoryId}`);
                                                const findMaterial = await this.findMaterialByName(material, categoryId);
                                                if (findMaterial) {
                                                    foundMaterials.push({
                                                        _id: findMaterial.erp_id.toString(),
                                                        name: findMaterial.name,
                                                        erp_id: findMaterial.erp_id
                                                    });
                                                    console.log("ðŸš¨ AUTO-SELECTED MATERIAL:", findMaterial.name, "ERP ID:", findMaterial.erp_id);
                                                } else {
                                                    requestedMaterials.push(material);
                                                    console.log("Material not found in category, storing as requested:", material);
                                                }
                                            }
                                            
                                            if (foundMaterials.length > 0) {
                                                updatedData.selectedMaterial = foundMaterials;
                                            }
                                            if (requestedMaterials.length > 0) {
                                                updatedData.requestedMaterial = requestedMaterials.join(' + ');
                                            }
                                        }
                                    } else {
                                        console.log("Materials already selected, skipping extraction to prevent override");
                                    }
                                    break;
                                case 'quantities:quantities':
                                    // Don't extract quantity if this looks like a dimension string
                                    if (messageText && this.isDimensionMessage(messageText)) {
                                        console.log("Skipping quantity extraction - detected dimension message:", messageText);
                                        break;
                                    }
                                    
                                    const quantities = Array.isArray(entities[entityType]) ? 
                                        entities[entityType].map(e => e.value || e.body) : 
                                        [value || body];
                                    
                                    console.log("ðŸ”¢ QUANTITY ENTITIES DETECTED:", {
                                        quantities,
                                        originalEntity: entities[entityType],
                                        messageText
                                    });
                                    
                                    if (!updatedData.quantity) {
                                        updatedData.quantity = [];
                                    }
                                    
                                    for (const quantity of quantities) {
                                        // Convert to number for comparison - handle comma-separated numbers and "k" notation
                                        const cleanQuantity = quantity.toString().replace(/,/g, '');
                                        
                                        // Handle "k" notation (e.g., "19k" -> 19000)
                                        let numericQuantity;
                                        if (cleanQuantity.toLowerCase().includes('k')) {
                                            // Extract number before 'k' and multiply by 1000
                                            const kMatch = cleanQuantity.toLowerCase().match(/(\d+(?:\.\d+)?)k/);
                                            if (kMatch) {
                                                numericQuantity = parseFloat(kMatch[1]) * 1000;
                                                console.log(`Converted "${cleanQuantity}" to ${numericQuantity} (k notation)`);
                                            } else {
                                                numericQuantity = parseInt(cleanQuantity);
                                            }
                                        } else {
                                            numericQuantity = parseInt(cleanQuantity);
                                        }
                                        
                                        if (!isNaN(numericQuantity) && !updatedData.quantity.includes(numericQuantity)) {
                                            updatedData.quantity.push(numericQuantity);
                                            console.log(`Added quantity: ${numericQuantity} (from "${quantity}")`);
                                        }
                                    }
                                    break;
                                case 'skus:skus':
                                case 'sku:sku':
                                    console.log("ðŸŽ¯ Processing SKU entity:", { value, body, confidence });
                                    const skuValue = value || body;
                                    console.log("ðŸ“¦ SKU value extracted:", skuValue);
                                    
                                    // Store SKU as single value, not array
                                    const cleanSku = skuValue.toString().replace(/,/g, '');
                                    const skuNum = parseInt(cleanSku);
                                    
                                    console.log("ðŸ”¢ SKU number conversion:", { cleanSku, skuNum, isNaN: isNaN(skuNum) });
                                    
                                    if (!isNaN(skuNum)) {
                                        updatedData.skus = skuNum;
                                        console.log("âœ… Stored numeric SKU:", skuNum);
                                    } else {
                                        updatedData.skus = skuValue;
                                        console.log("âœ… Stored string SKU:", skuValue);
                                    }
                                    
                                    console.log("ðŸ“Š Current skus value:", updatedData.skus);
                                    break;
                                default:
                                    // Check if this is a SKU-related entity that we missed
                                    if (entityType.includes('sku') || entityType.includes('SKU')) {
                                        console.log("ðŸŽ¯ Processing potential SKU entity (fallback):", { entityType, value, body, confidence });
                                        const skuValue = value || body;
                                        
                                        const cleanSku = skuValue.toString().replace(/,/g, '');
                                        const skuNum = parseInt(cleanSku);
                                        
                                        if (!isNaN(skuNum)) {
                                            updatedData.skus = skuNum;
                                            console.log("âœ… Stored SKU via fallback:", skuNum);
                                        } else {
                                            updatedData.skus = skuValue;
                                            console.log("âœ… Stored SKU string via fallback:", skuValue);
                                        }
                                    }
                                    break;
                        }
                        }
                    } catch (entityError) {
                        console.error(`Error processing entity ${entityType}:`, entityError);
                        await mongoLogger.logError(entityError, {
                            source: 'entity-processor',
                            entityType: entityType,
                            entity: entity
                        });
                        // Continue processing other entities
                    }
                }
            }

            // Fallback: If no product was detected by AI, try manual product pattern matching
            if (!updatedData.selectedProduct && !updatedData.requestedProductName && messageText) {
                console.log("ðŸ” No product detected by AI, trying manual pattern matching...");
                await this.tryManualProductDetection(messageText, updatedData);
            }

            console.log("âœ… Final Updated Conversation Data:", JSON.stringify(updatedData, null, 2));
            console.log("ðŸ” Checking for SKUs in final data:", {
                hasSkus: !!updatedData.skus,
                skusValue: updatedData.skus,
                skusType: typeof updatedData.skus
            });
            return updatedData;
        } catch (error) {
            console.error('Error in extractAndUpdateConversationData:', error);
            await mongoLogger.logError(error, {
                source: 'extract-conversation-data',
                entities: entities
            });
            // Return original data if extraction fails
            return currentConversationData;
        }
    }

    /**
     * Try to detect product names from message text using pattern matching
     */
    async tryManualProductDetection(messageText, updatedData) {
        try {
            console.log(`ðŸ” Manual product detection for: "${messageText}"`);
            
            // Common product name patterns
            const productPatterns = [
                /\b(flat\s*pouch)\b/i,
                /\b(stand\s*up\s*pouch)\b/i,
                /\b(standup\s*pouch)\b/i,
                /\b(side\s*gusset\s*bag)\b/i,
                /\b(bottom\s*gusset\s*bag)\b/i,
                /\b(roll\s*stock)\b/i,
                /\b(spouted\s*pouch)\b/i,
                /\b(zipper\s*pouch)\b/i,
                /\b(valve\s*bag)\b/i
            ];

            let detectedProduct = null;
            
            for (const pattern of productPatterns) {
                const match = messageText.match(pattern);
                if (match) {
                    const productName = match[1];
                    console.log(`ðŸŽ¯ Pattern matched: "${productName}"`);
                    
                    // Try to find this product in database
                    const foundProduct = await this.findProductByName(productName, updatedData);
                    if (foundProduct) {
                        console.log(`âœ… Manual detection found product: ${foundProduct.name}`);
                        
                        updatedData.selectedProduct = {
                            id: foundProduct._id.toString(),
                            erp_id: foundProduct.erp_id,
                            name: foundProduct.name,
                            description: foundProduct.description,
                            basePrice: foundProduct.basePrice
                        };
                        
                        // Also set category from product
                        const foundCategory = await this.findCategoryById(foundProduct.categoryId);
                        if (foundCategory) {
                            updatedData.selectedCategory = {
                                id: foundCategory._id.toString(),
                                erp_id: foundCategory.erp_id,
                                name: foundCategory.name,
                                description: foundCategory.description
                            };
                            console.log(`âœ… Auto-detected category from product: ${foundCategory.name}`);
                        }
                        
                        detectedProduct = foundProduct;
                        break;
                    }
                }
            }

            if (!detectedProduct) {
                console.log("âŒ No product patterns matched in manual detection");
            }
            
        } catch (error) {
            console.error('Error in manual product detection:', error);
        }
    }

    /**
     * Find category by name in ProductCategory schema
     */
    async findCategoryByName(categoryName) {
        try {
            const categories = await conversationService.getProductCategories();

            // Apply common spelling corrections
            let normalizedCategoryName = categoryName.toLowerCase();
            
            // Common spelling variations (incorrect â†’ correct)
            const spellingCorrections = {
                'mylor': 'mylar',  // Common misspelling of Mylar
                'pa': 'polyamide',
                'pe': 'polyethylene', 
                'pp': 'polypropylene',
                'kraft': 'kraft paper'
            };
            
            // Apply spelling corrections
            for (const [incorrect, correct] of Object.entries(spellingCorrections)) {
                if (normalizedCategoryName.includes(incorrect)) {
                    normalizedCategoryName = normalizedCategoryName.replace(incorrect, correct);
                    console.log(`ðŸ”§ Spelling correction applied: "${incorrect}" â†’ "${correct}"`);
                }
            }

            // Function to normalize text for comparison (handle hyphens, spaces)
            const normalizeForComparison = (text) => {
                return text.toLowerCase()
                    .replace(/[-\s]+/g, ' ')  // Replace hyphens and multiple spaces with single space
                    .replace(/\s+/g, '')      // Remove all spaces for comparison
                    .trim();
            };

            // Search in name field with original name
            let foundCategory = categories.find(cat =>
                cat.name.toLowerCase().includes(categoryName.toLowerCase())
            );

            // Search with corrected name if original didn't match
            if (!foundCategory && normalizedCategoryName !== categoryName.toLowerCase()) {
                foundCategory = categories.find(cat =>
                    cat.name.toLowerCase().includes(normalizedCategoryName)
                );
                
                if (foundCategory) {
                    console.log(`âœ… Found category "${foundCategory.name}" using spelling correction for "${categoryName}"`);
                }
            }

            // If not found, try normalized comparison (handles spacing/hyphen differences)
            if (!foundCategory) {
                const normalizedInput = normalizeForComparison(categoryName);
                foundCategory = categories.find(cat => {
                    const normalizedCatName = normalizeForComparison(cat.name);
                    return normalizedCatName.includes(normalizedInput) || normalizedInput.includes(normalizedCatName);
                });
                
                if (foundCategory) {
                    console.log(`âœ… Found category "${foundCategory.name}" using normalized matching for "${categoryName}"`);
                }
            }

            // If not found in name, search in sub_names with original name
            if (!foundCategory) {
                foundCategory = categories.find(cat =>
                    cat.sub_names && cat.sub_names.some(subName =>
                        subName.toLowerCase().includes(categoryName.toLowerCase())
                    )
                );
            }

            // If still not found, search sub_names with corrected name
            if (!foundCategory && normalizedCategoryName !== categoryName.toLowerCase()) {
                foundCategory = categories.find(cat =>
                    cat.sub_names && cat.sub_names.some(subName =>
                        subName.toLowerCase().includes(normalizedCategoryName)
                    )
                );
            }

            // If still not found, try normalized comparison in sub_names
            if (!foundCategory) {
                const normalizedInput = normalizeForComparison(categoryName);
                foundCategory = categories.find(cat =>
                    cat.sub_names && cat.sub_names.some(subName => {
                        const normalizedSubName = normalizeForComparison(subName);
                        return normalizedSubName.includes(normalizedInput) || normalizedInput.includes(normalizedSubName);
                    })
                );
                
                if (foundCategory) {
                    console.log(`âœ… Found category "${foundCategory.name}" using normalized sub_names matching for "${categoryName}"`);
                }
            }

            return foundCategory;
        } catch (error) {
            console.error('Error finding category by name:', error);
            return null;
        }
    }

    /**
     * Find category by ID in ProductCategory schema
     */
    async findCategoryById(categoryId) {
        try {
            // Convert ObjectId to string if needed
            const categoryIdString = categoryId.toString();
            console.log("categoryIdString ", categoryIdString);

            // First try to find by MongoDB ObjectId
            let category = await ProductCategory.findById(categoryIdString);

            // If not found and it's a number, try finding by ERP ID
            if (!category && !isNaN(parseInt(categoryIdString))) {
                category = await ProductCategory.findOne({ erp_id: parseInt(categoryIdString) });
                console.log("Found category by ERP ID:", category?.name);
            }

            return category;
        } catch (error) {
            console.error('Error finding category by ID:', error);
            return null;
        }
    }

    /**
     * Find product by name in Product schema
     */
    async findProductByName(productName, conversationData = {}) {
        try {
            console.log(`ðŸ” Searching for product: "${productName}"`);
            
            // Search all active products
            const products = await Product.find({ isActive: true }).sort({ sortOrder: 1, name: 1 });
            console.log(`ðŸ“‹ Available products: ${products.map(p => p.name).join(', ')}`);

            // Normalize search term for better matching
            const normalizedSearch = productName.toLowerCase().trim();

            // 1. Try exact name match first
            let foundProduct = products.find(product =>
                product.name.toLowerCase() === normalizedSearch
            );

            // 2. Try name contains search (existing logic)
            if (!foundProduct) {
                foundProduct = products.find(product =>
                    product.name.toLowerCase().includes(normalizedSearch)
                );
            }

            // 3. Try reverse contains (search term contains product name)
            if (!foundProduct) {
                foundProduct = products.find(product => {
                    const productWords = product.name.toLowerCase().split(/\s+/);
                    return productWords.some(word => normalizedSearch.includes(word) && word.length > 2);
                });
            }

            // 4. Try word-by-word matching for compound names like "flat pouch"
            if (!foundProduct) {
                const searchWords = normalizedSearch.split(/\s+/);
                foundProduct = products.find(product => {
                    const productWords = product.name.toLowerCase().split(/\s+/);
                    return searchWords.length >= 2 && 
                           searchWords.every(word => 
                               productWords.some(pWord => pWord.includes(word) || word.includes(pWord))
                           );
                });
            }

            // 5. If not found in name, search in description
            if (!foundProduct) {
                foundProduct = products.find(product =>
                    product.description && product.description.toLowerCase().includes(normalizedSearch)
                );
            }

            // 6. If not found in description, search in erp_id
            if (!foundProduct) {
                const erpId = parseInt(productName);
                if (!isNaN(erpId)) {
                    foundProduct = products.find(product => product.erp_id === erpId);
                }
            }

            if (foundProduct) {
                console.log(`âœ… Found product match: "${foundProduct.name}" (ERP: ${foundProduct.erp_id})`);
            } else {
                console.log(`âŒ No product match found for: "${productName}"`);
            }

            return foundProduct;
        } catch (error) {
            console.error('Error finding product by name:', error);
            return null;
        }
    }

    async findFinishByName(finishName, categoryId = null, fullMessage = null) {
        try {
            console.log("ðŸ” Searching for finish:", finishName, categoryId ? `in category: ${categoryId}` : 'across all categories');
            
            // Search finishes - filter by category if provided
            const searchQuery = { isActive: true };
            if (categoryId) {
                searchQuery.productCategoryId = categoryId;
            }
            const finishes = await ProductFinish.find(searchQuery).sort({ sortOrder: 1, name: 1 });
            console.log("ðŸ” Available finishes:", finishes.map(f => ({ name: f.name, erp_id: f.erp_id, categoryId: f.productCategoryId })));
            
            // Try exact match first
            let foundFinish = finishes.find(finish =>
                finish.name.toLowerCase() === finishName.toLowerCase()
            );
            
            if (foundFinish) {
                console.log("âœ… Found exact finish match:", foundFinish.name);
                return foundFinish;
            }
            
            // If no exact match, try fuzzy matching
            if (!foundFinish && finishes.length > 0) {
                console.log(`ðŸ” Trying fuzzy match for finish: "${finishName}"`);
                
                // Try partial matching
                foundFinish = finishes.find(finish =>
                    finish.name.toLowerCase().includes(finishName.toLowerCase()) ||
                    finishName.toLowerCase().includes(finish.name.toLowerCase())
                );
                
                if (foundFinish) {
                    console.log(`âœ… Found fuzzy finish match: "${finishName}" â†’ "${foundFinish.name}"`);
                } else {
                    console.log(`âŒ No finish match found for: "${finishName}"`);
                }
            }
            
            // If not found in name, search for partial match
            if (!foundFinish) {
                foundFinish = finishes.find(finish =>
                    finish.name.toLowerCase().includes(finishName.toLowerCase()) ||
                    finishName.toLowerCase().includes(finish.name.toLowerCase())
                );
                
                if (foundFinish) {
                    console.log("âœ… Found partial finish match:", foundFinish.name);
                }
            }
            
            // If still not found, try intelligent mapping for common terms
            if (!foundFinish) {
                const intelligentMappings = {
                    'soft touch': 'Softtouch Finish',
                    'softtouch': 'Softtouch Finish',
                    'soft': 'Softtouch Finish',
                    'foiling': 'Hot Foil',
                    'foil': 'Hot Foil',
                    'hot foil': 'Hot Foil',
                    'cold foil': 'Cold Foil',
                    'matte': 'Matte Finish',
                    'matt': 'Matte Finish',
                    'glossy': 'Gloss Finish',
                    'gloss': 'Gloss Finish',
                    'spot uv': 'Spot UV',
                    'uv': 'Spot UV',
                    'raised uv': '3D Raised Spot UV',
                    '3d uv': '3D Raised Spot UV',
                    'window': 'Window',
                    'valve': 'Valve',
                    'spout': 'Spout'
                };
                
                const mapped = intelligentMappings[finishName.toLowerCase()];
                if (mapped) {
                    foundFinish = finishes.find(finish => 
                        finish.name.toLowerCase() === mapped.toLowerCase()
                    );
                    if (foundFinish) {
                        console.log(`ðŸŽ¯ Found intelligent mapped finish: "${finishName}" â†’ "${foundFinish.name}"`);
                    }
                }
            }
            
            // If not found in name, search in description
            if (!foundFinish) {
                foundFinish = finishes.find(finish =>
                    finish.description && finish.description.toLowerCase().includes(finishName.toLowerCase())
                );
                
                if (foundFinish) {
                    console.log("âœ… Found finish match in description:", foundFinish.name);
                }
            }
            
            // If not found in description, search in erp_id
            if (!foundFinish) {
                const erpId = parseInt(finishName);
                if (!isNaN(erpId)) {
                    foundFinish = finishes.find(finish => finish.erp_id === erpId);
                    if (foundFinish) {
                        console.log("âœ… Found finish match by ERP ID:", foundFinish.name);
                    }
                }
            }
            
            console.log("Finish search result:", foundFinish ? foundFinish.name : "Not found");
            return foundFinish;
        } catch (error) {
            console.error('Error finding finish by name:', error);
            return null;
        }
    }

    async findMaterialByName(materialName, categoryId = null) {
        try {
            console.log("ðŸ” Searching for material:", materialName, categoryId ? `in category: ${categoryId}` : 'across all categories');
            
            // Search materials - filter by category if provided
            const searchQuery = { isActive: true };
            if (categoryId) {
                searchQuery.categoryId = categoryId;
            }
            const materials = await Material.find(searchQuery).sort({ sortOrder: 1, name: 1 });
            console.log("ðŸ” Available materials:", materials.map(m => ({ name: m.name, erp_id: m.erp_id, categoryId: m.categoryId })));
            
            // Search in name field (exact match first)
            let foundMaterial = materials.find(material =>
                material.name.toLowerCase() === materialName.toLowerCase()
            );
            
            if (foundMaterial) {
                console.log("ðŸŽ¯ Found exact match:", foundMaterial.name);
                return foundMaterial;
            }
            
            // If not found, search for partial match in name
            foundMaterial = materials.find(material =>
                material.name.toLowerCase().includes(materialName.toLowerCase())
            );
            
            if (foundMaterial) {
                console.log("ðŸŽ¯ Found partial match in name:", foundMaterial.name);
                return foundMaterial;
            }
            
            // If not found in name, search in description
            foundMaterial = materials.find(material =>
                material.description && material.description.toLowerCase().includes(materialName.toLowerCase())
            );
            
            if (foundMaterial) {
                console.log("ðŸŽ¯ Found match in description:", foundMaterial.name);
                return foundMaterial;
            }
            
            // If not found in description, try searching for composite materials like "PET+MET+PE" or "PET + MPET + PE"
            if (!foundMaterial) {
                console.log("ðŸ” Trying composite material search for:", materialName);
                
                // Split by common separators: +, -, space, etc.
                const materialParts = materialName.split(/[+\-\s,]+/).map(part => part.trim().toUpperCase()).filter(part => part.length > 0);
                console.log("ðŸ” Material parts:", materialParts);
                
                // Try to find a material that contains all the parts
                foundMaterial = materials.find(material => {
                    const materialNameUpper = material.name.toUpperCase();
                    const allPartsPresent = materialParts.every(part => 
                        materialNameUpper.includes(part)
                    );
                    console.log(`ðŸ” Checking material "${material.name}" against parts [${materialParts.join(', ')}]: ${allPartsPresent}`);
                    return allPartsPresent;
                });
                
                // If no material contains all parts, try to find one with most parts
                if (!foundMaterial && materialParts.length > 1) {
                    console.log("ðŸ” No exact composite match, trying partial composite match");
                    let bestMatch = null;
                    let maxMatches = 0;
                    
                    for (const material of materials) {
                        const materialNameUpper = material.name.toUpperCase();
                        const matches = materialParts.filter(part => 
                            materialNameUpper.includes(part)
                        ).length;
                        
                        console.log(`ðŸ” Material "${material.name}" matches ${matches}/${materialParts.length} parts`);
                        
                        if (matches > maxMatches && matches >= Math.ceil(materialParts.length / 2)) {
                            maxMatches = matches;
                            bestMatch = material;
                        }
                    }
                    
                    if (bestMatch) {
                        foundMaterial = bestMatch;
                        console.log(`ðŸŽ¯ Best composite match: ${bestMatch.name} (${maxMatches}/${materialParts.length} parts)`);
                    }
                }
                
                // Fallback: try finding any material containing any of the parts
                if (!foundMaterial) {
                    console.log("ðŸ” Trying fallback search for any part");
                    for (const part of materialParts) {
                        foundMaterial = materials.find(material =>
                            material.name.toUpperCase().includes(part)
                        );
                        if (foundMaterial) {
                            console.log(`ðŸŽ¯ Found material containing "${part}": ${foundMaterial.name}`);
                            break;
                        }
                    }
                }
            }
            
            // If not found, search in erp_id
            if (!foundMaterial) {
                const erpId = parseInt(materialName);
                if (!isNaN(erpId)) {
                    foundMaterial = materials.find(material => material.erp_id === erpId);
                }
            }
            
            console.log("Material search result:", foundMaterial ? foundMaterial.name : "Not found");
            return foundMaterial;
        } catch (error) {
            console.error('Error finding material by name:', error);
            return null;
        }
    }

    /**
     * Check if message is a simple restart/greeting after conversation completion
     */
    isSimpleRestartMessage(messageText) {
        const lowerText = messageText.toLowerCase().trim();
        const restartKeywords = [
            'hi', 'hello', 'hey', 'restart', 'new quote', 'start over', 
            'reset', 'begin again', 'fresh quote', 'another quote', 'new order'
        ];
        
        return restartKeywords.some(keyword => 
            lowerText === keyword || lowerText.includes(keyword)
        );
    }

    /**
     * Handle restart messages for completed conversations
     */
    async handleCompletedConversationRestart(messageText, from, messageId) {
        try {
            const lowerText = messageText.toLowerCase().trim();
            
            // Send comprehensive restart message
            await this.sendMessageOnce(
                messageId,
                from,
                `Hello! ðŸ‘‹ I'd be happy to help you with a new quote! 

Please share your complete quote details:

ðŸ“¦ **Product Type:** (e.g. stand up pouch, flat pouch, labels, folding cartons)
ðŸ“ **Dimensions:** (e.g. 5x8 inches, 10x12x3 cm)
ðŸ§± **Material:** (e.g. PET+PE, kraft paper, metallized film)
ðŸ”¢ **Quantity:** (e.g. 5000, 10k, 20000 pieces)
âœ¨ **Finishes:** (e.g. matte, spot UV, foil, holographic)
ðŸŽ¨ **SKUs/Designs:** (e.g. 1, 2, 4 different designs)

*Example: "I need 10,000 stand up pouches, 6x9 inches, metallized material, spot UV finish, 2 designs"*

Or just say 'hi' to be guided step by step! ðŸ˜Š`
            );

            // Reset conversation for new quote
            await conversationService.resetConversation(from);
            
        } catch (error) {
            console.error('Error handling completed conversation restart:', error);
            await mongoLogger.logError(error, {
                source: 'completed-conversation-restart',
                from: from,
                messageText: messageText
            });
        }
    }

    /**
     * Check if message contains simple keywords that don't need ChatGPT processing
     */
    isSimpleKeywordMessage(messageText, currentStep) {
        const lowerText = messageText.toLowerCase().trim();
        
        // Simple yes/no responses
        if (['yes', 'no', 'pdf', 'ok', 'okay'].includes(lowerText)) {
            return true;
        }
        
        // Restart keywords - should always be handled as simple keywords
        const restartKeywords = ['restart', 'new quote', 'start over', 'reset', 'begin again', 'fresh quote', 'another quote', 'new order'];
        if (restartKeywords.some(keyword => lowerText === keyword || lowerText.includes(keyword))) {
            return true;
        }
        
        // Quote generation step specific keywords
        if (currentStep === 'quote_generation') {
            const quoteKeywords = ['generate', 'create quote', 'pdf', 'download', 'send quote'];
            return quoteKeywords.some(keyword => lowerText.includes(keyword));
        }
        
        // Simple greetings in non-start steps
        if (['hi', 'hello', 'hey'].includes(lowerText) && currentStep !== 'start') {
            return true;
        }
        
        return false;
    }

    /**
     * Handle simple keyword messages without ChatGPT processing
     */
    async handleSimpleKeywordMessage(messageText, from, messageId, conversationState) {
        try {
            const lowerText = messageText.toLowerCase().trim();
            const currentStep = conversationState.currentStep;
            
            console.log(`ðŸŽ¯ Handling simple keyword: "${lowerText}" in step: ${currentStep}`);
            
            // Handle PDF requests in quote_generation step
            if (currentStep === 'quote_generation' && lowerText.includes('pdf')) {
                await this.handleQuoteGeneration(messageText, from, conversationState.conversationData, { id: messageId });
                return;
            }
            
            // Handle yes/no responses based on current step
            if (lowerText === 'yes') {
                switch (currentStep) {
                    case 'greeting_response':
                        await this.handleGreetingResponse('yes', from, messageId);
                        break;
                    case 'quote_generation':
                        // User confirmed quote details, pass 'yes' to quote generation handler
                        await this.handleQuoteGeneration('yes', from, conversationState.conversationData, { id: messageId });
                        break;
                    default:
                        await this.sendMessageOnce(
                            messageId,
                            from,
                            "Please provide the quote details."
                        );
                }
                return;
            }
            
            if (lowerText === 'no') {
                switch (currentStep) {
                    case 'greeting_response':
                        await this.handleGreetingResponse('no', from, messageId);
                        break;
                    default:
                        await this.sendMessageOnce(
                            messageId,
                            from,
                            "No problem! Please let me know how I can help you, or say 'restart' for a new quote."
                        );
                }
                return;
            }
            
            // Handle restart requests
            const restartKeywords = ['restart', 'new quote', 'start over', 'reset', 'begin again', 'fresh quote', 'another quote', 'new order'];
            if (restartKeywords.some(keyword => lowerText === keyword || lowerText.includes(keyword))) {
                console.log(`ðŸ”„ User requested restart: "${lowerText}"`);
                
                // Send restart message asking for complete quote details
                await this.sendMessageOnce(
                    messageId,
                    from,
                    `Starting fresh! ðŸ†• 

Please share your complete quote details:

ðŸ“¦ **Product Type:** (e.g. stand up pouch, flat pouch, labels, folding cartons)
ðŸ“ **Dimensions:** (e.g. 5x8 inches, 10x12x3 cm)
ðŸ§± **Material:** (e.g. PET+PE, kraft paper, metallized film)
ðŸ”¢ **Quantity:** (e.g. 5000, 10k, 20000 pieces)
âœ¨ **Finishes:** (e.g. matte, spot UV, foil, holographic)
ðŸŽ¨ **SKUs/Designs:** (e.g. 1, 2, 4 different designs)

*Example: "I need 10,000 stand up pouches, 6x9 inches, metallized material, spot UV finish, 2 designs"*

Or just say 'hi' to be guided step by step! ðŸ˜Š`
                );
                
                // Reset conversation
                await conversationService.resetConversation(from);
                return;
            }

            // Handle simple greetings in middle of conversation
            if (['hi', 'hello', 'hey'].includes(lowerText)) {
                await this.sendContextualGreeting(from, messageId, currentStep, conversationState.conversationData);
                return;
            }
            
            // Handle other simple keywords
            if (['ok', 'okay'].includes(lowerText)) {
                await this.sendMessageOnce(
                    messageId,
                    from,
                    "Great! Please provide the information I requested above to continue with your quote."
                );
                return;
            }
            
        } catch (error) {
            console.error('Error handling simple keyword message:', error);
            await mongoLogger.logError(error, {
                source: 'simple-keyword-handler',
                from: from,
                messageText: messageText,
                currentStep: conversationState.currentStep
            });
        }
    }

    /**
     * Send contextual greeting based on current conversation step
     */
    async sendContextualGreeting(from, messageId, currentStep, conversationData) {
        let message = "Hello! ðŸ‘‹ ";
        
        switch (currentStep) {
            case 'category_selection':
                message += "I'm waiting for you to select a product category from the list above.";
                break;
            case 'product_selection':
                message += `I'm waiting for you to select a product from the ${conversationData?.selectedCategory?.name || 'selected'} category.`;
                break;
            case 'dimension_input':
                message += `I need the dimensions for your ${conversationData?.selectedProduct?.name || 'selected product'}.`;
                break;
            case 'material_selection':
                message += "I'm waiting for you to select the material for your product.";
                break;
            case 'finish_selection':
                message += "I'm waiting for you to select the finish options for your product.";
                break;
            case 'quantity_input':
                message += "I need to know the quantity you're looking for.";
                break;
            case 'quote_generation':
                message += "I have all your details! Say 'pdf' to generate your quote.";
                break;
            default:
                message += "I'm here to help with your quote request. Please provide the details I asked for above.";
        }
        
        await this.sendMessageOnce(messageId, from, message);
    }

    /**
     * Check if a step should be bypassed based on available data
     */
    shouldBypassStep(step, conversationData, skipDimensionBypass = false) {
        switch (step) {
            case 'greeting_response':
                // Bypass greeting_response if we have category data and user wants a quote
                return conversationData.wantsQuote && 
                       ((conversationData.selectedCategory && conversationData.selectedCategory.id) || conversationData.requestedCategory);

            case 'category_selection':
                return (conversationData.selectedCategory && conversationData.selectedCategory.id) || conversationData.requestedCategory;

            case 'product_selection':
                return (conversationData.selectedProduct && conversationData.selectedProduct.id) || conversationData.requestedProductName;

            case 'dimension_input':
                // Don't bypass if we're currently processing dimension input
                if (skipDimensionBypass) {
                    return false;
                }
                return conversationData.dimensions && conversationData.dimensions.length > 0;

            case 'material_selection':
                return conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0;

            case 'finish_selection':
                return conversationData.selectedFinish && conversationData.selectedFinish.length > 0;

            case 'quantity_input':
                return conversationData.quantity && conversationData.quantity.length > 0;

            default:
                return false;
        }
    }

    /**
     * Get the next step after bypassing current step
     */
    getNextStepAfterBypass(currentStep, conversationData) {
        // Check if all required dimensions are provided
        let hasAllRequiredDimensions = false;
        if (conversationData.selectedProduct && conversationData.dimensions && conversationData.dimensions.length > 0) {
            // Get the product to check required dimensions
            const product = conversationData.selectedProduct;
            if (product.dimensionFields) {
                const requiredDimensionCount = product.dimensionFields.length;
                const providedDimensionCount = conversationData.dimensions.length;
                hasAllRequiredDimensions = providedDimensionCount >= requiredDimensionCount;
                
                console.log('ðŸ” Dimension validation:', {
                    productName: product.name,
                    requiredDimensions: requiredDimensionCount,
                    providedDimensions: providedDimensionCount,
                    hasAllRequired: hasAllRequiredDimensions,
                    requiredFields: product.dimensionFields.map(f => f.name),
                    providedFields: conversationData.dimensions.map(d => d.name)
                });
            } else {
                // No dimension fields defined, consider complete
                hasAllRequiredDimensions = true;
            }
        }
        
        // If we have all required data, go to quote generation
        if (conversationData.selectedProduct &&
            hasAllRequiredDimensions &&
            conversationData.selectedMaterial &&
            conversationData.selectedMaterial.length > 0 &&
            conversationData.selectedFinish &&
            conversationData.selectedFinish.length > 0 &&
            conversationData.quantity &&
            conversationData.quantity.length > 0) {
            return 'quote_generation';
        }

        // Otherwise, move to the next logical step
        switch (currentStep) {
            case 'greeting_response':
                return conversationData.selectedProduct ? 'dimension_input' : 
                       (conversationData.selectedCategory ? 'product_selection' : 'category_selection');

            case 'category_selection':
                return conversationData.selectedProduct ? 'dimension_input' : 'product_selection';

            case 'product_selection':
                return 'dimension_input';

            case 'dimension_input':
                // Check if we have all required dimensions before moving to material selection
                if (conversationData.selectedProduct && conversationData.selectedProduct.dimensionFields) {
                    const requiredCount = conversationData.selectedProduct.dimensionFields.length;
                    const providedCount = conversationData.dimensions ? conversationData.dimensions.length : 0;
                    
                    if (providedCount < requiredCount) {
                        console.log('ðŸ” Staying in dimension_input - missing dimensions:', {
                            required: requiredCount,
                            provided: providedCount,
                            missing: requiredCount - providedCount
                        });
                        return 'dimension_input'; // Stay in dimension input until all are provided
                    }
                }
                return 'material_selection';

            case 'material_selection':
                return 'finish_selection';

            case 'finish_selection':
                return 'quantity_input';

            case 'quantity_input':
                return 'quote_generation';

            default:
                return currentStep;
        }
    }

    /**
     * Determine the next step based on current step and extracted data
     */
    async determineNextStep(currentStep, conversationData, entities, skipDimensionBypass = false) {
        console.log('ðŸ” determineNextStep called with:', {
            currentStep,
            wantsQuote: conversationData.wantsQuote,
            hasSelectedCategory: !!conversationData.selectedCategory?.id,
            selectedCategory: conversationData.selectedCategory,
            skipDimensionBypass
        });

        // Special case: If we're in 'start' step and have selectedCategory, go to product_selection
        if (currentStep === 'start' && conversationData.selectedCategory?.id) {
            console.log('âœ… Case 1: start + has selectedCategory â†’ product_selection');
            return 'product_selection';
        }

        // Special case: If we're in 'start' step and user wants quote but no category selected, go to greeting_response
        if (currentStep === 'start' && conversationData.wantsQuote && !conversationData.selectedCategory?.id) {
            console.log('âœ… Case 2: start + wantsQuote + no category â†’ greeting_response');
            return 'greeting_response';
        }

        // Special case: If we're in 'greeting_response' and now have selectedCategory, move to product_selection
        if (currentStep === 'greeting_response' && conversationData.selectedCategory?.id) {
            console.log('âœ… Case 3: greeting_response + has selectedCategory â†’ product_selection');
            return 'product_selection';
        }

        // Use the bypassing logic to determine next step
        if (this.shouldBypassStep(currentStep, conversationData, skipDimensionBypass)) {
            const bypassResult = this.getNextStepAfterBypass(currentStep, conversationData);
            console.log('âœ… Case 4: bypass logic â†’', bypassResult);
            return bypassResult;
        }

        console.log('âœ… Case 5: no change â†’', currentStep);
        return currentStep; // Keep current step if no advancement possible
    }

    async processConversationFlow(message, messageText, from, conversationState, hasResponded = false) {
        console.log("processConversationFlow ", messageText, from, conversationState);
        try {
            const currentStep = conversationState.currentStep;
            const conversationData = conversationState.conversationData || {};

            // Check if conversation is already completed
            if (conversationData.completed || currentStep === 'completed') {
                console.log(`â­ï¸ Conversation already completed for ${from}, skipping processing`);
                return;
            }

            await mongoLogger.info('Processing conversation step', { currentStep, from });

            // Check if current step should be bypassed
            // Don't bypass dimension_input if we're currently processing it
            const skipDimensionBypass = currentStep === 'dimension_input';
            
            if (this.shouldBypassStep(currentStep, conversationData, skipDimensionBypass)) {
                await mongoLogger.info(`Bypassing step: ${currentStep}`, {
                    from,
                    conversationData: Object.keys(conversationData)
                });

                const nextStep = this.getNextStepAfterBypass(currentStep, conversationData);

                // Update conversation state to next step
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Recursively process the next step - but don't send duplicate responses
                const updatedState = await conversationService.getConversationState(from);
                return await this.processConversationFlow(message, messageText, from, updatedState, hasResponded);
            }
            
            // Only process step if we haven't already responded
            if (!hasResponded) {
                try {
                    switch (currentStep) {
                        case 'start':
                            await this.handleStartStep(messageText, from, message.id);
                            break;
                        case 'greeting_response':
                            await this.handleGreetingResponse(messageText, from, message.id);
                            break;
                        case 'category_selection':
                            await this.handleCategorySelection(messageText, from);
                            break;
                        case 'product_selection':
                            await this.handleProductSelection(messageText, from);
                            break;
                        case 'dimension_input':
                            await this.handleDimensionInput(messageText, from, conversationData, message);
                            break;
                        case 'material_selection':
                            await this.handleMaterialSelection(messageText, from, conversationData);
                            break;
                        case 'finish_selection':
                            await this.handleFinishSelection(messageText, from, conversationData);
                            break;
                        case 'quantity_input':
                            await this.handleQuantityInput(messageText, from, conversationData);
                            break;
                        case 'quote_generation':
                            await this.handleQuoteGeneration(messageText, from, conversationData, message);
                            break;
                        default:
                            console.log(`Unknown step: ${currentStep}, defaulting to start step`);
                            await this.handleStartStep(messageText, from, message.id);
                    }
                } catch (stepError) {
                    console.error(`Error in step ${currentStep}:`, stepError);
                    await mongoLogger.logError(stepError, {
                        source: 'conversation-step-handler',
                        step: currentStep,
                        from: from,
                        messageText: messageText
                    });

                    // Send user-friendly error message (only once)
                    await this.sendMessageOnce(
                        message.id,
                        from,
                        "Sorry, I encountered an error processing your request. Let me start over."
                    );

                    // Reset conversation to start step
                    await conversationService.updateConversationState(from, {
                        currentStep: 'start',
                        conversationData: {}
                    });
                }
            } else {
                console.log(`Skipping step processing - already responded for ${from}`);
            }
        } catch (error) {
            await mongoLogger.logError(error, { source: 'conversation-flow' });
            // Only send error message if we haven't already responded
            const messageId = message?.id || 'error-flow-' + Date.now();
            if (!(await this.hasResponded(messageId))) {
                await this.sendMessageOnce(
                    messageId,
                    from,
                    "I'm sorry, something went wrong. Let me restart our conversation. Please type 'hi' to begin."
                );
            }
            await conversationService.resetConversation(from);
        }
    }

    async handleStartStep(messageText, from, messageId) {
        try {
            // Process with ChatGPT to detect greeting (with fallback)
            let intent = null;
            try {
                const aiResponse = await this.aiService.processMessage(messageText);
                intent = aiResponse.data?.intents?.[0]?.name;
            } catch (aiError) {
                console.log("ChatGPT not available, using fallback greeting detection");
                await mongoLogger.warn('ChatGPT unavailable in handleStartStep, using fallback', { 
                    messageText, 
                    from,
                    error: aiError.message
                });
            }

            if (intent === 'greeting' || this.isGreeting(messageText)) {
                await this.sendGreetingWithQuoteOption(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'greeting_response'
                });
            } else {
                await this.sendMessageOnce(
                    messageId,
                    from,
                    "Hello! ðŸ‘‹ Welcome to our mylar bag service. Please say 'Hi' to get started with your quote request."
                );
                await conversationService.updateConversationState(from, {
                    currentStep: 'greeting_response'
                });
            }
        } catch (error) {
            console.error('Error in handleStartStep:', error);
            await mongoLogger.error('handleStartStep failed', { 
                messageText, 
                from,
                error: error.message,
                stack: error.stack
            });
            
            // Fallback response
            await this.sendMessageOnce(
                messageId,
                from,
                "Hello! ðŸ‘‹ Welcome to our mylar bag service. Please say 'Hi' to get started with your quote request."
            );
        }
    }

    async sendGreetingWithQuoteOption(from) {
        const buttons = [
            {
                type: 'reply',
                reply: {
                    id: 'quote_yes',
                    title: 'Yes, Get Quote'
                }
            },
            {
                type: 'reply',
                reply: {
                    id: 'quote_no',
                    title: 'No, Thanks'
                }
            }
        ];

        const bodyText = `Hello! ðŸ‘‹ Welcome to our Mylar Bag service! 

We specialize in high-quality mylar bags for all your packaging needs.

Would you like to get a quote for mylar bags today?`;

        await this.whatsappService.sendButtonMessage(from, bodyText, buttons);
    }

    async handleGreetingResponse(messageText, from, messageId = null) {
        const response = messageText.toLowerCase().trim();
        console.log('ðŸŽ¯ handleGreetingResponse called with:', { messageText, response, from });

        // Check if user is making a specific quote request (e.g., "need folding carton quote")
        const isQuoteRequest = response.includes('quote') || response.includes('need') || 
                              response.includes('want') || response.includes('get');
                              
        // Check if user mentioned a specific category
        const hasProductInfo = this.hasProductInformation(messageText);

        if (response.includes('yes') || response === 'quote_yes' || response.includes('get quote') || 
            (isQuoteRequest && hasProductInfo)) {
            console.log('âœ… User wants quote, updating state to category_selection or proceeding with extracted category');
            
            await conversationService.updateConversationState(from, {
                currentStep: 'category_selection',
                'conversationData.wantsQuote': true
            });
            
            // Check if we already have category information from entity extraction
            const conversationState = await conversationService.getConversationState(from);
            const selectedCategory = conversationState.conversationData?.selectedCategory;
            
            if (selectedCategory && selectedCategory.id) {
                console.log('ðŸ“¦ Category already identified from message, proceeding to product selection');
                
                // Send confirmation that category was detected
                await this.whatsappService.sendMessage(
                    from,
                    `âœ… Perfect! I detected you need a quote for **${selectedCategory.name}** products. Let me show you the available options.`
                );
                
                await conversationService.updateConversationState(from, {
                    currentStep: 'product_selection'
                });
                
                // Small delay to ensure messages appear in order
                setTimeout(async () => {
                    await this.sendProductSelection(from);
                }, 1000);
            } else {
                console.log('ðŸ“¤ No category identified, calling sendCategorySelection');
                await this.sendCategorySelection(from);
            }
        } else if (response.includes('no') || response === 'quote_no') {
            await this.sendMessageOnce(
                messageId,
                from,
                "No problem! If you change your mind or have any questions about our mylar bags, feel free to reach out anytime. Have a great day! ðŸ˜Š"
            );
            await conversationService.updateConversationState(from, {
                currentStep: 'completed',
                isActive: false,
                completedAt: new Date()
            });
        } else {
            await this.sendMessageOnce(
                messageId,
                from,
                "Please reply with 'Yes' if you want a quote or 'No' if you don't need one right now."
            );
        }
    }

    async sendCategorySelection(from, messageId = null) {
        console.log('ðŸŽ¯ sendCategorySelection called for:', from);
        try {
            const categories = await conversationService.getProductCategories();
            console.log('ðŸ“‹ Retrieved categories:', categories?.length || 0);

            if (!categories || categories.length === 0) {
                if (messageId) {
                    await this.sendMessageOnce(
                        messageId,
                        from,
                        "Sorry, no product categories are available at the moment. Please try again later."
                    );
                } else {
                    await this.sendMessageFallback(
                        from,
                        "Sorry, no product categories are available at the moment. Please try again later."
                    );
                }
                return;
            }

            // Ensure we're in category_selection step before sending the list
            await conversationService.updateConversationState(from, {
                currentStep: 'category_selection'
            });

            const sections = [{
                title: "Product Categories",
                rows: categories.map(category => ({
                    id: category.erp_id.toString(),
                    title: category.name,
                    description: category.description
                }))
            }];

            const bodyText = `Perfect! ðŸŽ¯ Let's start by selecting the category that best fits your needs. Which category are you interested in?`;
            console.log('sections ', sections);
            await this.whatsappService.sendListMessage(
                from,
                bodyText,
                "Select Category",
                sections
            );
        } catch (error) {
            await mongoLogger.logError(error, { source: 'send-category-selection' });
            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error loading categories. Please try again later."
            );
        }
    }

    async handleCategorySelection(messageText, from) {
        console.log('ðŸŽ¯ handleCategorySelection called with:', { messageText, from });

        const categories = await conversationService.getProductCategories();
        console.log('ðŸ“‹ Available categories:', categories?.map(c => ({ name: c.name, erp_id: c.erp_id })) || 'No categories found');

        if (!categories || categories.length === 0) {
            await this.whatsappService.sendMessage(
                from,
                "Sorry, no product categories are available at the moment. Please try again later."
            );
            return;
        }

        let selectedCategory = null;

        // Check if it's a direct category ERP ID or find by name
        selectedCategory = categories.find(c =>
            c.erp_id.toString() === messageText ||
            c.name.toLowerCase().includes(messageText.toLowerCase())
        );

        console.log('ðŸ” Category search result:', {
            searchTerm: messageText,
            foundCategory: selectedCategory ? { name: selectedCategory.name, erp_id: selectedCategory.erp_id } : null,
            searchByERP: categories.some(c => c.erp_id.toString() === messageText),
            searchByName: categories.some(c => c.name.toLowerCase().includes(messageText.toLowerCase())),
            allCategoryERPIds: categories.map(c => c.erp_id.toString()),
            exactMatch: categories.find(c => c.erp_id.toString() === messageText)
        });

        if (selectedCategory) {
            console.log('âœ… Updating conversation state with selected category:', {
                id: selectedCategory._id,
                erp_id: selectedCategory.erp_id,
                name: selectedCategory.name,
                description: selectedCategory.description
            });
            
            const updatePayload = {
                currentStep: 'product_selection',
                'conversationData.selectedCategory': {
                    id: selectedCategory._id,
                    erp_id: selectedCategory.erp_id,
                    name: selectedCategory.name,
                    description: selectedCategory.description
                }
            };
            console.log('ðŸ“¤ Update payload:', JSON.stringify(updatePayload, null, 2));
            
            try {
                const updatedState = await conversationService.updateConversationState(from, updatePayload);
                console.log('ðŸ“¥ Update response received:', {
                    success: !!updatedState,
                    currentStep: updatedState?.currentStep,
                    selectedCategory: updatedState?.conversationData?.selectedCategory,
                    hasCategory: !!updatedState?.conversationData?.selectedCategory?.id,
                    fullState: JSON.stringify(updatedState, null, 2)
                });

                // Verify the update was successful by reading back the state
                const verificationState = await conversationService.getConversationState(from);
                console.log('ï¿½ Verification - state after update:', {
                    currentStep: verificationState?.currentStep,
                    selectedCategory: verificationState?.conversationData?.selectedCategory,
                    hasCategory: !!verificationState?.conversationData?.selectedCategory?.id,
                    categoryId: verificationState?.conversationData?.selectedCategory?.id,
                    categoryName: verificationState?.conversationData?.selectedCategory?.name
                });

                if (!verificationState?.conversationData?.selectedCategory?.id) {
                    console.error('âŒ CRITICAL: Category update failed to persist in database!');
                    await mongoLogger.logError(new Error('Category selection failed to persist'), {
                        source: 'category-selection-persistence',
                        from: from,
                        selectedCategory: selectedCategory,
                        updatePayload: updatePayload,
                        updatedState: updatedState,
                        verificationState: verificationState
                    });
                    
                    // Retry the update
                    console.log('ðŸ”„ Retrying category update...');
                    const retryState = await conversationService.updateConversationState(from, updatePayload);
                    console.log('ðŸ”„ Retry result:', retryState);
                } else {
                    console.log('âœ… Category successfully persisted in database');
                }

                console.log('ï¿½ðŸ“¤ Sending product selection for category:', selectedCategory.name);
            await this.sendProductSelection(from);
            } catch (updateError) {
                console.error('âŒ Error updating conversation state with category:', updateError);
                await mongoLogger.logError(updateError, {
                    source: 'category-selection-update',
                    from: from,
                    selectedCategory: selectedCategory,
                    updatePayload: updatePayload
                });
                
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, I encountered an error saving your category selection. Please try again."
                );
                return;
            }
        } else {
            console.log('âŒ No category found for:', messageText);
            await this.whatsappService.sendMessage(
                from,
                "I didn't quite catch that. Please select a category from the list above or type the category name."
            );
        }
    }

    async sendProductSelection(from, messageId = null) {
        console.log('ðŸš¨ sendProductSelection called for:', from, '- This should not be called during greeting response!');
        try {
        // Get conversation state to access selected category
        const conversationState = await conversationService.getConversationState(from);
            console.log('ðŸ“‹ sendProductSelection - Current conversation state:', {
                from: from,
                currentStep: conversationState?.currentStep,
                selectedCategory: conversationState?.conversationData?.selectedCategory,
                hasCategory: !!conversationState?.conversationData?.selectedCategory?.id,
                categoryId: conversationState?.conversationData?.selectedCategory?.id,
                categoryName: conversationState?.conversationData?.selectedCategory?.name,
                fullConversationData: JSON.stringify(conversationState?.conversationData, null, 2)
            });

        const selectedCategory = conversationState.conversationData?.selectedCategory;
        console.log('Selected category ', selectedCategory);

        if (!selectedCategory || !selectedCategory.id) {
                console.error('âŒ CRITICAL: No selected category found in sendProductSelection!');
                await mongoLogger.logError(new Error('No selected category in sendProductSelection'), {
                    source: 'send-product-selection',
                    from: from,
                    conversationState: conversationState
                });
                
            await this.whatsappService.sendMessage(
                from,
                "Sorry, I couldn't find the selected category. Please start over by selecting a category."
            );
            return;
        }

        // Get products by category ID to validate against
        const allProducts = await conversationService.getProductsByCategory(selectedCategory.id);

        if (!allProducts || allProducts.length === 0) {
            await this.whatsappService.sendMessage(
                from,
                `Sorry, no products are available in the ${selectedCategory.name} category at the moment. Please try another category.`
            );
            return;
        }

        // Get all the information we have so far
        const conversationData = conversationState.conversationData || {};
        
        // Show available products with collected information
        let bodyText = `Perfect! ðŸŽ¯ I see you need a quote for **${selectedCategory.name}** products.\n\n`;
        
        // Show collected information if any
        let hasCollectedInfo = false;
        if ((conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) || conversationData.requestedMaterial) {
            if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
                const materialsText = conversationData.selectedMaterial
                    .map(m => m.name)
                    .join(', ');
                bodyText += `ðŸ§± **Materials:** ${materialsText}\n`;
            } else {
                bodyText += `ðŸ§± **Material:** ${conversationData.requestedMaterial}\n`;
            }
            hasCollectedInfo = true;
        }
        if (conversationData.quantity?.length > 0) {
            bodyText += `ðŸ”¢ **Quantity:** ${conversationData.quantity.join(', ')}\n`;
            hasCollectedInfo = true;
        }
        if (conversationData.dimensions?.length > 0) {
            const dimensionsText = conversationData.dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
            bodyText += `ðŸ“ **Dimensions:** ${dimensionsText}\n`;
            hasCollectedInfo = true;
        }
        if (conversationData.selectedFinish?.length > 0) {
            const finishNames = conversationData.selectedFinish.map(f => f.name).join(', ');
            bodyText += `âœ¨ **Finishes:** ${finishNames}\n`;
            hasCollectedInfo = true;
        }
        
        if (hasCollectedInfo) {
            bodyText += `\n`;
        }
        
        // Show available products request without numbered list
        bodyText += `Here are the available products in **${selectedCategory.name}**. Please type the exact name of the product you want to quote (e.g., "${allProducts[0].name}").`;

        if (messageId) {
            await this.sendMessageOnce(messageId, from, bodyText);
        } else {
            await this.sendMessageFallback(from, bodyText);
        }
    } catch (error) {
        console.error('Error in sendProductSelection:', error);
        await mongoLogger.logError(error, {
            source: 'send-product-selection',
            from: from,
            selectedCategory: selectedCategory
        });
        
        await this.whatsappService.sendMessage(
            from,
            "Sorry, I encountered an error while preparing the product selection. Please try again."
        );
    }
    }

    async handleProductSelection(messageText, from) {
        try {
            // Get conversation state to access selected category
            const conversationState = await conversationService.getConversationState(from);
            const selectedCategory = conversationState.conversationData?.selectedCategory;
            const requestedProductName = conversationState.conversationData?.requestedProductName;

            if (!selectedCategory || !selectedCategory.id) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, I couldn't find the selected category. Please start over by selecting a category."
                );
                return;
            }

            // Get products by category ID
            const products = await conversationService.getProductsByCategory(selectedCategory.id);
            let selectedProduct = null;

            // Use requested product name from Wit.ai if available, otherwise use messageText
            const searchTerm = requestedProductName || messageText;
            
            console.log('ðŸ” Product selection search details:', {
                messageText,
                requestedProductName,
                searchTerm,
                selectedCategory: selectedCategory?.name,
                hasQuantity: !!conversationState.conversationData?.quantity?.length,
                quantity: conversationState.conversationData?.quantity
            });

            // Check if the message contains quantity information but no specific product name
            const hasQuantityInfo = conversationState.conversationData?.quantity?.length > 0;
            const isGenericQuoteRequest = messageText.toLowerCase().includes('quote') && 
                                        messageText.toLowerCase().includes('qty');
            
            if (hasQuantityInfo && isGenericQuoteRequest && !requestedProductName) {
                console.log('ðŸ“‹ User provided quantity but no specific product, asking for product selection');
                
                // Acknowledge the quantity and ask for product selection
                const quantity = conversationState.conversationData?.quantity?.[0];
                const quantityText = quantity ? `${quantity.toLocaleString()} pieces` : 'the specified quantity';
                
                await this.whatsappService.sendMessage(
                    from,
                    `Great! I see you need a quote for ${quantityText}. Now please select a product from the ${selectedCategory.name} category:`
                );
                
                await this.sendProductSelection(from);
                return;
            }

            // Check if it's a numeric selection (DISABLED - users must type product names)
            const numericSelection = parseInt(searchTerm);
            if (false && !isNaN(numericSelection) && numericSelection > 0 && numericSelection <= products.length) {
                selectedProduct = products[numericSelection - 1];
                console.log(`ðŸ”¢ Selected product by number: ${numericSelection} -> ${selectedProduct.name}`);
            } else {
                // Check if it's a direct product ERP ID or find by name
                selectedProduct = products.find(p =>
                    p.erp_id.toString() === searchTerm ||
                    p.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }

            if (selectedProduct) {
                await conversationService.updateConversationState(from, {
                    currentStep: 'dimension_input',
                    'conversationData.selectedProduct': {
                        id: selectedProduct.erp_id.toString(),
                        erp_id: selectedProduct.erp_id,
                        name: selectedProduct.name,
                        description: selectedProduct.description,
                        basePrice: selectedProduct.basePrice,
                        dimensionFields: selectedProduct.dimensionFields
                    }
                });

                // Check if dimensions are already provided from Wit.ai
                const conversationData = conversationState.conversationData || {};
                if (conversationData.dimensions && conversationData.dimensions.length > 0) {
                    // Skip dimension input and go to material selection
                    await conversationService.updateConversationState(from, {
                        currentStep: 'material_selection'
                    });
                    await this.sendMaterialSelection(from, selectedProduct);
                } else {
                    await this.sendDimensionRequest(from, selectedProduct);
                }
            } else {
                    // Check if this looks like a quote request rather than a specific product name
                const isQuoteRequest = messageText.toLowerCase().includes('quote') || 
                                     messageText.toLowerCase().includes('need') ||
                                     messageText.toLowerCase().includes('want') ||
                                     messageText.toLowerCase().includes('get');
                
                // Also check if the message contains the category name (likely a generic request)
                const containsCategoryName = selectedCategory.name.toLowerCase().split(' ').some(word => 
                    messageText.toLowerCase().includes(word.toLowerCase())
                );
                
                if (isQuoteRequest || containsCategoryName) {
                    console.log('ðŸŽ¯ Detected generic quote request, showing product list');
                    
                    // Show available products list
                    if (products && products.length > 0) {
                        await this.whatsappService.sendMessage(
                            from,
                            `Great! I see you need a quote for *${selectedCategory.name}* products. ðŸ“¦\n\nPlease type the exact name of the product you're interested in (e.g., "${products[0].name}").\n\n*Note: If you're unsure about product names, please contact our support team.*`
                        );
                    } else {
                        await this.whatsappService.sendMessage(
                            from,
                            `I understand you need a quote for ${selectedCategory.name}, but no products are available in this category at the moment. Please contact our support team.`
                        );
                    }
                } else {
                    await this.whatsappService.sendMessage(
                        from,
                        `I couldn't find a product named "${searchTerm}" in the ${selectedCategory.name} category. Please try a different product name or check the spelling.`
                    );
                }
            }
        } catch (error) {
            await mongoLogger.logError(error, { source: 'handle-product-selection' });
            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your product selection. Please try again."
            );
        }
    }

    async sendDimensionRequest(from, product) {
        const dimensionFields = product.dimensionFields || [];
        const dimensionNames = dimensionFields.map(field => field.name);

        // Get conversation state to show all collected information
        const conversationState = await conversationService.getConversationState(from);
        const conversationData = conversationState.conversationData || {};

        let message = `Perfect! You selected: **${product.name}** ðŸ“\n\n`;
        
        // Show all collected information
        message += `Here's what I have so far:\n`;
        message += `ðŸ“‚ **Category:** ${conversationData.selectedCategory?.name || 'Not specified'}\n`;
        
        // Handle multiple materials (without showing internal ERP IDs)
        if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
            const materialsText = conversationData.selectedMaterial
                .map(m => m.name)
                .join(', ');
            message += `ðŸ§± **Materials:** ${materialsText}\n`;
        } else {
            message += `ðŸ§± **Material:** ${conversationData.requestedMaterial || 'Not specified'}\n`;
        }
        
        message += `ðŸ”¢ **Quantity:** ${conversationData.quantity?.join(', ') || 'Not specified'}\n`;
        message += `ðŸŽ¨ **SKUs/Designs:** ${conversationData.skus || '1 (default)'}\n`;
        
        // Show finishes (both selected and requested)
        let finishDisplay = 'Not specified';
        if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
            finishDisplay = conversationData.selectedFinish.map(f => f.name).join(', ');
        } else if (conversationData.requestedFinish) {
            finishDisplay = `${conversationData.requestedFinish} (requested)`;
        }
        message += `âœ¨ **Finishes:** ${finishDisplay}\n\n`;
        
        message += `Now I need the ${dimensionNames.length === 1 ? 'dimension' : 'dimensions'} for your product.\n\n`;
        
        // Create appropriate example based on the number of dimensions
        if (dimensionNames.length === 1) {
            message += `ðŸ“ **Required:** ${dimensionNames[0]} (Diameter)\n\n`;
            message += `**Examples:**\nâ€¢ Just one value: "5"\nâ€¢ With label: "${dimensionNames[0]}:5"\n\n`;
        } else if (dimensionNames.length === 2) {
            message += `ðŸ“ **Required:** ${dimensionNames.join(' x ')}\n\n`;
            message += `**Examples:**\nâ€¢ Two values: "${dimensionNames.map(() => '5').join(' x ')}" or "${dimensionNames.map(() => '5').join(', ')}"\nâ€¢ With labels: "${dimensionNames.map((name, i) => `${name}:5`).join(', ')}"\n\n`;
        } else {
            message += `ðŸ“ **Required:** ${dimensionNames.join(' x ')}\n\n`;
            message += `**Examples:**\nâ€¢ ${dimensionNames.length} values: "${dimensionNames.map(() => '5').join(' x ')}" or "${dimensionNames.map(() => '5').join(', ')}"\nâ€¢ With labels: "${dimensionNames.map((name, i) => `${name}:5`).join(', ')}"\n\n`;
        }
        
        message += `All dimensions should be in inches.`;

        await this.whatsappService.sendMessage(from, message);
    }

    async handleDimensionInput(messageText, from, conversationData, message = null) {
        try {
            // Check if we're waiting for dimension confirmation
            if (conversationData.awaitingDimensionConfirmation && conversationData.pendingDimensions) {
                const response = messageText.toLowerCase().trim();
                
                if (response.includes('yes') || response.includes('y') || response.includes('correct') || response.includes('ok')) {
                    // User confirmed the dimensions
                    const dimensions = conversationData.pendingDimensions;
                    const dimensionsList = dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
                    
                    await this.whatsappService.sendMessage(
                        from,
                        `âœ… Great! Confirmed dimensions: **${dimensionsList}**\n\nMoving to the next step...`
                    );
                    
                    // Update conversation state with confirmed dimensions
                    await conversationService.updateConversationState(from, {
                        'conversationData.dimensions': dimensions,
                        'conversationData.pendingDimensions': null,
                        'conversationData.awaitingDimensionConfirmation': false
                    });

                    // Move to next step
                    const nextStep = this.getNextStepAfterBypass('dimension_input', { ...conversationData, dimensions });
                    await conversationService.updateConversationState(from, {
                        currentStep: nextStep
                    });

                    // Process the next step without passing the confirmation text
                    const updatedState = await conversationService.getConversationState(from);
                    const mockMessage = { id: 'dimension-confirmed-' + Date.now() };
                    await this.processConversationFlow(mockMessage, '', from, updatedState, false);
                    return;
                    
                } else {
                    // User wants to provide different dimensions
                    await conversationService.updateConversationState(from, {
                        'conversationData.pendingDimensions': null,
                        'conversationData.awaitingDimensionConfirmation': false
                    });
                    
                    const product = await conversationService.getProductById(conversationData.selectedProduct.id);
                    const dimensionNames = product.dimensionFields.map(f => f.name);
                    
                    await this.whatsappService.sendMessage(
                        from,
                        `No problem! Please provide the correct dimensions for **${product.name}**:\n\nRequired: **${dimensionNames.join(', ')}**\n\nFormat: **${dimensionNames.join(' x ')}** (e.g., "${dimensionNames.map(() => '5').join(' x ')}")`
                    );
                    return;
                }
            }
            
            // Don't bypass - we want to handle dimension input properly
            // Even if dimensions exist, we may need to extract new ones or confirm
            // The smart extraction has already handled updating dimensions if needed

            // Check if we have a selected product
            if (!conversationData.selectedProduct || !conversationData.selectedProduct.id) {
                console.log("No selected product, checking conversation state:", {
                    hasCategory: !!conversationData.selectedCategory?.id,
                    selectedCategory: conversationData.selectedCategory,
                    messageText: messageText
                });

                // Check if we have a selected category
                if (!conversationData.selectedCategory || !conversationData.selectedCategory.id) {
                    console.log("No selected category, asking for category selection");
                    await conversationService.updateConversationState(from, {
                        currentStep: 'category_selection'
                    });
                    await this.sendCategorySelection(from);
                    return;
                } else {
                    console.log("Have category, asking for product selection");
                    await this.sendProductSelection(from);
                    return;
                }
            }

            // Try to extract dimensions from the message using ChatGPT
            console.log("Attempting to extract dimensions from message:", messageText);
            
            try {
                const aiResponse = await this.aiService.processMessage(messageText);
                console.log("ChatGPT response for dimensions:", JSON.stringify(aiResponse, null, 2));

                if (aiResponse.data && aiResponse.data.entities && aiResponse.data.entities['dimensions:dimensions']) {
                    console.log("Found dimensions in ChatGPT response, processing...");
                    
                    // Extract and update conversation data with dimensions
                    const updatedData = await this.extractAndUpdateConversationData(aiResponse.data.entities, conversationData, messageText);
                    
                    if (updatedData.dimensions && updatedData.dimensions.length > 0) {
                        console.log("Successfully extracted dimensions:", updatedData.dimensions);
                        
                        // Update conversation state with dimensions (store in conversationData)
                        await conversationService.updateConversationState(from, {
                            'conversationData.dimensions': updatedData.dimensions
                        });

                        // Send confirmation message and ask for next step
                        const dimensionsList = updatedData.dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
                        await this.whatsappService.sendMessage(
                            from,
                            `âœ… Perfect! I've captured your dimensions: **${dimensionsList}**\n\nLet me move to the next step...`
                        );

                        // Move to next step
                        const nextStep = this.getNextStepAfterBypass('dimension_input', updatedData);
                        await conversationService.updateConversationState(from, {
                            currentStep: nextStep
                        });

                        // Process the next step without passing the dimension input text
                        const updatedState = await conversationService.getConversationState(from);
                        const mockMessage = { id: 'dimension-extracted-' + Date.now() };
                        await this.processConversationFlow(mockMessage, '', from, updatedState, false);
                        return;
                    }
                }
            } catch (aiError) {
                console.log("ChatGPT extraction failed, trying manual parsing:", aiError.message);
            }

            // If ChatGPT extraction failed, try manual parsing - but only for simple dimension responses
            // Check if this looks like a complex quote request rather than a dimension response
            const quoteRequestIndicators = ['looking for', 'need', 'want', 'quote', 'pouches', 'bags', 'labels', 'standard size', 'different', 'flavors', 'designs', 'inside'];
            const isComplexQuoteRequest = quoteRequestIndicators.some(indicator => 
                messageText.toLowerCase().includes(indicator)
            );
            
            if (isComplexQuoteRequest) {
                console.log("Detected complex quote request, not parsing as dimensions:", messageText);
                // This is a quote request, not dimension input - ask for dimensions
                const product = await conversationService.getProductById(conversationData.selectedProduct.id);
                if (product && product.dimensionFields) {
                    const dimensionNames = product.dimensionFields.map(f => f.name);
                    await this.whatsappService.sendMessage(
                        from,
                        `Thank you for your quote request! ðŸ“‹\n\nTo proceed, I need the dimensions for your **${product.name}**.\n\nðŸ“ Required: **${dimensionNames.join(', ')}**\n\n*Format:* **${dimensionNames.join(' x ')}** (e.g., "${dimensionNames.map(() => '5').join(' x ')}")\n\nAll dimensions should be in inches.`
                    );
                }
                return;
            }
            
            const product = await conversationService.getProductById(conversationData.selectedProduct.id);
            if (product && product.dimensionFields) {
                const dimensionNames = product.dimensionFields.map(f => f.name);
                const dimensionValues = this.parseDimensionValues(messageText);
                
                console.log('ðŸ” Dimension matching details:', {
                    productName: product.name,
                    requiredDimensions: dimensionNames,
                    requiredCount: dimensionNames.length,
                    providedValues: dimensionValues,
                    providedCount: dimensionValues.length,
                    messageText
                });
                
                if (dimensionValues.length > 0) {
                    console.log("Manually parsed dimensions:", dimensionValues);
                    
                    // Check if the number of provided values matches required dimensions
                    if (dimensionValues.length > dimensionNames.length) {
                        // Too many dimensions provided
                        const extraDimensions = dimensionValues.slice(dimensionNames.length);
                        await this.whatsappService.sendMessage(
                            from,
                            `I notice you provided ${dimensionValues.length} dimensions (${dimensionValues.join(', ')}), but **${product.name}** only requires **${dimensionNames.length} dimension${dimensionNames.length > 1 ? 's' : ''}**: **${dimensionNames.join(', ')}**.\n\nI'll use the first ${dimensionNames.length} value${dimensionNames.length > 1 ? 's' : ''}: **${dimensionValues.slice(0, dimensionNames.length).join(', ')}**\n\nIs this correct? Reply 'yes' to continue or provide the correct dimension${dimensionNames.length > 1 ? 's' : ''}.`
                        );
                        
                        // Use only the required number of dimensions
                        const limitedValues = dimensionValues.slice(0, dimensionNames.length);
                        const dimensions = [];
                        product.dimensionFields.forEach((field, index) => {
                            if (limitedValues[index] !== undefined) {
                                dimensions.push({
                                    name: field.name,
                                    value: limitedValues[index]
                                });
                            }
                        });
                        
                        // Store the dimensions but wait for user confirmation
                        await conversationService.updateConversationState(from, {
                            'conversationData.pendingDimensions': dimensions,
                            'conversationData.awaitingDimensionConfirmation': true
                        });
                        return;
                        
                    } else if (dimensionValues.length < dimensionNames.length) {
                        // Not enough dimensions provided
                        const missingCount = dimensionNames.length - dimensionValues.length;
                        const providedDimensionsList = dimensionNames.slice(0, dimensionValues.length).map((name, index) => 
                            `${name}: ${dimensionValues[index]}`
                        ).join(', ');
                        const missingDimensions = dimensionNames.slice(dimensionValues.length);
                        
                        await this.whatsappService.sendMessage(
                            from,
                            `I received: **${providedDimensionsList}**\n\nBut **${product.name}** needs **${missingCount} more dimension${missingCount > 1 ? 's' : ''}**: **${missingDimensions.join(', ')}**\n\nPlease provide the missing dimension${missingCount > 1 ? 's' : ''}, or provide all dimensions in this format:\n**${dimensionNames.join(' x ')}** (e.g., "${dimensionNames.map(() => '5').join(' x ')}")`
                        );
                        return;
                        
                    } else {
                        // Perfect match - correct number of dimensions
                        const dimensions = [];
                        product.dimensionFields.forEach((field, index) => {
                            if (dimensionValues[index] !== undefined) {
                                dimensions.push({
                                    name: field.name,
                                    value: dimensionValues[index]
                                });
                            }
                        });

                        if (dimensions.length > 0) {
                            console.log("Successfully parsed dimensions manually:", dimensions);
                            
                            // Send confirmation message
                            const dimensionsList = dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
                            await this.whatsappService.sendMessage(
                                from,
                                `âœ… Perfect! I've set your dimensions: **${dimensionsList}**\n\nMoving to the next step...`
                            );
                            
                            // Update conversation state with dimensions (store in conversationData)
                            await conversationService.updateConversationState(from, {
                                'conversationData.dimensions': dimensions
                            });

                            // Move to next step
                            const nextStep = this.getNextStepAfterBypass('dimension_input', { ...conversationData, dimensions });
                            await conversationService.updateConversationState(from, {
                                currentStep: nextStep
                            });

                            // Process the next step without passing the dimension input text
                            const updatedState = await conversationService.getConversationState(from);
                            const mockMessage = { id: 'dimension-processed-' + Date.now() };
                            await this.processConversationFlow(mockMessage, '', from, updatedState, false);
                            return;
                        }
                    }
                }
            }

            // If no dimensions were extracted, ask for them

            if (!product || !product.dimensionFields) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, this product doesn't have dimension requirements. Let me help you with the next step."
                );
                return;
            }

            // Ask for dimensions with product-specific dimension names
            const dimensionNames = product.dimensionFields.map(f => f.name);
            
            // Create appropriate example based on the number of dimensions
            let exampleFormat = '';
            let exampleValues = '';
            if (dimensionNames.length === 1) {
                exampleFormat = `**${dimensionNames[0]}** (e.g., "5")`;
                exampleValues = `Just one value: "5"`;
            } else if (dimensionNames.length === 2) {
                exampleFormat = `**${dimensionNames.join(' x ')}** (e.g., "5 x 8")`;
                exampleValues = `Two values: "5 x 8" or "5, 8"`;
            } else {
                exampleFormat = `**${dimensionNames.join(' x ')}** (e.g., "5 x 8 x 3")`;
                exampleValues = `${dimensionNames.length} values: "${dimensionNames.map(() => '5').join(' x ')}" or "${dimensionNames.map(() => '5').join(', ')}"`;
            }

            await this.whatsappService.sendMessage(
                from,
                `Please provide the ${dimensionNames.length === 1 ? 'dimension' : 'dimensions'} for your **${product.name}**:\n\nðŸ“ **Required:** ${exampleFormat}\n\n**Examples:**\nâ€¢ ${exampleValues}\nâ€¢ With labels: "${dimensionNames.map((name, i) => `${name}:5`).join(', ')}"\n\nAll dimensions should be in inches.`
            );
        } catch (error) {
            console.error('Error in handleDimensionInput:', error);
            await mongoLogger.logError(error, {
                source: 'dimension-input-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your dimensions. Please try again."
            );
        }
    }

    async sendMaterialSelection(from, selectedProduct) {
        const product = await conversationService.getProductById(selectedProduct.id);
        
        // Get current conversation data to show what we already have
        const conversationState = await conversationService.getConversationState(from);
        const conversationData = conversationState.conversationData || {};

        const sections = [{
            title: "Available Materials",
            rows: product.availableMaterials.map(material => ({
                id: material.name,
                title: material.name,
                description: `${material.description} - $${material.pricePerUnit}/unit`
            }))
        }];

        // Build acknowledgment message with collected details
        let acknowledgmentText = "Great! I have the following details from your message:\n\n";
        
        if (conversationData.selectedProduct) {
            acknowledgmentText += `â€¢ Product: ${conversationData.selectedProduct.name}\n`;
        }
        
        if (conversationData.quantity && conversationData.quantity.length > 0) {
            const quantity = conversationData.quantity[0];
            acknowledgmentText += `â€¢ Quantity: ${quantity.toLocaleString()} pieces\n`;
        }
        
        if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
            const finishNames = conversationData.selectedFinish.map(f => f.name).join(', ');
            acknowledgmentText += `â€¢ Finishes: ${finishNames}\n`;
        }
        
        if (conversationData.skus) {
            acknowledgmentText += `â€¢ SKUs: ${conversationData.skus}\n`;
        }
        
        acknowledgmentText += `\nNow please select the material for your ${product.name}:`;

        await this.whatsappService.sendListMessage(
            from,
            acknowledgmentText,
            "Select Material",
            sections
        );
    }

    async sendMaterialRequest(from, selectedCategory) {
        try {
            const category = await this.findCategoryById(selectedCategory.id);

            if (!category) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, category not found. Please try again."
                );
                return;
            }

            // Fetch materials for this category from Material model
            const materials = await Material.find({
                categoryId: selectedCategory.id,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!materials || materials.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no materials are available for this category. Please contact support."
                );
                return;
            }

            // Get conversation state to show all collected information
            const conversationState = await conversationService.getConversationState(from);
            const conversationData = conversationState.conversationData || {};

            let message = `Great! Now please select the material for your ${category.name} products.\n\n`;
            
            // Show all collected information
            message += `Here's what I have so far:\n`;
            message += `ðŸ“‚ **Category:** ${conversationData.selectedCategory?.name || 'Not specified'}\n`;
            message += `ðŸ”§ **Product:** ${conversationData.selectedProduct?.name || 'Not specified'}\n`;
            message += `ðŸ”¢ **Quantity:** ${conversationData.quantity?.join(', ') || 'Not specified'}\n`;
            message += `ðŸ“ **Dimensions:** ${conversationData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'Not specified'}\n`;
            message += `ðŸŽ¨ **SKUs/Designs:** ${conversationData.skus || '1 (default)'}\n`;
            
            // Show finishes (both selected and requested)
            let finishDisplay = 'Not specified';
            if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
                finishDisplay = conversationData.selectedFinish.map(f => f.name).join(', ');
            } else if (conversationData.requestedFinish) {
                finishDisplay = `${conversationData.requestedFinish} (requested)`;
            }
            message += `âœ¨ **Finishes:** ${finishDisplay}\n\n`;
            
            message += `Type your material name.`;

            await this.whatsappService.sendMessage(from, message);
        } catch (error) {
            console.error('Error in sendMaterialRequest:', error);
            await mongoLogger.logError(error, {
                source: 'send-material-request',
                from: from
            });

            await this.whatsappService.sendMessage(
                from,
                "Please type the name of the material you want to use."
            );
        }
    }

    async sendFinishRequest(from, conversationData) {
        try {
            const category = await this.findCategoryById(conversationData.selectedCategory.id);

            if (!category) {
                await this.sendCategorySelection(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'category_selection'
                });
                return;
            }
            const product = await conversationService.getProductById(conversationData.selectedProduct.id);
            console.log("product111111111 ", product);

            if (!product) {
                await this.sendProductSelection(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'product_selection'
                });
                return;
            }

            // Fetch finishes for this category from ProductFinish model
            const finishes = await ProductFinish.find({
                productCategoryId: conversationData.selectedCategory.id,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!finishes || finishes.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no finishes are available for this category. Please contact support."
                );
                return;
            }

            await this.whatsappService.sendMessage(
                from,
                `Great! Now please select the finishes for your ${product.name} product.\n\nType your finish names.`
            );
        } catch (error) {
            console.error('Error in sendFinishRequest:', error);
            await mongoLogger.logError(error, {
                source: 'send-finish-request',
                from: from
            });

            await this.whatsappService.sendMessage(
                from,
                "Please type the name of the finish you want to use."
            );
        }
    }

    async handleMaterialSelection(messageText, from, conversationData) {
        try {
            console.log('ðŸ”§ handleMaterialSelection called:', {
                messageText,
                hasSelectedMaterial: !!(conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0),
                selectedMaterial: conversationData.selectedMaterial,
                selectedMaterialKeys: Object.keys(conversationData.selectedMaterial || {}),
                selectedMaterialName: conversationData.selectedMaterial?.name,
                selectedCategory: conversationData.selectedCategory?.name
            });
            
            // Check if this message looks like a dimension input (e.g., "8x9", "5x5x5")
            const isDimensionMessage = this.isDimensionMessage(messageText);
            
            // Check if we already have material selected
            const hasMaterial = conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0;
            
            // If message looks like dimensions (transitioning from dimension_input step), ask for material
            if (isDimensionMessage) {
                console.log('ðŸŽ¯ Detected dimension message in material selection step, asking for material:', messageText);
                await this.sendMaterialRequest(from, conversationData.selectedCategory);
                return;
            }
            
            // If we already have material, we shouldn't be here - move to next step
            if (hasMaterial) {
                console.log('ðŸŽ¯ Material already selected, moving to next step');
                const nextStep = this.getNextStepAfterBypass('material_selection', conversationData);
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'material-bypass-' + Date.now() };
                await this.processConversationFlow(mockMessage, '', from, updatedState);
                return;
            }

            // IMPORTANT: Don't auto-search for materials in complex messages that aren't material-specific
            // Only search if message is likely a direct material selection
            const isLikelyMaterialMessage = this.isLikelyMaterialSelectionMessage(messageText);
            
            if (!isLikelyMaterialMessage) {
                console.log('ðŸš« Message doesn\'t appear to be a material selection, asking user to choose material');
                await this.sendMaterialRequest(from, conversationData.selectedCategory);
                return;
            }

            // User has provided material, process it
            const category = await this.findCategoryById(conversationData.selectedCategory.id);

            if (!category) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, category not found. Please try again."
                );
                return;
            }

            // Fetch materials for this category from Material model
            const materials = await Material.find({
                categoryId: conversationData.selectedCategory.id,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!materials || materials.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no materials are available for this category. Please try again."
                );
                return;
            }

            // Find matching material with improved matching logic
            let selectedMaterial = null;
            
            // First check if user sent a number (list position)
            const trimmedText = messageText.trim();
            const listPosition = parseInt(trimmedText);
            
            if (false && !isNaN(listPosition) && listPosition >= 1 && listPosition <= materials.length) {
                // DISABLED: User selected by number (1-based indexing) to prevent "5x5" selecting material #5
                selectedMaterial = materials[listPosition - 1];
                console.log(`ðŸ”¢ User selected material by number ${listPosition}: ${selectedMaterial.name}`);
            } else {
                // Special handling for "metallized" - map to MPET materials
                if (messageText.toLowerCase().includes('metallized') || messageText.toLowerCase().includes('metallic')) {
                    console.log('ðŸŽ¯ Special handling for metallized material request');
                    
                    // Look for materials containing MPET in order of preference
                    const mpetMaterials = [
                        'PET +  MPET + PE',  // Exact match from logs
                        'PET + MPET + PE',   // Without extra spaces
                        'Kraft + MPET +PE',  // Alternative
                    ];
                    
                    for (const preferredMaterial of mpetMaterials) {
                        selectedMaterial = materials.find(m => 
                            m.name.toLowerCase() === preferredMaterial.toLowerCase()
                        );
                        if (selectedMaterial) {
                            console.log(`ðŸŽ¯ Mapped "metallized" to: ${selectedMaterial.name}`);
                            break;
                        }
                    }
                    
                    // If exact names don't match, look for any material containing MPET
                    if (!selectedMaterial) {
                        selectedMaterial = materials.find(m => 
                            m.name.toLowerCase().includes('mpet')
                        );
                        if (selectedMaterial) {
                            console.log(`ðŸŽ¯ Mapped "metallized" to MPET material: ${selectedMaterial.name}`);
                        }
                    }
                }
                
                // Try exact match first in category materials (if not already found above)
                if (!selectedMaterial) {
                    selectedMaterial = materials.find(m =>
                        m.name.toLowerCase() === messageText.toLowerCase()
                    );
                }
                
                // If no exact match, use ChatGPT to find the best match
                if (!selectedMaterial) {
                    console.log(`ðŸ¤– Using ChatGPT to find best material match for: "${messageText}"`);
                    try {
                        const context = {
                            availableMaterials: materials.map(m => ({ name: m.name, erp_id: m.erp_id })),
                            categoryId: conversationData.selectedCategory.id
                        };
                        const aiResponse = await this.aiService.processMessage(
                            `Find the best matching material for: "${messageText}"`, 
                            context
                        );
                        
                        if (aiResponse.success && aiResponse.data?.entities?.['material:material'] && aiResponse.data.entities['material:material'].length > 0) {
                            const suggestedMaterial = aiResponse.data.entities['material:material'][0].value || aiResponse.data.entities['material:material'][0].body;
                            selectedMaterial = materials.find(m => 
                                m.name.toLowerCase() === suggestedMaterial.toLowerCase()
                            );
                            if (selectedMaterial) {
                                console.log(`ðŸ¤– ChatGPT found material match: "${messageText}" â†’ "${selectedMaterial.name}"`);
                            }
                        }
                    } catch (aiError) {
                        console.error('ChatGPT material search failed:', aiError);
                    }
                }
                
                // If still not found in category materials, make one more attempt within the category
                if (!selectedMaterial) {
                    console.log(`ðŸ” Material not found in category, doing advanced search within category for: ${messageText}`);
                    selectedMaterial = await this.findMaterialByName(messageText, conversationData.selectedCategory.id);
                    
                    if (selectedMaterial) {
                        console.log(`ðŸŽ¯ Found material across all materials: ${selectedMaterial.name}`);
                        // Convert to the expected format to match category materials structure
                        selectedMaterial = {
                            _id: selectedMaterial._id,
                            name: selectedMaterial.name,
                            erp_id: selectedMaterial.erp_id,
                            description: selectedMaterial.description
                        };
                    }
                }
            }
            
            console.log('ðŸ” Material search result:', {
                searchTerm: messageText,
                foundMaterial: selectedMaterial ? selectedMaterial.name : 'Not found',
                availableMaterials: materials.map(m => m.name)
            });

            if (selectedMaterial) {
                console.log("selectedMaterial ", selectedMaterial);
                
                // Send confirmation message
                await this.whatsappService.sendMessage(
                    from,
                    `âœ… Great! I've selected *${selectedMaterial.name}* as your material.\n\nMoving to the next step...`
                );
                
                // Update conversation data with selected material as array
                await conversationService.updateConversationState(from, {
                    'conversationData.selectedMaterial': [{
                        _id: selectedMaterial.erp_id.toString(),
                        name: selectedMaterial.name,
                        erp_id: selectedMaterial.erp_id
                    }]
                });

                // Bypass material_selection and move to next step
                const nextStep = this.getNextStepAfterBypass('material_selection', {
                    ...conversationData,
                    selectedMaterial: [{
                        _id: selectedMaterial.erp_id.toString(),
                        name: selectedMaterial.name,
                        erp_id: selectedMaterial.erp_id
                    }]
                });

                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step without passing the material selection text
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'material-found-' + Date.now() };
                await this.processConversationFlow(mockMessage, '', from, updatedState);
            } else {
                // Material not found - show available materials instead of creating custom ones
                console.log(`âŒ Material "${messageText}" not found in database, showing available options`);
                
                // Format available materials list
                // Send message asking for material name without numbered list
                await this.whatsappService.sendMessage(
                    from,
                    `âŒ I couldn't find "${messageText}" in our materials database.

Please type the exact name of the material you want to use for your ${category.name}.

*Note: We only use materials from our database to ensure accurate pricing and availability. If you're unsure about material names, please contact our support team.*`
                );
                return; // Don't proceed to next step
            }
        } catch (error) {
            console.error('Error in handleMaterialSelection:', error);
            await mongoLogger.logError(error, {
                source: 'material-selection-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your material selection. Please try again."
            );
        }
    }

    async sendFinishSelection(from, selectedProduct) {
        const product = await conversationService.getProductById(selectedProduct.id);

        const sections = [{
            title: "Available Finishes",
            rows: product.availableFinishes.map(finish => ({
                id: finish.name,
                title: finish.name,
                description: `${finish.description} - $${finish.pricePerUnit}/unit`
            }))
        }];

        const bodyText = `Excellent! Now please select the finish for your mylar bags:`;

        await this.whatsappService.sendListMessage(
            from,
            bodyText,
            "Select Finish",
            sections
        );
    }

    async handleFinishSelection(messageText, from, conversationData) {
        try {
            console.log('ðŸŽ¨ handleFinishSelection called:', {
                messageText,
                hasSelectedFinish: !!(conversationData.selectedFinish && conversationData.selectedFinish.length > 0),
                selectedFinish: conversationData.selectedFinish,
                selectedCategory: conversationData.selectedCategory?.name
            });
            
            // Check if we already have finish selected
            const hasFinish = conversationData.selectedFinish && conversationData.selectedFinish.length > 0;
            
            // If we already have finish, we shouldn't be here - move to next step
            if (hasFinish) {
                console.log('ðŸŽ¯ Finish already selected, moving to next step');
                const nextStep = this.getNextStepAfterBypass('finish_selection', conversationData);
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'finish-bypass-' + Date.now() };
                await this.processConversationFlow(mockMessage, '', from, updatedState);
                return;
            }

            // Check if we have required data
            if (!conversationData.selectedCategory || !conversationData.selectedCategory.id) {
                console.log("No selected category, asking for category selection");
                await this.sendCategorySelection(from);
                return;
            }

            if (!conversationData.selectedProduct || !conversationData.selectedProduct.id) {
                console.log("No selected product, asking for product selection");
                await this.sendProductSelection(from);
                return;
            }

            // Check if this is just asking for finish options (no specific finish provided) or empty string
            const lowerText = messageText.toLowerCase().trim();
            if (lowerText === '' || ['finish', 'finishes', 'what finishes', 'show finishes', 'finish options'].some(keyword => lowerText === keyword)) {
                console.log('ðŸŽ¨ User asking for finish options or empty message, showing available finishes');
                await this.sendFinishRequest(from, conversationData);
                return;
            }

            // User has provided a specific finish, process it
            console.log('ðŸ” Processing user finish selection:', messageText);
            
            // Get categoryId for filtering finishes
            const categoryId = conversationData.selectedCategory.id;
            
            // Get available finishes for this category
            const finishes = await ProductFinish.find({
                productCategoryId: categoryId,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!finishes || finishes.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no finishes are available for this category. Please contact support."
                );
                return;
            }

            console.log('ðŸ” Available finishes for category:', finishes.map(f => f.name));

            // Search for the finish in the category-filtered list
            let selectedFinish = null;
            
            // Try exact match first
            selectedFinish = finishes.find(f =>
                f.name.toLowerCase() === messageText.toLowerCase()
            );
            
            // If no exact match, try fuzzy matching directly
            if (!selectedFinish) {
                console.log(`ðŸ” Trying fuzzy match for finish: "${messageText}"`);
                
                // Try partial matching
                selectedFinish = finishes.find(f =>
                    f.name.toLowerCase().includes(messageText.toLowerCase()) ||
                    messageText.toLowerCase().includes(f.name.toLowerCase())
                );
                
                if (selectedFinish) {
                    console.log(`âœ… Found fuzzy finish match: "${messageText}" â†’ "${selectedFinish.name}"`);
                }
            }
            
            // If still not found, try intelligent mapping for common terms
            if (!selectedFinish) {
                const intelligentMappings = {
                    'soft touch': 'Softtouch Finish',
                    'softtouch': 'Softtouch Finish',
                    'soft': 'Softtouch Finish',
                    'foiling': 'Hot Foil',
                    'foil': 'Hot Foil',
                    'hot foil': 'Hot Foil',
                    'cold foil': 'Cold Foil',
                    'matte': 'Matte Finish',
                    'matt': 'Matte Finish',
                    'glossy': 'Gloss Finish',
                    'gloss': 'Gloss Finish',
                    'spot uv': 'Spot UV',
                    'uv': 'Spot UV',
                    'raised uv': '3D Raised Spot UV',
                    '3d uv': '3D Raised Spot UV',
                    'window': 'Window',
                    'valve': 'Valve',
                    'spout': 'Spout'
                };
                
                const lowerMessage = messageText.toLowerCase();
                for (const [key, value] of Object.entries(intelligentMappings)) {
                    if (lowerMessage.includes(key)) {
                        selectedFinish = finishes.find(f => 
                            f.name.toLowerCase() === value.toLowerCase()
                        );
                        if (selectedFinish) {
                            console.log(`ðŸŽ¯ Found intelligent mapped finish: "${key}" in "${messageText}" â†’ "${selectedFinish.name}"`);
                            break;
                        }
                    }
                }
            }

            if (selectedFinish) {
                // Found a finish, update conversation data
                const finishData = {
                    _id: selectedFinish.erp_id.toString(),
                    name: selectedFinish.name
                };

                await conversationService.updateConversationState(from, {
                    'conversationData.selectedFinish': [finishData]
                });

                console.log('ðŸŽ¨ Selected finish:', selectedFinish.name);

                await this.whatsappService.sendMessage(
                    from,
                    `Perfect! âœ¨ I've selected **${selectedFinish.name}** as your finish.\n\nMoving to the next step...`
                );

                // Move to next step
                const nextStep = this.getNextStepAfterBypass('finish_selection', { ...conversationData, selectedFinish: [finishData] });
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step without passing the finish selection text
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'finish-found-' + Date.now() };
                await this.processConversationFlow(mockMessage, '', from, updatedState);

            } else {
                // No finish found
                console.log('âŒ No finish found for:', messageText);
                
                let message = `Sorry, I couldn't find a finish called "${messageText}" in the ${conversationData.selectedCategory.name} category.\n\n`;
                message += `Please type the exact name of the finish you want to use.\n\n`;
                message += `*Note: If you're unsure about available finish names, please contact our support team.*`;

                await this.whatsappService.sendMessage(from, message);
            }

        } catch (error) {
            console.error('Error in handleFinishSelection:', error);
            await mongoLogger.logError(error, {
                source: 'finish-selection-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your finish selection. Please try again."
            );
        }
    }

    async sendQuantityRequest(from) {
        const message = `Almost done! ðŸ“Š

Please tell me the quantity of mylar bags you need:

Examples:
â€¢ "500 pieces"
â€¢ "1000"
â€¢ "2500 bags"

What quantity would you like?`;

        await this.whatsappService.sendMessage(from, message);
    }

    async handleQuantityInput(messageText, from, conversationData) {
        try {
            // Check if quantity already exists
            if (conversationData.quantity && conversationData.quantity.length > 0) {
                console.log("Quantity already exists, bypassing quantity input step");

                // Bypass quantity_input and move to next step
                const nextStep = this.getNextStepAfterBypass('quantity_input', conversationData);

                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'quantity-bypass-' + Date.now() };
                await this.processConversationFlow(mockMessage, '', from, updatedState, false);
                return;
            }

            // Check if we have all required data for quote generation
            if (!conversationData.selectedProduct || !conversationData.selectedMaterial ||
                !conversationData.selectedFinish || conversationData.selectedFinish.length === 0) {
                console.log("Missing required data for quote generation");

                // Guide user to complete missing steps
                if (!conversationData.selectedProduct) {
                    await this.sendProductSelection(from);
                    return;
                }
                if (!conversationData.selectedMaterial) {
                    await this.sendMaterialRequest(from, conversationData.selectedCategory);
                    return;
                }
                if (!conversationData.selectedFinish || conversationData.selectedFinish.length === 0) {
                    await this.sendFinishRequest(from, conversationData);
                    return;
                }
            }

            // Extract quantity from user's message
            console.log('ðŸ”¢ Processing quantity input:', messageText);
            
            // Try to extract quantity using various methods
            let extractedQuantity = null;
            
            // Method 1: Handle "k" notation first (5k = 5000, 2.5k = 2500)
            const kMatch = messageText.match(/(\d+(?:\.\d+)?)\s*k\b/i);
            if (kMatch) {
                extractedQuantity = Math.round(parseFloat(kMatch[1]) * 1000);
                console.log('âœ… Extracted quantity from "k" notation:', extractedQuantity);
            }
            
            // Method 2: Direct number extraction if no "k" found (handles "50000", "5000", etc.)
            if (!extractedQuantity) {
                const numberMatch = messageText.match(/\b(\d{1,3}(?:,\d{3})*|\d+)\b/);
                if (numberMatch) {
                    const numberStr = numberMatch[1].replace(/,/g, ''); // Remove commas
                    extractedQuantity = parseInt(numberStr);
                    console.log('âœ… Extracted quantity from number:', extractedQuantity);
                }
            }
            
            // Method 3: Use AI service for complex quantity extraction
            if (!extractedQuantity) {
                try {
                    const aiResponse = await this.aiService.processMessage(messageText, {
                        expectingQuantity: true,
                        from: from
                    });
                    
                    if (aiResponse.success && aiResponse.data?.entities?.['quantity:quantity']) {
                        const quantityEntity = aiResponse.data.entities['quantity:quantity'][0];
                        extractedQuantity = parseInt(quantityEntity.value || quantityEntity.body);
                        console.log('âœ… Extracted quantity using AI:', extractedQuantity);
                    }
                } catch (aiError) {
                    console.log('AI quantity extraction failed:', aiError.message);
                }
            }
            
            if (extractedQuantity && extractedQuantity > 0) {
                // Valid quantity found, save it
                await conversationService.updateConversationState(from, {
                    'conversationData.quantity': [extractedQuantity]
                });
                
                console.log('ðŸ“¦ Quantity saved:', extractedQuantity);
                
                await this.whatsappService.sendMessage(
                    from,
                    `Perfect! âœ… I've noted your quantity: **${extractedQuantity.toLocaleString()}** pieces.\n\nMoving to the next step...`
                );
                
                // Move to next step (quote generation)
                const nextStep = this.getNextStepAfterBypass('quantity_input', { ...conversationData, quantity: [extractedQuantity] });
                
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });
                
                // Process the next step
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'quantity-found-' + Date.now() };
                await this.processConversationFlow(mockMessage, '', from, updatedState);
                
            } else {
                // Could not extract valid quantity, ask again
                console.log('âŒ Could not extract valid quantity from:', messageText);
                await this.sendQuantityRequest(from);
            }
            
        } catch (error) {
            console.error('Error in handleQuantityInput:', error);
            await mongoLogger.logError(error, {
                source: 'quantity-input-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I couldn't process your quantity. Please try again with a number like '5000' or '10k'."
            );
        }
    }

    async handleQuoteGeneration(messageText, from, conversationData, message) {
        console.log("ðŸ” [QUOTE DEBUG START] ======================");
        console.log("ðŸ” [QUOTE DEBUG] messageText:", messageText);
        console.log("ðŸ” [QUOTE DEBUG] quoteAcknowledged:", conversationData.quoteAcknowledged);
        console.log("ðŸ” [QUOTE DEBUG] pricing_done:", conversationData.pricing_done);
        console.log("ðŸ” [QUOTE DEBUG] wantsPdf:", conversationData.wantsPdf);
        console.log("ðŸ” [QUOTE DEBUG] completed:", conversationData.completed);
        console.log("ðŸ” [QUOTE DEBUG END] ======================");
        console.log("conversationData111111111 ", conversationData);
        try {
            // Check if this looks like a dimension message (e.g., "5x5x5", "10,8,3", etc.)
            const isDimensionMessage = this.isDimensionMessage(messageText);
            if (isDimensionMessage && (!conversationData.dimensions || conversationData.dimensions.length === 0)) {
                console.log("Detected dimension message in quote generation, processing as dimensions");
                
                // Get the product to know what dimensions are needed
                const product = conversationData.selectedProduct;
                if (product && product.dimensionFields) {
                    const dimensionNames = product.dimensionFields.map(f => f.name);
                    const parsedDimensions = await this.parseDimensionsManually(messageText, dimensionNames);
                    
                    if (parsedDimensions.length > 0) {
                        console.log("Successfully parsed dimensions from quote generation:", parsedDimensions);
                        
                        // Update conversation state with dimensions (store in conversationData)
                        await conversationService.updateConversationState(from, {
                            'conversationData.dimensions': parsedDimensions
                        });
                        
                        // Verify dimensions were stored
                        const verifyState = await conversationService.getConversationState(from);
                        console.log('ðŸ” Dimensions after storage:', verifyState.conversationData?.dimensions);
                        
                        // Move back to quote generation to continue
                        await conversationService.updateConversationState(from, {
                            currentStep: 'quote_generation'
                        });
                        
                        // Verify dimensions are still there after step update
                        const finalState = await conversationService.getConversationState(from);
                        console.log('ðŸ” Dimensions after step update:', finalState.conversationData?.dimensions);
                        
                        // Process the next step
                        const updatedState = await conversationService.getConversationState(from);
                        await this.processConversationFlow(message, messageText, from, updatedState, false);
                        return;
                    }
                }
            }
            
            // Set default SKU value if not provided
            if (!conversationData.skus) {
                await conversationService.updateConversationState(from, {
                    'conversationData.skus': 1
                });
                // Update local reference
                conversationData.skus = 1;
            }

            // Validate required data before showing acknowledgment
            const validationResult = this.validateQuoteData(conversationData);
            if (!validationResult.isValid) {
                console.log("Missing required data for quote generation:", validationResult.missingFields);
                
                // Send helpful message about what's missing
                const missingMessage = `I need more information to generate your quote. Please provide:\n\n${validationResult.missingFields.join('\n')}\n\nLet's go back and collect this information.`;
                
                await this.whatsappService.sendMessage(from, missingMessage);
                
                // Reset to appropriate step based on what's missing
                const resetStep = this.getResetStepForMissingData(validationResult.missingFields, conversationData);
                await conversationService.updateConversationState(from, {
                    currentStep: resetStep,
                    'conversationData.quoteAcknowledged': false // Reset acknowledgment so user gets fresh confirmation when data is complete
                });
                
                return;
            }

            // Check if this is the first time in quote generation (acknowledge selections)
            if (!conversationData.quoteAcknowledged) {
                // Format the acknowledgment message
                const categoryName = conversationData.selectedCategory?.name || 'Not specified';
                const productName = conversationData.selectedProduct?.name || 'Not specified';
                // Format materials (without showing internal ERP IDs)
                const materialName = (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) 
                    ? conversationData.selectedMaterial.map(m => m.name).join(', ')
                    : conversationData.requestedMaterial || 'Not specified';

                // Format finishes
                const finishNames = conversationData.selectedFinish?.map(f => f.name).join(', ') || 'Not specified';

                // Format dimensions
                const dimensionsText = conversationData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'Not specified';

                // Format quantities
                const quantitiesText = conversationData.quantity?.join(', ') || 'Not specified';

                // Format SKUs - show actual value or indicate it will default to 1
                const skusText = conversationData.skus ? conversationData.skus.toString() : '1 (default)';

                const acknowledgmentMessage = `Perfect! ðŸŽ¯ Let me confirm your selections:

ðŸ“¦ **Category:** ${categoryName}
ðŸ”§ **Product:** ${productName}
ðŸ§± **Materials:** ${materialName}
âœ¨ **Finishes:** ${finishNames}
ðŸ“ **Dimensions:** ${dimensionsText}
ðŸ”¢ **Quantities:** ${quantitiesText}
ðŸŽ¨ **SKUs/Designs:** ${skusText}

Based on the information you've provided, would you like me to generate pricing for your quote? 

Please reply with "Yes" to get pricing details, or "No" if you'd like to make any changes.`;

                await this.sendMessageOnce(
                    message?.id || 'auto-generated-' + Date.now(),
                    from,
                    acknowledgmentMessage
                );

                // Mark as acknowledged and wait for response
                await conversationService.updateConversationState(from, {
                    'conversationData.quoteAcknowledged': true
                });

            } else {
                // Process user's response
                const response = messageText.toLowerCase().trim();
                const safeMessageId = message?.id || 'quote-response-' + Date.now();
                
                console.log(`ðŸŽ¯ Processing user response: "${response}"`);
                console.log(`ðŸŽ¯ pricing_done: ${conversationData.pricing_done}, wantsPdf: ${conversationData.wantsPdf}`);
                console.log(`ðŸŽ¯ pricing_done type: ${typeof conversationData.pricing_done}`);
                console.log(`ðŸŽ¯ Condition 1 (pricing_done && !wantsPdf): ${conversationData.pricing_done && !conversationData.wantsPdf}`);
                console.log(`ðŸŽ¯ Condition 2 (!pricing_done): ${!conversationData.pricing_done}`);

                // Check if user is responding to document request after pricing is done
                if (conversationData.pricing_done && !conversationData.wantsPdf) {
                    if (response.includes('pdf') || response.includes('yes') || response.includes('generate')) {
                        // Check if already completed to prevent duplicate processing
                        if (conversationData.completed) {
                            console.log(`â­ï¸ Conversation already completed for ${from}, skipping duplicate PDF generation`);
                            return;
                        }

                        // User wants PDF, generate and send it
                        await conversationService.updateConversationState(from, {
                            'conversationData.wantsPdf': true
                        });

                        await this.generateAndSendPDF(from, conversationData, safeMessageId);
                        
                        // Send completion message
                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            `âœ… **Quote Complete!** 

Thank you for using our quote system! Your PDF quote has been generated and sent.

Need another quote? Just say "Hi" or "New Quote" anytime! ðŸŒŸ`
                        );

                        // Mark as fully completed
                        await conversationService.updateConversationState(from, {
                            'conversationData.completed': true,
                            currentStep: 'completed',
                            isActive: false
                        });

                    } else if (response.includes('no') || response.includes('n') || response.includes('not')) {
                        // Check if already completed to prevent duplicate processing
                        if (conversationData.completed) {
                            console.log(`â­ï¸ Conversation already completed for ${from}, skipping duplicate completion`);
                            return;
                        }

                        // User doesn't want PDF, end conversation
                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            `âœ… **Quote Complete!** 

Thank you for using our quote system! 

Need another quote? Just say "Hi" or "New Quote" anytime! ðŸŒŸ`
                        );

                        // Mark as completed without PDF
                        await conversationService.updateConversationState(from, {
                            'conversationData.completed': true,
                            currentStep: 'completed',
                            isActive: false
                        });
                    } else {
                        // Unclear response to document question
                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            `ðŸ“„ Would you like me to generate a PDF quote for you?\n\nâ€¢ Reply "Yes" or "PDF" to get your quote\nâ€¢ Reply "No" to finish without the document`
                        );
                    }
                } else if (!conversationData.pricing_done) {
                    console.log(`ðŸŽ¯ Taking pricing branch - pricing not done yet`);
                    // Check if user is providing additional information (like SKUs) before confirming
                    if (messageText.toLowerCase().includes('sku') && !response.includes('yes') && !response.includes('no')) {
                        // Extract SKU information
                        const skuMatch = messageText.match(/sku\s*(?:is\s*)?(\d+)/i);
                        if (skuMatch) {
                            const skuValue = parseInt(skuMatch[1]);
                            
                            // Update conversation data with SKU
                            await conversationService.updateConversationState(from, {
                                'conversationData.skus': skuValue
                            });
                            
                            // Re-send confirmation with updated information
                            const updatedState = await conversationService.getConversationState(from);
                            const updatedData = updatedState.conversationData;
                            
                            // Format the updated acknowledgment message
                            const categoryName = updatedData.selectedCategory?.name || 'Not specified';
                            const productName = updatedData.selectedProduct?.name || 'Not specified';
                            const materialName = (updatedData.selectedMaterial && updatedData.selectedMaterial.length > 0) 
                                ? updatedData.selectedMaterial.map(m => m.name).join(', ')
                                : updatedData.requestedMaterial || 'Not specified';
                            const finishNames = updatedData.selectedFinish?.map(f => f.name).join(', ') || 'Not specified';
                            const dimensionsText = updatedData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'Not specified';
                            const quantitiesText = updatedData.quantity?.join(', ') || 'Not specified';
                            const skusText = updatedData.skus ? updatedData.skus.toString() : '1 (default)';

                            const updatedAcknowledgmentMessage = `Perfect! ðŸŽ¯ Let me confirm your updated selections:

ðŸ“¦ **Category:** ${categoryName}
ðŸ”§ **Product:** ${productName}
ðŸ§± **Materials:** ${materialName}
âœ¨ **Finishes:** ${finishNames}
ðŸ“ **Dimensions:** ${dimensionsText}
ðŸ”¢ **Quantities:** ${quantitiesText}
ðŸŽ¨ **SKUs/Designs:** ${skusText}

Based on the information you've provided, would you like me to generate pricing for your quote? 

Please reply with "Yes" to get pricing details, or "No" if you'd like to make any changes.`;

                            await this.sendMessageOnce(
                                safeMessageId,
                                from,
                                updatedAcknowledgmentMessage
                            );
                            return;
                        }
                    }
                    
                    // User is responding to initial pricing question
                    console.log(`ðŸ” Checking pricing response: "${response}" vs "yes"`);
                    console.log(`ðŸ” pricing_done: ${conversationData.pricing_done}, includes yes: ${response.includes('yes')}`);
                    if (response.includes('yes') || response.includes('y') || response.includes('sure') || response.includes('ok')) {
                        // User wants pricing, generate and send quote
                        try {
                            console.log("User wants pricing, calling getPricingForQuote...");
                            const pricing = await this.getPricingForQuote(conversationData);
                            console.log("Pricing result:", pricing);

                            if (pricing && !pricing.error) {
                                // Store pricing in conversation data
                                await conversationService.updateConversationState(from, {
                                   
                                    'conversationData.pricingData': pricing,
                                    'conversationData.pricing_done': true
                                });

                                // Send beautiful pricing table
                                await this.sendPricingTable(from, conversationData, pricing, safeMessageId);
                            } else {
                                // Handle pricing error
                                await this.sendMessageOnce(
                                    safeMessageId,
                                    from,
                                    "Sorry, I couldn't get pricing information at the moment. Please try again later or contact our support team."
                                );
                            }
                        } catch (pricingError) {
                            console.error("Error in pricing generation:", pricingError);
                            await mongoLogger.logError(pricingError, {
                                source: 'pricing-generation',
                                from: from,
                                conversationData: conversationData
                            });
                            
                            await this.sendMessageOnce(
                                safeMessageId,
                                from,
                                "Sorry, I encountered an error generating your pricing. Please try again later or contact our support team."
                            );
                        }
                    } else if (response.includes('no') || response.includes('n') || response.includes('not')) {
                        // User doesn't want pricing, end conversation gracefully
                        const goodbyeMessage = `No problem! ðŸ˜Š 

I'm always here to help you whenever you need a quote. Just say "Hi" or "Get Quote" anytime you're ready, and I'll be happy to assist you with pricing for your products.

Have a great day! ðŸŒŸ`;

                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            goodbyeMessage
                        );

                        // Inactivate conversation
                        await conversationService.updateConversationState(from, {
                            currentStep: 'completed',
                            isActive: false,
                            'conversationData.completed': true
                        });

                    } else {
                        // Unclear response - check if they're trying to provide additional information
                        if (messageText.length > 2 && (messageText.toLowerCase().includes('sku') || 
                            messageText.toLowerCase().includes('design') || 
                            messageText.toLowerCase().includes('quantity') ||
                            messageText.toLowerCase().includes('material') ||
                            messageText.toLowerCase().includes('finish'))) {
                            
                            await this.sendMessageOnce(
                                message.id,
                                from,
                                "I see you want to update some information. To make changes, please reply with 'No' and I'll help you update your quote details. Or reply with 'Yes' to proceed with the current information for pricing."
                            );
                        } else {
                            // Unclear response, ask for clarification
                            await this.sendMessageOnce(
                                message.id,
                                from,
                                "I didn't quite catch that. Please reply with 'Yes' if you'd like pricing details, or 'No' if you'd like to make changes."
                            );
                        }
                    }
                } else {
                    console.log(`ðŸŽ¯ Taking fallback branch - pricing done but unclear response`);
                    // Unclear response, ask for clarification
                    await this.sendMessageOnce(
                        message.id,
                        from,
                        "I didn't quite catch that. Please reply with 'Yes' if you'd like pricing details, or 'No' if you'd like to make changes."
                    );
                }
            }

        } catch (error) {
            console.error('Error in handleQuoteGeneration:', error);
            await mongoLogger.logError(error, {
                source: 'quote-generation-handler',
                from: from,
                messageText: messageText
            });

            await this.sendMessageOnce(
                message?.id || 'error-response-' + Date.now(),
                from,
                "Sorry, I encountered an error processing your request. Please try again or type 'hi' to restart."
            );
        }
    }

    async getPricingForQuote(conversationData) {
        try {
            console.log("getPricingForQuote - conversationData:", JSON.stringify(conversationData, null, 2));
            
            // Prepare the payload for the pricing API
            const payload = {
                file_type: conversationData.selectedCategory?.erp_id?.toString() || "1",
                product_id: conversationData.selectedProduct?.erp_id,
                material_id: conversationData.selectedMaterial?.[0]?.erp_id,
                finishes: conversationData.selectedFinish?.map(finish => {
                    console.log("Processing finish:", finish);
                    const finishId = parseInt(finish._id);
                    if (isNaN(finishId)) {
                        console.error("Invalid finish ID:", finish._id);
                        throw new Error(`Invalid finish ID: ${finish._id}`);
                    }
                    return {
                        id: finishId,
                        value: null
                    };
                }) || [],
                quantities: conversationData.quantity || [],
                dimensions: conversationData.dimensions?.map(dim => dim.value) || []
            };


            console.log("payload", payload);
            console.log("Pricing API Payload:", JSON.stringify(payload, null, 2));

            // Make API call to get pricing
            console.log("Making API call to:", `${process.env.ERP_API_BASE_URL}/api/get-quote-price-for-whatsapp`);
            
            const response = await fetch(`${process.env.ERP_API_BASE_URL}/api/get-quote-price-for-whatsapp`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // 'Authorization': `Bearer ${process.env.PRICING_API_TOKEN || ''}`,
                    // Add any other required headers
                },
                body: JSON.stringify(payload)
            });

            console.log("API Response status:", response.status, response.statusText);

            if (!response.ok) {
                const errorText = await response.text();
                console.error("API Error Response:", errorText);
                throw new Error(`Pricing API error: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const pricingData = await response.json();
            console.log("Pricing API Response:", pricingData);

            return pricingData;

        } catch (error) {
            console.error('Error getting pricing for quote:', error);
            await mongoLogger.logError(error, {
                source: 'pricing-api-call',
                conversationData: conversationData
            });
            
            // Return a default pricing structure or null
            return {
                error: true,
                message: 'Failed to get pricing information',
                details: error.message
            };
        }
    }

    async sendPricingTable(from, conversationData, pricingData, messageId = null) {
        try {
            const { qty, unit_cost } = pricingData;
            
            // Create beautiful simplified pricing message
            let pricingMessage = `ï¿½ *Quote Ready!*\n\n`;
            
            // Product summary
            pricingMessage += `ðŸ“¦ ${conversationData.selectedProduct?.name || 'Product'}\n`;
            if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
                const materialsText = conversationData.selectedMaterial.map(m => m.name).join(', ');
                pricingMessage += `ðŸ§± ${materialsText}\n`;
            }
            pricingMessage += `âœ¨ ${conversationData.selectedFinish?.map(f => f.name).join(', ') || 'Standard'}\n`;
            pricingMessage += `ðŸ“ ${conversationData.dimensions?.map(d => `${d.value}`).join(' x ') || 'Custom'}\n\n`;
            
            // Simplified pricing - show best value tier
            const bestTierIndex = qty.length - 1; // Last tier is usually best value
            
            // Show all pricing tiers
            pricingMessage += `ðŸ’° *Pricing Options*\n`;
            qty.forEach((quantity, index) => {
                const unitPrice = unit_cost[index];
                const totalPrice = (quantity * unitPrice).toFixed(2);
                
                // Mark best value (usually highest tier)
                const isBestValue = index === qty.length - 1;
                const bestMark = isBestValue ? ' â­' : '';
                
                pricingMessage += `${quantity.toLocaleString()} pcs â†’ $${unitPrice.toFixed(3)} each â†’ *$${totalPrice}*${bestMark}\n`;
            });
            pricingMessage += `\n`;
            
            // Simple PDF offer
            pricingMessage += `ðŸ“„ *Get PDF Quote?*\n`;
            pricingMessage += `Reply "Yes" for detailed document`;

            if (messageId) {
                await this.sendMessageOnce(messageId, from, pricingMessage);
            } else {
                await this.whatsappService.sendMessage(from, pricingMessage);
            }

        } catch (error) {
            console.error('Error sending pricing table:', error);
            await mongoLogger.logError(error, {
                source: 'pricing-table-sender',
                from: from,
                pricingData: pricingData
            });

            // Simple fallback message with all tiers
            let fallbackMessage = `ðŸŽ¯ *Quote Ready!*\n\n`;
            
            fallbackMessage += `ðŸ’° *Pricing Options*\n`;
            pricingData.qty.forEach((quantity, index) => {
                const unitPrice = pricingData.unit_cost[index];
                const totalPrice = (quantity * unitPrice).toFixed(2);
                const isBestValue = index === pricingData.qty.length - 1;
                const bestMark = isBestValue ? ' â­' : '';
                
                fallbackMessage += `${quantity.toLocaleString()} pcs â†’ $${unitPrice.toFixed(3)} each â†’ *$${totalPrice}*${bestMark}\n`;
            });
            
            fallbackMessage += `\nðŸ“„ *Get PDF Quote?*\n`;
            fallbackMessage += `Reply "Yes" for detailed document`;
            
            await this.whatsappService.sendMessage(from, fallbackMessage);
        }
    }

    async generateAndSendPSF(from, conversationData, messageId = null) {
        try {
            console.log("Generating PSF for:", from);
            console.log("Conversation data for PSF:", JSON.stringify(conversationData, null, 2));
            
            // Create PSF document using PDFKit
            console.log("Creating PSF document...");
            const psfBuffer = await this.createPSFDocument(conversationData);
            console.log("PSF document created, buffer size:", psfBuffer.length);
            
            // For Vercel compatibility, try buffer approach first
            try {
                console.log("Attempting to send PSF via buffer...");
                // Send PSF directly from buffer (Vercel-friendly)
                await this.whatsappService.sendDocument(from, {
                    buffer: psfBuffer,
                    filename: `PSF_${Date.now()}.pdf`,
                    caption: "ðŸ“‹ Here's your Product Specification Form (PSF)!"
                });
                
                console.log("PSF sent successfully via buffer to:", from);
                
            } catch (bufferError) {
                console.error("Buffer upload failed:", bufferError);
                console.log("Trying file approach...");
                
                // Fallback to file approach
                const tempPath = await this.createTempPDF(psfBuffer, from, 'PSF');
                console.log("Temp PSF created at:", tempPath);
                
                // Send PSF via WhatsApp
                await this.whatsappService.sendDocument(from, {
                    link: tempPath,
                    filename: `PSF_${Date.now()}.pdf`,
                    caption: "ðŸ“‹ Here's your Product Specification Form (PSF)!"
                });
                
                console.log("PSF sent successfully via file to:", from);
            }
            
        } catch (error) {
            console.error('Error generating/sending PSF:', error);
            await mongoLogger.logError(error, {
                source: 'psf-generation',
                from: from
            });
            
            // Fallback message
            await this.sendMessageOnce(
                messageId || 'psf-error',
                from,
                "Sorry, I couldn't generate the PSF at the moment. However, you have all the product specification information above. Please contact our support if you need assistance."
            );
        }
    }

    async generateAndSendPDF(from, conversationData, messageId = null) {
        try {
            console.log("Generating PDF for:", from);
            console.log("Conversation data for PDF:", JSON.stringify(conversationData, null, 2));
            
            // Create PDF document using PDFKit
            console.log("Creating PDF document...");
            const pdfBuffer = await this.createPDFDocument(conversationData);
            console.log("PDF document created, buffer size:", pdfBuffer.length);
            
            // For Vercel compatibility, try buffer approach first
            try {
                console.log("Attempting to send PDF via buffer...");
                // Send PDF directly from buffer (Vercel-friendly)
                await this.whatsappService.sendDocument(from, {
                    buffer: pdfBuffer,
                    filename: `Quote_${Date.now()}.pdf`,
                    caption: "ðŸ“„ Here's your detailed quote PDF!"
                });
                
                console.log("PDF sent successfully via buffer to:", from);
                
            } catch (bufferError) {
                console.error("Buffer upload failed:", bufferError);
                console.log("Trying file approach...");
                
                // Fallback to file approach
                const tempPath = await this.createTempPDF(pdfBuffer, from);
                console.log("Temp PDF created at:", tempPath);
                
                // Send PDF via WhatsApp
                await this.whatsappService.sendDocument(from, {
                    link: tempPath,
                    filename: `Quote_${Date.now()}.pdf`,
                    caption: "ðŸ“„ Here's your detailed quote PDF!"
                });
                
                console.log("PDF sent successfully via file to:", from);
            }
            
        } catch (error) {
            console.error('Error generating/sending PDF:', error);
            await mongoLogger.logError(error, {
                source: 'pdf-generation',
                from: from
            });
            
            // Fallback message - use sendMessageOnce to prevent duplicates
            await this.sendMessageOnce(
                messageId || 'pdf-error',
                from,
                "Sorry, I couldn't generate the PDF at the moment. However, you have all the pricing information above. Please contact our support if you need assistance."
            );
        }
    }

    async createPSFDocument(conversationData) {
        try {
            console.log("Starting PSF creation...");
            console.log("Conversation data:", JSON.stringify(conversationData, null, 2));
            
            // Import PDFKit dynamically
            console.log("Importing PDFKit...");
            const PDFDocument = (await import('pdfkit')).default;
            console.log("PDFKit imported successfully");
            
            const doc = new PDFDocument({ 
                size: 'A4',
                margin: 0,
                layout: 'portrait'
            });
            const chunks = [];
            
            // Collect PDF data
            doc.on('data', chunk => chunks.push(chunk));
            doc.on('end', () => {
                console.log("PSF generation completed");
            });
            
            const pageWidth = doc.page.width;
            const pageHeight = doc.page.height;
            
            // Set up colors
            const primaryColor = '#000000';
            const secondaryColor = '#333333';
            const accentColor = '#0066CC'; // Blue for PSF highlights
            const headerColor = '#F0F8FF'; // Light blue header background
            
            // Background
            doc.rect(0, 0, pageWidth, pageHeight).fill('#FFFFFF');
            
            // Header background
            doc.rect(0, 0, pageWidth, 120).fill(headerColor);
            
            // Vertical PSF text on the left
            doc.save()
               .translate(30, 120)
               .rotate(-90)
               .fontSize(48)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('PSF', 0, 0)
               .restore();
            
            // Header section with logo area
            const headerY = 30;
            const contentStartX = 120;
            
            // Company logo using logo.png image
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Get the absolute path to the logo image
                const logoPath = path.join(process.cwd(), 'public', 'logo.png');
                
                // Check if logo exists
                await fs.access(logoPath);
                
                // Add the logo.png image in PSF header
                doc.image(logoPath, contentStartX, headerY - 10, {
                    width: 120,
                    height: 50
                });
                
            } catch (logoError) {
                console.log('Could not load logo.png for PSF, falling back to text');
                // Fallback to text if logo fails
                doc.fontSize(28)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Print247', contentStartX, headerY)
                   .fontSize(18)
                   .font('Helvetica')
                   .text('.us', contentStartX + 100, headerY + 5);
            }
            
            // PSF Title
            doc.fontSize(24)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('Product Specification Form', contentStartX, headerY + 40);
            
            // Document info
            doc.fontSize(12)
               .fillColor(secondaryColor)
               .font('Helvetica')
               .text(`PSF No: PSF-${Date.now()}`, contentStartX, headerY + 70)
               .text(`Date: ${new Date().toLocaleDateString('en-US')}`, pageWidth - 150, headerY + 70);
            
            // Main content area
            let currentY = 150;
            const leftCol = contentStartX;
            const rightCol = contentStartX + 250;
            const lineHeight = 25;
            
            // Product Information Section
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('ðŸ“¦ PRODUCT INFORMATION', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 200)
               .stroke('#E0E0E0');
            
            const productInfo = [
                ['Category:', conversationData.selectedCategory?.name || 'Not specified'],
                ['Product Type:', conversationData.selectedProduct?.name || 'Not specified'],
                ['Job Name:', conversationData.selectedProduct?.name || 'Custom Product'],
                ['SKUs/Designs:', conversationData.skus?.toString() || '1 (default)'],
                ['Estimated Turnaround:', '12 - 15 Business Days'],
                ['Shipping Method:', 'DAP (Delivered At Place)']
            ];
            
            productInfo.forEach(([label, value]) => {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text(label, leftCol, currentY)
                   .font('Helvetica')
                   .text(value, leftCol + 120, currentY);
                currentY += lineHeight;
            });
            
            // Materials & Specifications Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('ðŸ§± MATERIALS & SPECIFICATIONS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 150)
               .stroke('#E0E0E0');
            
            // Materials
            if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Materials:', leftCol, currentY);
                
                conversationData.selectedMaterial.forEach((material, index) => {
                    doc.font('Helvetica')
                       .text(`â€¢ ${material.name}`, leftCol + 120, currentY + (index * 15));
                });
                currentY += (conversationData.selectedMaterial.length * 15) + 10;
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Materials:', leftCol, currentY)
                   .font('Helvetica')
                   .text(conversationData.requestedMaterial || 'Standard Material', leftCol + 120, currentY);
                currentY += lineHeight;
            }
            
            // Dimensions
            if (conversationData.dimensions && conversationData.dimensions.length > 0) {
                const dimensionsText = conversationData.dimensions
                    .map(d => `${d.name}: ${d.value}"`)
                    .join(' Ã— ');
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Dimensions:', leftCol, currentY)
                   .font('Helvetica')
                   .text(dimensionsText, leftCol + 120, currentY);
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Dimensions:', leftCol, currentY)
                   .font('Helvetica')
                   .text('Custom Size', leftCol + 120, currentY);
            }
            currentY += lineHeight;
            
            // Finishes Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('âœ¨ FINISHES & TREATMENTS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 100)
               .stroke('#E0E0E0');
            
            if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Selected Finishes:', leftCol, currentY);
                
                conversationData.selectedFinish.forEach((finish, index) => {
                    doc.font('Helvetica')
                       .text(`â€¢ ${finish.name}`, leftCol + 120, currentY + (index * 15));
                });
                currentY += (conversationData.selectedFinish.length * 15) + 10;
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Finishes:', leftCol, currentY)
                   .font('Helvetica')
                   .text('Standard Finish', leftCol + 120, currentY);
                currentY += lineHeight;
            }
            
            // Quantity Requirements Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('ðŸ”¢ QUANTITY REQUIREMENTS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 80)
               .stroke('#E0E0E0');
            
            if (conversationData.quantity && conversationData.quantity.length > 0) {
                const quantitiesText = conversationData.quantity.map(q => q.toLocaleString()).join(', ');
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Requested Quantities:', leftCol, currentY)
                   .font('Helvetica')
                   .text(`${quantitiesText} pieces`, leftCol + 120, currentY);
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Quantities:', leftCol, currentY)
                   .font('Helvetica')
                   .text('To be determined', leftCol + 120, currentY);
            }
            currentY += lineHeight + 10;
            
            // Notes Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('ðŸ“ NOTES & REQUIREMENTS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 100)
               .stroke('#E0E0E0');
            
            doc.fontSize(10)
               .fillColor(secondaryColor)
               .font('Helvetica')
               .text('â€¢ This PSF contains the specifications as discussed via WhatsApp', leftCol, currentY)
               .text('â€¢ Final specifications may be adjusted based on artwork review', leftCol, currentY + 15)
               .text('â€¢ Please confirm all specifications before proceeding to production', leftCol, currentY + 30)
               .text('â€¢ Contact us for any clarifications or modifications needed', leftCol, currentY + 45);
            
            // Footer section
            const footerY = pageHeight - 120;
            
            // Use print247usa.png image instead of text circle
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Get the absolute path to the image
                const imagePath = path.join(process.cwd(), 'public', 'print247usa.png');
                
                // Check if image exists
                await fs.access(imagePath);
                
                // Add the print247usa.png image
                doc.image(imagePath, leftCol + 15, footerY - 35, {
                    width: 70,
                    height: 70
                });
                
            } catch (imageError) {
                console.log('Could not load print247usa.png for PSF, falling back to text');
                // Fallback to circle and text if image fails
                doc.circle(leftCol + 50, footerY, 35)
                   .stroke(primaryColor);
                
                doc.fontSize(8)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('PRODUCT SPEC', leftCol + 20, footerY - 15, { align: 'center' })
                   .text('APPROVED BY', leftCol + 20, footerY - 7, { align: 'center' })
                   .text('Print247.us', leftCol + 20, footerY + 1, { align: 'center' })
                   .text('PSF DEPT', leftCol + 20, footerY + 9, { align: 'center' });
            }
            
            // Authorization section
            doc.fontSize(10)
               .font('Helvetica-Bold')
               .text('Customer Approval:', leftCol + 150, footerY - 20)
               .text('_____________________', leftCol + 150, footerY)
               .text('Signature & Date', leftCol + 150, footerY + 20);
            
            // PSF ID and Date
            doc.fontSize(8)
               .fillColor(secondaryColor)
               .text(`PSF-${Date.now()}`, pageWidth - 150, footerY - 20)
               .text(`Generated: ${new Date().toLocaleString('en-US')}`, pageWidth - 150, footerY)
               .text('This is a computer generated document', pageWidth - 150, footerY + 20);
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be ready
            return new Promise((resolve) => {
                doc.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            });
            
        } catch (error) {
            console.error('Error creating PSF document:', error);
            throw error;
        }
    }

    async createPDFDocument(conversationData) {
        try {
            console.log("Starting PDF creation...");
            console.log("Conversation data:", JSON.stringify(conversationData, null, 2));
            
            // Import PDFKit dynamically
            console.log("Importing PDFKit...");
            const PDFDocument = (await import('pdfkit')).default;
            console.log("PDFKit imported successfully");
            
            const doc = new PDFDocument({ 
                size: 'A4',
                margin: 0,
                layout: 'portrait'
            });
            const chunks = [];
            
            // Collect PDF data
            doc.on('data', chunk => chunks.push(chunk));
            doc.on('end', () => {
                console.log("PDF generation completed");
            });
            
            const pageWidth = doc.page.width;
            const pageHeight = doc.page.height;
            
            // Set up colors to match reference
            const primaryColor = '#000000';
            const grayColor = '#666666';
            const lightGrayColor = '#CCCCCC';
            const headerBgColor = '#F8F8F8';
            
            // Background
            doc.rect(0, 0, pageWidth, pageHeight).fill('#FFFFFF');
            
            // Header section with light gray background
            doc.rect(0, 0, pageWidth, 80).fill(headerBgColor);
            
            // Date and Version in top right (matching reference)
            const currentDate = new Date().toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: '2-digit', 
                year: 'numeric' 
            }).replace(/\//g, '/');
            
            doc.fontSize(9)
               .fillColor(primaryColor)
               .font('Helvetica')
               .text(currentDate, pageWidth - 100, 15)
               .text(`${Math.floor(Date.now()/1000)}-${Math.floor(Math.random()*1000)} (Version 2)`, pageWidth - 150, 30);
            
        // Print247 logo using logo.png image
        try {
            const fs = await import('fs/promises');
            const path = await import('path');
            
            // Get the absolute path to the logo image
            const logoPath = path.join(process.cwd(), 'public', 'logo.png');
            
            // Check if logo exists
            await fs.access(logoPath);
            
            // Add the logo.png image in header
            doc.image(logoPath, 50, 15, {
                width: 120,
                height: 50
            });
            
        } catch (logoError) {
            console.log('Could not load logo.png, falling back to text');
            // Fallback to text if logo fails
            doc.fontSize(28)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('Print247', 50, 25);
            
            doc.fontSize(16)
               .fillColor('#0066CC')
               .font('Helvetica')
               .text('.us', 165, 30);
        }            // Vertical QUOTE text on the left side
            doc.save()
               .translate(25, 150)
               .rotate(-90)
               .fontSize(48)
               .fillColor(lightGrayColor)
               .font('Helvetica-Bold')
               .text('QUOTE', 0, 0)
               .restore();
            
            // Disclaimer section (matching reference layout)
            const disclaimerY = 90;
            const contentStartX = 80;
            
            doc.fontSize(9)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('Disclaimer:', contentStartX, disclaimerY);
            
            const disclaimerText = 'We want to emphasize that our estimate is comprehensive, encompassing all essential operations and materials in line with industry standards. If you have any queries, please don\'t hesitate to reach out. The estimate remains valid for 30 days from the specified date, and pricing adjustments may occur after a final artwork inspection. The countdown for delivery initiation starts upon design file approval and payment receipt. We value your business and eagerly anticipate the opportunity to serve you in the future. Feel free to contact us for any further information or clarification you may need. Any additional tariff, duty, and taxes on goods at the time of arrival, if applicable, shall be paid by the receiver/customer.';
            
            doc.fontSize(8)
               .font('Helvetica')
               .text(disclaimerText, contentStartX, disclaimerY + 15, {
                   width: pageWidth - contentStartX - 50,
                   align: 'justify',
                   lineGap: 2
               });
            
            // Quote details section (matching reference layout)
            const detailsY = disclaimerY + 130;
            
            // Materials processing for display
            let materialText = 'Standard Material';
            if (conversationData.selectedMaterials && Array.isArray(conversationData.selectedMaterials)) {
                materialText = conversationData.selectedMaterials.map(m => m.name).join(', ');
            } else if (conversationData.selectedMaterial?.name) {
                materialText = conversationData.selectedMaterial.name;
            }
            
            // Finishes processing for display
            let finishText = 'Standard Finish';
            if (conversationData.selectedFinishes && Array.isArray(conversationData.selectedFinishes)) {
                finishText = conversationData.selectedFinishes.map(f => f.name).join(', ');
            } else if (conversationData.selectedFinish?.name) {
                finishText = conversationData.selectedFinish.name;
            }
            
            // Quantities processing for display
            let quantityText = '1';
            if (conversationData.quantities && Array.isArray(conversationData.quantities)) {
                quantityText = conversationData.quantities.join(', ');
            } else if (conversationData.quantity) {
                quantityText = conversationData.quantity.toString();
            }
            
            const details = [
                ['Query No:', `QT-${Date.now().toString().slice(-8)}`],
                ['Customer:', 'WhatsApp Customer'],
                ['Job Name:', conversationData.selectedProduct?.name || 'Custom Product'],
                ['Materials:', materialText],
                ['Quantities:', quantityText],
                ['No of SKU\'s:', conversationData.skus?.toString() || '1 (default)'],
                ['Turnaround Time:', '12 - 15 Business Days (*T&C Applies)'],
                ['Shipping:', 'DAP (Delivered At Place)'],
                ['Finished Size:', conversationData.dimensions?.map(d => `${d.value}`).join(' x ') || 'Custom Size'],
                ['Print Specification:', 'CMYK 4/0 + DIE CUTTING + STRAIGHT LINE GLUING'],
                ['Extra Finishes:', finishText],
                ['Representative:', 'AI Assistant - WhatsApp Bot']
            ];
            
            let currentY = detailsY;
            details.forEach(([label, value]) => {
                // Draw horizontal line
                doc.moveTo(contentStartX, currentY)
                   .lineTo(pageWidth - 50, currentY)
                   .stroke('#CCCCCC');
                
                // Label and value
                doc.fontSize(10)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text(label, contentStartX, currentY + 5)
                   .font('Helvetica-Bold')
                   .text(value, contentStartX + 200, currentY + 5);
                
                currentY += 25;
            });
            
            // Final line
            doc.moveTo(contentStartX, currentY)
               .lineTo(pageWidth - 50, currentY)
               .stroke('#CCCCCC');
            
            // Pricing table (matching reference layout)
            const tableY = currentY + 40;
            const tableStartX = contentStartX;
            const tableWidth = pageWidth - contentStartX - 50;
            const colWidth = tableWidth / 4;
            
            if (conversationData.pricingData) {
                console.log("Pricing data found:", conversationData.pricingData);
                const { qty, unit_cost } = conversationData.pricingData;
                
                if (!qty || !unit_cost) {
                    console.error("Invalid pricing data structure:", { qty, unit_cost });
                    throw new Error("Invalid pricing data structure");
                }
                
                // Table border
                doc.rect(tableStartX, tableY - 5, tableWidth, 90)
                   .stroke('#CCCCCC');
                
                // Header background
                doc.rect(tableStartX, tableY - 5, tableWidth, 20)
                   .fillAndStroke('#F0F0F0', '#CCCCCC');
                
                // Table headers with proper alignment
                doc.fontSize(10)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Tier\'s', tableStartX + 5, tableY + 2, { width: colWidth - 10, align: 'left' })
                   .text('Tier 1', tableStartX + colWidth + 5, tableY + 2, { width: colWidth - 10, align: 'center' })
                   .text('Tier 2', tableStartX + colWidth * 2 + 5, tableY + 2, { width: colWidth - 10, align: 'center' })
                   .text('Tier 3', tableStartX + colWidth * 3 + 5, tableY + 2, { width: colWidth - 10, align: 'center' });
                
                // Vertical lines for columns
                for (let i = 1; i < 4; i++) {
                    doc.moveTo(tableStartX + colWidth * i, tableY - 5)
                       .lineTo(tableStartX + colWidth * i, tableY + 85)
                       .stroke('#CCCCCC');
                }
                
                // Quantities row
                doc.fontSize(9)
                   .font('Helvetica-Bold')
                   .text('Quantities:', tableStartX + 5, tableY + 25);
                
                qty.forEach((quantity, index) => {
                    doc.text(quantity.toLocaleString(), tableStartX + colWidth * (index + 1) + 5, tableY + 25, { 
                        width: colWidth - 10, 
                        align: 'center' 
                    });
                });
                
                // Unit Cost row
                const unitCostY = tableY + 40;
                doc.moveTo(tableStartX, unitCostY - 5)
                   .lineTo(tableStartX + tableWidth, unitCostY - 5)
                   .stroke('#CCCCCC');
                
                doc.text('Unit Cost:', tableStartX + 5, unitCostY);
                unit_cost.forEach((cost, index) => {
                    doc.text(`$${cost.toFixed(3)}`, tableStartX + colWidth * (index + 1) + 5, unitCostY, { 
                        width: colWidth - 10, 
                        align: 'center' 
                    });
                });
                
                // Estimate Price row
                const priceY = tableY + 55;
                doc.moveTo(tableStartX, priceY - 5)
                   .lineTo(tableStartX + tableWidth, priceY - 5)
                   .stroke('#CCCCCC');
                
                doc.text('Estimate Price:', tableStartX + 5, priceY);
                qty.forEach((quantity, index) => {
                    const totalPrice = (quantity * unit_cost[index]);
                    doc.text(`$${totalPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, 
                        tableStartX + colWidth * (index + 1) + 5, priceY, { 
                        width: colWidth - 10, 
                        align: 'center' 
                    });
                });
            } else {
                console.log("No pricing data available for PDF");
                // Add a message indicating no pricing data
                doc.fontSize(12)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Pricing information not available', tableStartX, tableY);
            }
            
            // Notes section (matching reference)
            const notesY = tableY + 120;
            doc.fontSize(10)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('Notes:', contentStartX, notesY);
            
            const notesText = `â€¢ Final pricing may vary based on artwork complexity and material specifications
â€¢ This quote is valid for 30 days from the date above
â€¢ Production time starts after artwork approval and payment confirmation
â€¢ Shipping costs are included for DAP delivery within the continental US
â€¢ Custom packaging options available upon request
â€¢ All materials meet industry quality standards`;
            
            doc.fontSize(9)
               .font('Helvetica')
               .text(notesText, contentStartX, notesY + 15, {
                   width: pageWidth - contentStartX - 50,
                   lineGap: 3
               });
            
            // Footer section (matching reference)
            const footerY = pageHeight - 120;
            
            // Use print247usa.png image instead of text
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Get the absolute path to the image
                const imagePath = path.join(process.cwd(), 'public', 'print247usa.png');
                
                // Check if image exists
                await fs.access(imagePath);
                
                // Add the print247usa.png image
                doc.image(imagePath, contentStartX + 25, footerY - 5, {
                    width: 70,
                    height: 70
                });
                
            } catch (imageError) {
                console.log('Could not load print247usa.png, falling back to text');
                // Fallback to circle and text if image fails
                doc.circle(contentStartX + 60, footerY + 20, 35)
                   .stroke(primaryColor)
                   .lineWidth(2);
                
                doc.fontSize(7)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('PROUDLY BASED', contentStartX + 25, footerY + 5, { width: 70, align: 'center' })
                   .text('IN THE USA', contentStartX + 25, footerY + 15, { width: 70, align: 'center' });
                
                doc.fontSize(8)
                   .font('Helvetica-Bold')
                   .fillColor('#0066CC')
                   .text('Print247.us', contentStartX + 25, footerY + 30, { width: 70, align: 'center' });
            }
            
            // Authorization section with proper formatting
            doc.fontSize(10)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('S.M. Authorized By:', contentStartX + 150, footerY)
               .fontSize(9)
               .font('Helvetica')
               .text('_________________________________', contentStartX + 150, footerY + 15);
            
            // Date section
            doc.fontSize(10)
               .font('Helvetica-Bold')
               .text('Date:', pageWidth - 150, footerY)
               .fontSize(9)
               .font('Helvetica')
               .text('_________________________________', pageWidth - 150, footerY + 15)
               .text(new Date().toLocaleDateString('en-US', { 
                   month: '2-digit',
                   day: '2-digit', 
                   year: 'numeric' 
               }), pageWidth - 150, footerY + 30);
            
            // Footer line
            doc.moveTo(contentStartX, footerY + 50)
               .lineTo(pageWidth - 50, footerY + 50)
               .stroke('#CCCCCC');
            
            // Footer text
            doc.fontSize(8)
               .fillColor(grayColor)
               .font('Helvetica')
               .text('This quote is valid for 30 days from the date above. Final pricing subject to artwork review.', 
                     contentStartX, footerY + 60, { 
                         width: pageWidth - contentStartX - 50, 
                         align: 'center' 
                     });
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be ready
            return new Promise((resolve) => {
                doc.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            });
            
        } catch (error) {
            console.error('Error creating PDF document:', error);
            throw error;
        }
    }

    async createTempPDF(pdfBuffer, from, type = 'quote') {
        try {
            // Check if we're in Vercel environment
            if (process.env.VERCEL) {
                // For Vercel, use /tmp directory which is writable
                const fs = await import('fs/promises');
                const path = await import('path');
                const os = await import('os');
                
                // Use system temp directory
                const tempDir = path.join(os.tmpdir(), 'whatsapp-pdfs');
                await fs.mkdir(tempDir, { recursive: true });
                
                // Generate unique filename
                const filename = `${type.toLowerCase()}_${from}_${Date.now()}.pdf`;
                const filepath = path.join(tempDir, filename);
                
                // Save PDF file
                await fs.writeFile(filepath, pdfBuffer);
                
                console.log('PDF saved to Vercel temp:', filepath);
                return filepath;
            } else {
                // For local development, use the existing temp directory
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Create temp directory if it doesn't exist
                const tempDir = path.join(process.cwd(), 'temp', 'pdfs');
                await fs.mkdir(tempDir, { recursive: true });
                
                // Generate unique filename
                const filename = `${type.toLowerCase()}_${from}_${Date.now()}.pdf`;
                const filepath = path.join(tempDir, filename);
                
                // Save PDF file
                await fs.writeFile(filepath, pdfBuffer);
                
                console.log(`${type} saved to local temp:`, filepath);
                return filepath;
            }
            
        } catch (error) {
            console.error('Error creating temp PDF file:', error);
            throw error;
        }
    }

    async generateAndSendQuote(from, conversationData) {
        try {
            // Generate the quote
            const quote = await conversationService.generateQuote(from, conversationData);

            // Format and send the quote
            const quoteMessage = conversationService.formatQuoteMessage(quote);
            await this.whatsappService.sendMessage(from, quoteMessage);

            // Send follow-up options
            const buttons = [
                {
                    type: 'reply',
                    reply: {
                        id: 'new_quote',
                        title: 'New Quote'
                    }
                },
                {
                    type: 'reply',
                    reply: {
                        id: 'contact_us',
                        title: 'Contact Us'
                    }
                }
            ];

            const followUpText = `Thank you for using our quote service! ðŸŽ‰

Would you like to:`;

            await this.whatsappService.sendButtonMessage(from, followUpText, buttons);

            // Mark conversation as completed
            await conversationService.updateConversationState(from, {
                currentStep: 'completed',
                isActive: false,
                completedAt: new Date()
            });

        } catch (error) {
            await mongoLogger.logError(error, { source: 'quote-generation' });
            await this.whatsappService.sendMessage(
                from,
                "I'm sorry, there was an error generating your quote. Please contact our support team for assistance."
            );
        }
    }

    // Helper methods
    isGreeting(message) {
        const greetings = ['hi', 'hello', 'hey', 'greetings', 'good morning', 'good afternoon', 'good evening', 'hi there', 'hello there', 'hey there', 'howdy', 'hiya', 'sup', 'yo'];
        const lowerMessage = message.toLowerCase().trim();
        
        // Check for exact matches first
        if (lowerMessage === 'hi' || lowerMessage === 'hello' || lowerMessage === 'hey') {
            return true;
        }
        
        // Check for simple greetings (not complex messages with product info)
        const isSimpleGreeting = greetings.some(greeting => {
            if (greeting.length <= 3) {
                // For short greetings, require exact word match
                return lowerMessage === greeting;
            } else {
                // For longer greetings, allow partial match but not in the middle of words
                return lowerMessage.includes(greeting);
            }
        });
        
        // If it's a simple greeting, return true
        if (isSimpleGreeting) {
            return true;
        }
        
        // If the message contains product-related keywords, it's not a simple greeting
        const productKeywords = ['looking for', 'need', 'want', 'quote', 'price', 'pouches', 'boxes', 'labels', 'carton', 'quantity', 'size', 'flavors', 'uv', 'foil', 'white', 'inside'];
        const hasProductInfo = productKeywords.some(keyword => lowerMessage.includes(keyword));
        
        // If it has product info, it's not a simple greeting
        if (hasProductInfo) {
            return false;
        }
        
        return false;
    }

    hasProductInformation(message) {
        const lowerMessage = message.toLowerCase().trim();
        
        // Check for product-related keywords that indicate useful information
        const productKeywords = [
            'looking for', 'need', 'want', 'quote', 'price', 'pouches', 'boxes', 'labels', 'carton',
            'quantity', 'size', 'flavors', 'uv', 'foil', 'white', 'inside', 'standup', 'folding',
            'rigid', 'mylor', 'bag', 'label', 'dimensions', 'width', 'height', 'length', 'thickness',
            'material', 'finish', 'coating', 'printing', 'colors', 'design', 'custom', 'specifications'
        ];
        
        const hasProductInfo = productKeywords.some(keyword => lowerMessage.includes(keyword));
        
        // Also check for numbers (quantities, dimensions)
        const hasNumbers = /\d+/.test(message);
        
        // Check for measurement units
        const hasUnits = /(mm|cm|inches?|ft|feet|meters?|kg|g|lb|pounds?|pieces?|units?|pcs|k|thousand)/i.test(message);
        
        return hasProductInfo || (hasNumbers && hasUnits);
    }



    // Helper function to determine if message is likely a material selection
    isLikelyMaterialSelectionMessage(messageText) {
        const text = messageText.toLowerCase().trim();
        
        // Empty string is NOT a material selection - should ask for input
        if (text === '') {
            console.log('ðŸ” Empty string - NOT material selection, should ask for material');
            return false;
        }
        
        // Simple material names (likely material selection)
        if (text.length < 50 && !text.includes('quantity') && !text.includes('size') && !text.includes('design')) {
            console.log('ðŸ” Short message without quantity/size/design keywords - likely material selection');
            return true;
        }
        
        // Numeric selection (like "1", "2", "3" for material list)
        if (/^\d+$/.test(text)) {
            console.log('ðŸ” Numeric selection detected - likely material selection');
            return true;
        }
        
        // Contains material-specific keywords without other context
        const materialKeywords = ['pet', 'pe', 'kraft', 'alu', 'mpet', 'metallized', 'holographic', 'foil'];
        const hasOtherContext = text.includes('quantity') || text.includes('size') || text.includes('dimension') || 
                               text.includes('finish') || text.includes('design') || text.includes('pouch') ||
                               text.includes('bag') || text.includes('roll');
        
        if (materialKeywords.some(keyword => text.includes(keyword)) && !hasOtherContext) {
            console.log('ðŸ” Material keyword found without other context - likely material selection');
            return true;
        }
        
        // Complex messages with multiple specifications are NOT material selections
        console.log('ðŸ” Complex message with multiple specifications - NOT material selection');
        return false;
    }

    isDimensionMessage(message) {
        const trimmedMessage = message.trim();
        
        // Check for common dimension patterns (both 2D and 3D)
        const dimensionPatterns = [
            /^\d+x\d+$/,               // 6x6 (2D)
            /^\d+x\d+x\d+$/,           // 5x5x5 (3D)
            /^\d+,\d+$/,               // 6,6 (2D)
            /^\d+,\d+,\d+$/,           // 5,5,5 (3D)
            /^\d+\s+\d+$/,             // 6 6 (2D)
            /^\d+\s+\d+\s+\d+$/,       // 5 5 5 (3D)
            /^\d+\.\d+x\d+\.\d+$/,     // 6.5x6.5 (2D with decimals)
            /^\d+\.\d+x\d+\.\d+x\d+\.\d+$/, // 5.5x5.5x5.5 (3D with decimals)
            /^\d+\.\d+,\d+\.\d+$/,     // 6.5,6.5 (2D with decimals)
            /^\d+\.\d+,\d+\.\d+,\d+\.\d+$/, // 5.5,5.5,5.5 (3D with decimals)
            /^[a-zA-Z]:\d+[x,]\d+$/i,  // W:6x6 or W:6,6 (2D with label)
            /^[a-zA-Z]:\d+[x,]\d+[x,]\d+$/i, // L:5x5x5 or L:5,5,5 (3D with label)
        ];
        
        return dimensionPatterns.some(pattern => pattern.test(trimmedMessage));
    }

    async parseDimensionsManually(dimensionString, dimensionNames) {
        try {
            const values = [];
            const dimensionStringLower = dimensionString.toLowerCase().trim();

            // Handle format: "5x7x3" or "5,7,3" or "5 7 3"
            let numbers = [];

            if (dimensionStringLower.includes('x')) {
                numbers = dimensionStringLower.split('x').map(v => parseFloat(v.trim()));
            } else if (dimensionStringLower.includes(',')) {
                numbers = dimensionStringLower.split(',').map(v => parseFloat(v.trim()));
            } else {
                // Extract all numbers from the string
                const matches = dimensionStringLower.match(/\d+(?:\.\d+)?/g);
                if (matches) {
                    numbers = matches.map(n => parseFloat(n));
                }
            }

            // Map values to dimension names
            const result = [];
            for (let i = 0; i < dimensionNames.length && i < numbers.length; i++) {
                if (!isNaN(numbers[i]) && numbers[i] > 0) {
                    result.push({
                        name: dimensionNames[i],
                        value: numbers[i]
                    });
                }
            }

            return result.length === dimensionNames.length ? result : [];
        } catch (error) {
            await mongoLogger.logError(error, { source: 'dimension-parsing' });
            return [];
        }
    }

    async handleImageMessage(message, from) {
        await mongoLogger.info('Received image message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for sharing the image! ðŸ“¸ Our team will review it and get back to you."
        );
    }

    async handleDocumentMessage(message, from) {
        await mongoLogger.info('Received document message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for the document! ðŸ“„ We've received it and will review it shortly."
        );
    }

    /**
     * Validate that all required data is present for quote generation
     */
    validateQuoteData(conversationData) {
        const missingFields = [];
        let isValid = true;

        // Check for selected category
        if (!conversationData.selectedCategory || !conversationData.selectedCategory.id) {
            missingFields.push("â€¢ Product category selection");
            isValid = false;
        }

        // Check for selected product
        if (!conversationData.selectedProduct || !conversationData.selectedProduct.id) {
            missingFields.push("â€¢ Product selection");
            isValid = false;
        }

        // Check for selected material
        if (!conversationData.selectedMaterial || conversationData.selectedMaterial.length === 0) {
            missingFields.push("â€¢ Material selection");
            isValid = false;
        }

        // Check for selected finishes
        if (!conversationData.selectedFinish || conversationData.selectedFinish.length === 0) {
            missingFields.push("â€¢ Finish selection");
            isValid = false;
        }

        // Check for dimensions - must have ALL required dimensions
        if (!conversationData.dimensions || conversationData.dimensions.length === 0) {
            missingFields.push("â€¢ Product dimensions");
            isValid = false;
        } else if (conversationData.selectedProduct && conversationData.selectedProduct.dimensionFields) {
            // Check if all required dimensions are provided
            const requiredDimensions = conversationData.selectedProduct.dimensionFields.filter(field => field.isRequired);
            const providedDimensions = conversationData.dimensions || [];
            
            const missingDimensions = requiredDimensions.filter(reqDim => 
                !providedDimensions.some(provDim => provDim.name === reqDim.name)
            );
            
            if (missingDimensions.length > 0) {
                const missingDimNames = missingDimensions.map(d => d.name).join(', ');
                missingFields.push(`â€¢ Missing required dimensions: ${missingDimNames}`);
                isValid = false;
                
                console.log('ðŸ” validateQuoteData - Missing dimensions:', {
                    productName: conversationData.selectedProduct.name,
                    requiredDimensions: requiredDimensions.length,
                    providedDimensions: providedDimensions.length,
                    missingDimensions: missingDimNames
                });
            }
        }

        // Check for quantity
        if (!conversationData.quantity || conversationData.quantity.length === 0) {
            missingFields.push("â€¢ Quantity specification");
            isValid = false;
        }

        return {
            isValid,
            missingFields
        };
    }

    /**
     * Determine which step to reset to based on missing data
     */
    getResetStepForMissingData(missingFields, conversationData) {
        // Priority order: category -> product -> dimensions -> material -> finish -> quantity
        if (missingFields.some(field => field.includes("category"))) {
            return 'category_selection';
        }
        if (missingFields.some(field => field.includes("product"))) {
            return 'product_selection';
        }
        if (missingFields.some(field => field.includes("dimensions"))) {
            return 'dimension_input';
        }
        if (missingFields.some(field => field.includes("material"))) {
            return 'material_selection';
        }
        if (missingFields.some(field => field.includes("finish"))) {
            return 'finish_selection';
        }
        if (missingFields.some(field => field.includes("quantity"))) {
            return 'quantity_input';
        }

        // Default fallback
        return 'start';
    }

    async handleAudioMessage(message, from) {
        try {
            await mongoLogger.info('Received audio message', { 
                from, 
                audioId: message.audio?.id,
                mimeType: message.audio?.mime_type,
                duration: message.audio?.duration 
            });

            // Check if voice processing is available
            if (!voiceProcessingService.isAvailable()) {
                console.log('âš ï¸ Voice processing not available - OpenAI API key not configured');
                
                await this.whatsappService.sendMessage(
                    from,
                    "ðŸŽµ I received your voice message, but voice-to-text processing is currently not available. Please send your message as text instead. ðŸ“"
                );
                return;
            }

            // Send immediate acknowledgment
            await this.whatsappService.sendMessage(
                from,
                "ðŸŽµ Got your voice message! Converting it to text... Please wait a moment."
            );

            // Process the voice message
            console.log('ðŸŽ™ï¸ Processing voice message:', message.audio);
            
            const voiceResult = await voiceProcessingService.processVoiceMessage(
                message.audio, 
                process.env.WHATSAPP_ACCESS_TOKEN
            );

            if (!voiceResult.success) {
                console.error('âŒ Voice processing failed:', voiceResult.error);
                
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, I couldn't understand your voice message. Could you please type your message instead? ðŸ“\n\nOr try sending the voice message again - make sure you're in a quiet environment."
                );
                return;
            }

            const transcribedText = voiceResult.text;
            console.log('âœ… Voice transcribed:', transcribedText);

            // Send transcription confirmation to user
            await this.whatsappService.sendMessage(
                from,
                `ðŸŽ¯ I heard: "${transcribedText}"\n\nProcessing your request...`
            );

            // Create a text message object with the transcribed text
            const textMessage = {
                id: message.id + '-voice-to-text',
                from: from,
                timestamp: message.timestamp,
                type: 'text',
                text: {
                    body: transcribedText
                },
                original_type: 'audio', // Track that this came from voice
                voice_metadata: {
                    duration: voiceResult.duration,
                    language: voiceResult.language,
                    original_audio_id: message.audio?.id
                }
            };

            // Process the transcribed text as a regular text message
            await this.handleTextMessage(textMessage, from);

            // Log successful voice processing
            await mongoLogger.info('Voice message processed successfully', {
                from,
                originalAudioId: message.audio?.id,
                transcribedText: transcribedText,
                textMessageId: textMessage.id,
                duration: voiceResult.duration,
                language: voiceResult.language
            });

        } catch (error) {
            console.error('âŒ Error handling audio message:', error);
            await mongoLogger.logError(error, {
                source: 'audio-message-handler',
                from: from,
                audioMessage: message.audio
            });

            try {
                // Send fallback message directly without tracking
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, I had trouble processing your voice message. Please try typing your message instead. ðŸ“"
                );
            } catch (sendError) {
                console.error('Error sending audio error message:', sendError);
            }
        }
    }

    async handleVideoMessage(message, from) {
        await mongoLogger.info('Received video message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for the video! ðŸŽ¥ We've received it and will review it shortly."
        );
    }

    async handleInteractiveMessage(message, from) {
        await mongoLogger.info('Received interactive message', { from });

        if (message.interactive.type === 'button_reply') {
            const buttonId = message.interactive.button_reply.id;
            const buttonTitle = message.interactive.button_reply.title;
            await mongoLogger.info('Button clicked', { buttonId, buttonTitle, from });

            // Get current conversation state
            const conversationState = await conversationService.getConversationState(from);

            // Handle button responses
            if (buttonId === 'quote_yes') {
                await conversationService.updateConversationState(from, {
                    currentStep: 'product_selection',
                    'conversationData.wantsQuote': true
                });
                await this.sendProductSelection(from);
            } else if (buttonId === 'quote_no') {
                await this.whatsappService.sendMessage(
                    from,
                    "No problem! If you change your mind or have any questions about our mylar bags, feel free to reach out anytime. Have a great day! ðŸ˜Š"
                );
                await conversationService.updateConversationState(from, {
                    currentStep: 'completed',
                    isActive: false,
                    completedAt: new Date()
                });
            } else if (buttonId === 'new_quote') {
                await conversationService.resetConversation(from);
                await this.sendGreetingWithQuoteOption(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'greeting_response'
                });
            } else if (buttonId === 'contact_us') {
                await this.handleContactInfo(from);
            } else {
                await this.whatsappService.sendMessage(
                    from,
                    `You selected: ${buttonTitle}. Thank you for your choice!`
                );
            }
        } else if (message.interactive.type === 'list_reply') {
            const listId = message.interactive.list_reply.id;
            const listTitle = message.interactive.list_reply.title;
            await mongoLogger.info('List item selected', { listId, listTitle, from });

            // Get current conversation state before processing
            const conversationState = await conversationService.getConversationState(from);
            console.log('ðŸ” Current conversation state before list reply:', {
                currentStep: conversationState.currentStep,
                hasSelectedCategory: !!conversationState.conversationData?.selectedCategory,
                selectedCategory: conversationState.conversationData?.selectedCategory,
                conversationData: Object.keys(conversationState.conversationData || {})
            });

            console.log('ðŸ“‹ Processing list reply:', {
                listId,
                listTitle,
                currentStep: conversationState.currentStep,
                messageText: listId,
                isNumeric: !isNaN(parseInt(listId)),
                parsedId: parseInt(listId)
            });

            // Smart routing: Determine what type of selection this is based on the listId
            const routingResult = await this.determineListReplyRouting(listId, listTitle, conversationState);
            console.log('ðŸŽ¯ List reply routing result:', routingResult);

            if (routingResult.shouldOverrideStep) {
                console.log('ðŸ”„ Overriding step from', conversationState.currentStep, 'to', routingResult.correctStep);
                // Override the current step and process with the correct handler
                await conversationService.updateConversationState(from, {
                    currentStep: routingResult.correctStep
                });

                // Get updated state
                const updatedState = await conversationService.getConversationState(from);
                console.log('ðŸ”„ Updated state after step override:', {
                    currentStep: updatedState.currentStep,
                    selectedCategory: updatedState.conversationData?.selectedCategory,
                    hasCategory: !!updatedState.conversationData?.selectedCategory?.id
                });

                // Process with the correct step
                await this.processConversationFlow(message, listId, from, updatedState);
            } else {
                console.log('âž¡ï¸ Processing with current step:', conversationState.currentStep);
                // Process normally with current step
            await this.processConversationFlow(message, listId, from, conversationState);
            }
        }
    }

    // Helper methods for contact info
    async handleContactInfo(from) {
        const contactMessage = `ðŸ“ž *Contact Information*

ðŸ¢ *Business Hours:*
Monday - Friday: 9:00 AM - 6:00 PM
Saturday: 9:00 AM - 2:00 PM
Sunday: Closed

ðŸ“± *Phone:* [YOUR_PHONE_NUMBER]
ðŸ“§ *Email:* [YOUR_EMAIL]
ðŸŒ *Website:* [YOUR_WEBSITE]
ðŸ“ *Address:* [YOUR_ADDRESS]

Feel free to reach out anytime!`;

        await this.whatsappService.sendMessage(from, contactMessage);
    }

    /**
     * Determine the correct routing for a list reply based on its content and current state
     */
    async determineListReplyRouting(listId, listTitle, conversationState) {
        const currentStep = conversationState.currentStep;
        const conversationData = conversationState.conversationData || {};

        console.log('ðŸ” Determining list reply routing:', {
            listId,
            listTitle,
            currentStep,
            hasCategory: !!conversationData.selectedCategory?.id,
            hasProduct: !!conversationData.selectedProduct?.id
        });

        // If listId is numeric, it could be a category ERP ID
        if (!isNaN(parseInt(listId))) {
            const numericId = parseInt(listId);

            // Check if this matches a category ERP ID
            try {
                const categories = await conversationService.getProductCategories();
                const matchingCategory = categories.find(cat => cat.erp_id === numericId);

                if (matchingCategory) {
                    console.log('âœ… List reply matches category:', matchingCategory.name);

                    // If we're not in category selection and don't have a category, this should be treated as category selection
                    if (currentStep !== 'category_selection' && !conversationData.selectedCategory?.id) {
                        return {
                            shouldOverrideStep: true,
                            correctStep: 'category_selection',
                            reason: 'List reply matches category but current step is not category_selection'
                        };
                    }

                    // If we already have a category but this is a different one, treat it as category selection
                    if (conversationData.selectedCategory?.erp_id && conversationData.selectedCategory.erp_id !== numericId) {
                        return {
                            shouldOverrideStep: true,
                            correctStep: 'category_selection',
                            reason: 'List reply matches different category than currently selected'
                        };
                    }
                }
            } catch (error) {
                console.log('Error checking categories:', error.message);
            }
        }

        // Check if listId could be a product name or ID
        if (conversationData.selectedCategory?.id) {
            try {
                const products = await conversationService.getProductsByCategory(conversationData.selectedCategory.id);
                const matchingProduct = products.find(prod =>
                    prod.erp_id.toString() === listId ||
                    prod.name.toLowerCase().includes(listTitle.toLowerCase())
                );

                if (matchingProduct) {
                    console.log('âœ… List reply matches product:', matchingProduct.name);

                    // If we're not in product selection and don't have a product, this should be treated as product selection
                    if (currentStep !== 'product_selection' && !conversationData.selectedProduct?.id) {
                        return {
                            shouldOverrideStep: true,
                            correctStep: 'product_selection',
                            reason: 'List reply matches product but current step is not product_selection'
                        };
                    }
                }
            } catch (error) {
                console.log('Error checking products:', error.message);
            }
        }

        // Check for corrupted state: user in dimension_input but no category/product selected
        if (currentStep === 'dimension_input' && !conversationData.selectedCategory?.id && !conversationData.selectedProduct?.id) {
            console.log('ðŸš¨ Corrupted state detected: in dimension_input but no category/product selected');

            // Try to determine if this is actually a category selection
            if (!isNaN(parseInt(listId))) {
                return {
                    shouldOverrideStep: true,
                    correctStep: 'category_selection',
                    reason: 'Corrupted state: user in dimension_input with no selections, treating as category selection'
                };
            }
        }

        // Check for other corrupted states
        if (currentStep === 'material_selection' && !conversationData.selectedProduct?.id) {
            console.log('ðŸš¨ Corrupted state detected: in material_selection but no product selected');
            return {
                shouldOverrideStep: true,
                correctStep: 'product_selection',
                reason: 'Corrupted state: user in material_selection with no product selected'
            };
        }

        if (currentStep === 'finish_selection' && !conversationData.selectedProduct?.id) {
            console.log('ðŸš¨ Corrupted state detected: in finish_selection but no product selected');
            return {
                shouldOverrideStep: true,
                correctStep: 'product_selection',
                reason: 'Corrupted state: user in finish_selection with no product selected'
            };
        }

        if (currentStep === 'quantity_input' && !conversationData.selectedFinish?.length) {
            console.log('ðŸš¨ Corrupted state detected: in quantity_input but no finishes selected');
            return {
                shouldOverrideStep: true,
                correctStep: 'finish_selection',
                reason: 'Corrupted state: user in quantity_input with no finishes selected'
            };
        }

        // Default: don't override, process with current step
        return {
            shouldOverrideStep: false,
            correctStep: currentStep,
            reason: 'No override needed, processing with current step'
        };
    }
}

export default MessageHandler;
