import dotenv from 'dotenv';
import conversationService from '../services/conversationService.js';
import WitService from '../services/witService.js';
import mongoLogger from '../services/mongoLogger.js';
import messageStatusService from '../services/messageStatusService.js';
import { Product, ProductCategory } from '../models/productModel.js';
import { Material } from '../models/materialModel.js';
import { ProductFinish } from '../models/finishModel.js';
import { ProcessedMessage } from '../models/processedMessageModel.js';


dotenv.config();

class MessageHandler {
    constructor(whatsappService, aiService) {
        this.whatsappService = whatsappService;
        this.aiService = aiService; // ChatGPT or Wit service
        this.witService = new WitService(); // Keep for backward compatibility
        // Remove old responseTracker - now using MessageStatusService
        
        // Create a wrapper for whatsappService.sendMessage to track all messages
        this.originalSendMessage = this.whatsappService.sendMessage.bind(this.whatsappService);
        this.whatsappService.sendMessage = this.trackedSendMessage.bind(this);
    }

    // Wrapper method to track all message sending attempts
    async trackedSendMessage(to, message, type = 'text') {
        console.log(`üö® DIRECT MESSAGE SEND DETECTED: ${to} - ${message.substring(0, 50)}...`);
        // console.trace('Call stack for direct message send:');
        
        // Try to find messageId from the call stack or context
        // This is a fallback for direct calls that bypass sendMessageOnce
        const result = await this.originalSendMessage(to, message, type);
        
        // Log this as a potential duplicate
        await mongoLogger.warn('Direct message send detected (bypassed sendMessageOnce)', {
            to,
            message: message.substring(0, 100),
            type,
            source: 'direct-whatsapp-service-call'
        });
        
        return result;
    }

    // Check if we've already responded to a message using MessageStatusService
    async hasResponded(messageId) {
        return await messageStatusService.hasResponseBeenSent(messageId);
    }

    // Mark that we've responded to a message using MessageStatusService
    async markAsResponded(messageId, responseMessageId = null, responseType = 'text') {
        await messageStatusService.markResponseAsSent(messageId, responseMessageId, responseType);
    }

    // Send message only if we haven't already responded using MessageStatusService
    async sendMessageOnce(messageId, to, message, type = 'text') {
        try {
            // Check if we can send response
            const canSend = await messageStatusService.canSendResponse(messageId);

            if (!canSend) {
                console.log(`‚è≠Ô∏è Already responded to message ${messageId}, skipping duplicate response`);
                await mongoLogger.warn('Duplicate response prevented', {
                    messageId,
                    to,
                    message: message.substring(0, 100) + '...',
                    source: 'sendMessageOnce'
                });
                return null;
            }

            // Check if this is an auto-generated message ID (skip status tracking for these)
            const isAutoGenerated = messageId.includes('auto-generated-') || 
                                   messageId.includes('error-response-') || 
                                   messageId.includes('error-flow-') ||
                                   messageId.includes('quote-response-') ||
                                   messageId.includes('material-selection-') ||
                                   messageId.includes('material-found-') ||
                                   messageId.includes('material-bypass-') ||
                                   messageId.includes('dimension-selection-') ||
                                   messageId.includes('finish-selection-');

            // Mark response as sending (only for real message IDs)
            if (!isAutoGenerated) {
                await messageStatusService.markResponseAsSending(messageId);
            }

            console.log(`üì§ Sending response for message ${messageId}${isAutoGenerated ? ' (auto-generated)' : ''}`);

            try {
                // Send the message
                const result = await this.whatsappService.sendMessage(to, message, type);

                // Mark response as sent (only for real message IDs)
                if (!isAutoGenerated) {
                    const responseMessageId = result?.messages?.[0]?.id || null;
                    await messageStatusService.markResponseAsSent(messageId, responseMessageId, type);
                }

                return result;

            } catch (sendError) {
                // Mark response as failed (only for real message IDs)
                if (!isAutoGenerated) {
                    await messageStatusService.markResponseAsFailed(messageId, sendError.message);
                }
                throw sendError;
            }

        } catch (error) {
            console.error(`‚ùå Error in sendMessageOnce for message ${messageId}:`, error);
            await mongoLogger.logError(error, {
                source: 'sendMessageOnce',
                messageId,
                to,
                error: error.message
            });
            throw error;
        }
    }

    // Helper method for sending messages when we don't have a messageId (fallback)
    async sendMessageFallback(to, message, type = 'text') {
        try {
            console.log(`üì§ Sending fallback message to ${to}`);
            const result = await this.whatsappService.sendMessage(to, message, type);
            return result;
        } catch (error) {
            console.error(`‚ùå Error in sendMessageFallback:`, error);
            throw error;
        }
    }

    async handleIncomingMessage(message, value = null) {
        const messageId = message.id;
        const from = message.from;
        const messageType = message.type;

        try {
            // Check for empty text messages early
            if (messageType === 'text' && (!message.text?.body || message.text.body.trim() === '')) {
                console.log(`‚è≠Ô∏è Empty text message received from ${from}, skipping processing`);
                await mongoLogger.info('Empty text message received, skipping processing', { 
                    messageType, 
                    from, 
                    messageId,
                    messageText: message.text?.body || 'empty'
                });
                return;
            }

            await mongoLogger.logMessage(message, from);
            await mongoLogger.info('Message received', { messageType, from, messageId });

            // Check if conversation is already completed before processing
            const conversationState = await conversationService.getConversationState(from);
            if (conversationState.conversationData?.completed || conversationState.currentStep === 'completed') {
                console.log(`‚è≠Ô∏è Conversation already completed for ${from}, skipping message processing`);
                return;
            }

            // Initialize message status tracking
            await messageStatusService.initializeMessageStatus(
                messageId,
                from,
                messageType,
                message, // webhookData
                null // conversationId - can be set later if needed
            );

            // Check if message can be processed
            const canProcess = await messageStatusService.canProcessMessage(messageId);
            if (!canProcess) {
                console.log(`‚è≠Ô∏è Message ${messageId} already processed, skipping`);
                await mongoLogger.info('Message already processed, skipping', { messageId, from });
                return;
            }

            // Mark message as processing
            await messageStatusService.markAsProcessing(messageId);

            // Mark message as read
            // await this.whatsappService.markAsRead(messageId);

            await mongoLogger.info('Processing message type', { messageType });

            try {
                // Fix for webhook data sending wrong message type
                const actualMessageType = messageType === 'hi' ? 'text' : messageType;
                
                if (messageType !== actualMessageType) {
                    console.log(`üîß Message type correction: ${messageType} ‚Üí ${actualMessageType}`);
                }
                
                switch (actualMessageType) {
                    case 'text':
                        await this.handleTextMessage(message, from);
                        break;
                    case 'image':
                        await this.handleImageMessage(message, from);
                        break;
                    case 'document':
                        await this.handleDocumentMessage(message, from);
                        break;
                    case 'audio':
                        await this.handleAudioMessage(message, from);
                        break;
                    case 'video':
                        await this.handleVideoMessage(message, from);
                        break;
                    case 'interactive':
                        await this.handleInteractiveMessage(message, from);
                        break;
                    default:
                        await mongoLogger.warn('Unsupported message type', { messageType });
                        await this.sendMessageOnce(
                            messageId,
                            from,
                            "Sorry, I don't support this type of message yet.",
                            'text'
                        );
                }

                // Mark message as processed successfully
                await messageStatusService.markAsProcessed(messageId);

            } catch (processingError) {
                // Mark message processing as failed
                await messageStatusService.markAsFailed(messageId, processingError.message);
                throw processingError;
            }

        } catch (error) {
            await mongoLogger.logError(error, {
                source: 'message-handler',
                messageId,
                from,
                messageType
            });

            // Try to send error message if we haven't already responded
            try {
                const hasResponded = await this.hasResponded(messageId);
                if (!hasResponded) {
                    // Provide more specific error messages based on error type
                    let errorMessage = "Sorry, I encountered an error processing your message. Please try again.";
                    
                    if (error.message && error.message.includes('timeout')) {
                        errorMessage = "The system is taking longer than expected. Please try again in a moment.";
                    } else if (error.message && error.message.includes('network')) {
                        errorMessage = "There seems to be a connection issue. Please check your internet and try again.";
                    } else if (error.message && error.message.includes('database')) {
                        errorMessage = "I'm having trouble accessing my data right now. Please try again shortly.";
                    }
                    
                    // Add restart option
                    errorMessage += "\n\nüí° You can also type 'hi' to restart our conversation anytime.";
                    
                    await this.sendMessageOnce(
                        messageId,
                        from,
                        errorMessage,
                        'text'
                    );
                }
            } catch (sendError) {
                console.error('Error sending error message:', sendError);
            }
        }
    }

    async handleTextMessage(message, from) {
        let messageText = 'unknown';
        try {
            messageText = message.text.body;

            // Check if message is empty, null, or undefined
            if (!messageText || messageText.trim() === '') {
                console.log(`‚è≠Ô∏è Empty message received from ${from}, skipping processing`);
                await mongoLogger.info('Empty message received, skipping processing', { 
                    from, 
                    messageId: message.id,
                    messageText: messageText || 'empty'
                });
                return;
            }

            // Check if conversation is already completed - handle restart scenarios
            let conversationState = await conversationService.getConversationState(from);
            if (conversationState.conversationData?.completed || conversationState.currentStep === 'completed') {
                console.log(`üìù Conversation completed for ${from}, checking for restart/new quote requests`);
                
                // Handle simple restart/greeting messages for completed conversations
                if (this.isSimpleRestartMessage(messageText)) {
                    await this.handleCompletedConversationRestart(messageText, from, message.id);
                    return;
                }
                
                console.log(`‚è≠Ô∏è Conversation already completed and no restart detected, skipping processing`);
                return;
            }

            // Check for simple keyword messages that don't need ChatGPT processing
            if (this.isSimpleKeywordMessage(messageText, conversationState.currentStep)) {
                await this.handleSimpleKeywordMessage(messageText, from, message.id, conversationState);
                return;
            }

            // Process message with ChatGPT FIRST to extract entities before making decisions
            let aiResponse = null;
            let aiEntities = {};
            
            try {
                console.log("ü§ñ Processing message with ChatGPT:", messageText);
                
                // Prepare context for ChatGPT - include available materials if we have a category
                const context = {};
                if (conversationState.conversationData?.selectedCategory?.id) {
                    try {
                        // Get available materials for the selected category
                        const Material = (await import('../models/materialModel.js')).Material;
                        const availableMaterials = await Material.find({ 
                            categoryId: conversationState.conversationData.selectedCategory.id,
                            isActive: true 
                        }).sort({ sortOrder: 1, name: 1 });
                        
                        context.availableMaterials = availableMaterials;
                        context.categoryId = conversationState.conversationData.selectedCategory.id;
                        console.log(`üß± Found ${availableMaterials.length} materials for category: ${conversationState.conversationData.selectedCategory.name}`);
                    } catch (materialError) {
                        console.error("‚ùå Error fetching materials for context:", materialError);
                    }
                }
                
                aiResponse = await this.aiService.processMessage(messageText, context);
                
                // Log the complete ChatGPT response
                console.log("üìä Complete ChatGPT Response:", JSON.stringify(aiResponse, null, 2));
                
                aiEntities = aiResponse?.data?.entities || {};
                
            } catch (aiError) {
                console.error("‚ùå ChatGPT processing failed:", aiError);
                await mongoLogger.error('ChatGPT processing failed', { 
                    messageText, 
                    from,
                    error: aiError.message,
                    stack: aiError.stack,
                    step: 'AI_ERROR'
                });
                
                // Continue without ChatGPT - use empty entities
                aiResponse = { data: { entities: {} } };
                aiEntities = {};
            }

            // Check if user wants to start a new quote OR is greeting (regardless of current step)
            const newQuoteKeywords = ['new quote', 'new', 'start over', 'restart', 'reset', 'begin again', 'fresh quote', 'another quote', 'new order'];
            const wantsNewQuote = newQuoteKeywords.some(keyword => 
                messageText.toLowerCase().includes(keyword.toLowerCase())
            );

            // Check if this is a greeting message
            const isGreetingMessage = this.isGreeting(messageText);
            
            // Check if message contains useful product information
            const hasProductInfo = this.hasProductInformation(messageText);
            
            console.log('üîç Message analysis:', {
                message: messageText,
                wantsNewQuote: wantsNewQuote,
                isGreetingMessage: isGreetingMessage,
                hasProductInfo: hasProductInfo,
                hasEntities: Object.keys(aiEntities).length > 0
            });

            // Only reset conversation for simple greetings or explicit new quote requests
            // Don't reset if we're already in an active conversation step expecting a response
            const activeSteps = ['quote_generation', 'greeting_response', 'material_selection', 'finish_selection', 'quantity_input', 'dimension_input'];
            const isInActiveStep = activeSteps.includes(conversationState.currentStep);
            
            // Don't reset for complex messages with product information or detected entities
            // Don't reset if we're in an active conversation step expecting a response
            if (!isInActiveStep && (wantsNewQuote || (isGreetingMessage && !hasProductInfo && Object.keys(aiEntities).length === 0))) {
                console.log("User wants new quote or is simple greeting, resetting conversation");
                
                // Reset conversation to start fresh
                await conversationService.resetConversation(from);
                
                // Send greeting response for new conversation
                await this.handleGreetingResponse(messageText, from, message.id);
                return;
            }
            
            // If it's a complex message with product info OR entities detected, process it with entity extraction
            if (hasProductInfo || Object.keys(aiEntities).length > 0) {
                console.log("Complex message with product information or entities detected, processing with entity extraction");
                
                // For greeting messages with entities, reset conversation but extract entities first
                if (isGreetingMessage) {
                    console.log("Greeting with entities detected, resetting and extracting data");
                    await conversationService.resetConversation(from);
                    
                    // Get fresh conversation state after reset
                    conversationState = await conversationService.getConversationState(from);
                }
            }

            // Extract and update conversation data with entities
            // Skip entity extraction for quote_generation, material_selection, and finish_selection to prevent unwanted overrides
            // Allow entity extraction for greeting_response when it contains product info
            let updatedConversationData = conversationState.conversationData || {};
            const shouldExtractEntities = conversationState.currentStep !== 'quote_generation' && 
                                        conversationState.currentStep !== 'material_selection' &&
                                        conversationState.currentStep !== 'finish_selection' &&
                                        !(conversationState.currentStep === 'greeting_response' && 
                                          (messageText.toLowerCase().includes('yes') || messageText.toLowerCase().includes('no')));
                                          
            if (shouldExtractEntities) {
                updatedConversationData = await this.extractAndUpdateConversationData(
                aiResponse.data.entities,
                    conversationState.conversationData || {},
                    messageText
            );
                console.log("üéØ Entity extraction performed for step:", conversationState.currentStep, "message:", messageText);
            } else {
                console.log("üéØ Skipping entity extraction for response step:", conversationState.currentStep, "message:", messageText);
            }


            // Special case: If this is the first message and we have selectedCategory, bypass greeting
            if (conversationState.currentStep === 'start' && updatedConversationData.selectedCategory) {
                // console.log("Bypassing greeting - user provided product info in first message");
                updatedConversationData.wantsQuote = true;
            }

            // Check if we can bypass steps based on extracted data
            console.log('üîç determineNextStep input:', {
                currentStep: conversationState.currentStep,
                wantsQuote: updatedConversationData.wantsQuote,
                hasSelectedCategory: !!updatedConversationData.selectedCategory?.id,
                selectedCategory: updatedConversationData.selectedCategory
            });
            const nextStep = await this.determineNextStep(
                conversationState.currentStep,
                updatedConversationData,
                aiResponse.data.entities
            );
            console.log('üéØ determineNextStep result:', nextStep);
            // Update conversation state with extracted data
            if (Object.keys(updatedConversationData).length > 0) {
                // console.log("üíæ Updating conversation state with data:", {
                //     hasSkus: !!updatedConversationData.skus,
                //     skusData: updatedConversationData.skus,
                //     dataKeys: Object.keys(updatedConversationData)
                // });
                
                const _sss = await conversationService.updateConversationState(from, {
                    conversationData: updatedConversationData,
                    currentStep: nextStep
                });
                
                // console.log("‚úÖ Conversation state updated successfully");
                
                // Get the updated conversation state for processing
                conversationState = await conversationService.getConversationState(from);
                // console.log("üîÑ Retrieved updated conversation state:", {
                //     hasSkus: !!conversationState.conversationData?.skus,
                //     skusData: conversationState.conversationData?.skus,
                //     currentStep: conversationState.currentStep
                // });
            }
            // Process message through our conversation flow
            
            await this.processConversationFlow(message, messageText, from, conversationState, false);

        } catch (error) {
            console.error('Error in handleTextMessage:', error);
            await mongoLogger.logError(error, {
                source: 'text-message-handler',
                from: from,
                messageText: messageText || 'unknown'
            });

            try {
                // Provide more specific error messages based on error type
                let errorMessage = "Sorry, I encountered an error processing your message. Please try again.";
                
                if (error.message && error.message.includes('timeout')) {
                    errorMessage = "The system is taking longer than expected. Please try again in a moment.";
                } else if (error.message && error.message.includes('network')) {
                    errorMessage = "There seems to be a connection issue. Please check your internet and try again.";
                } else if (error.message && error.message.includes('database')) {
                    errorMessage = "I'm having trouble accessing my data right now. Please try again shortly.";
                }
                
                // Add restart option
                errorMessage += "\n\nüí° You can also type 'hi' to restart our conversation anytime.";
                
                await this.sendMessageOnce(
                    message.id,
                    from,
                    errorMessage
                );
            } catch (sendError) {
                console.error('Error sending error message to user:', sendError);
                await mongoLogger.logError(sendError, {
                    source: 'error-message-sender',
                    from: from
                });
            }
        }
    }

    /**
     * Parse dimension values from string with various separators
     */
    parseDimensionValues(dimensionString) {
        try {
            if (!dimensionString || typeof dimensionString !== 'string') {
                return [];
            }

            // Check if this looks like a dimension string (has dimension indicators)
            const dimensionIndicators = [
                'x', '√ó', '*', 'inch', 'cm', 'mm', 'size:', 'dimension', 
                'width', 'height', 'depth', 'diameter', 'w:', 'h:', 'd:', 'dia:'
            ];
            
            const lowerStr = dimensionString.toLowerCase();
            const hasDimensionIndicator = dimensionIndicators.some(indicator => 
                lowerStr.includes(indicator)
            );
            
            // If no dimension indicators, don't parse as dimensions
            if (!hasDimensionIndicator) {
                console.log(`No dimension indicators found in "${dimensionString}", skipping dimension parsing`);
                return [];
            }

            // Replace common separators with comma and clean the string
            let cleanedString = dimensionString
                .replace(/[x√ó*]/gi, ',')  // Replace x, √ó, or * with comma
                .replace(/\s+/g, ',')    // Replace spaces with comma
                .replace(/[,\s]+/g, ',') // Replace multiple commas/spaces with single comma
                .replace(/^,|,$/g, '');  // Remove leading/trailing commas

            // Split by comma and parse numbers
            const values = cleanedString
                .split(',')
                .map(val => val.trim())
                .filter(val => val !== '')
                .map(val => parseFloat(val))
                .filter(val => !isNaN(val) && val > 0 && val < 1000); // Reasonable dimension limits

            console.log(`Parsed dimensions from "${dimensionString}":`, values);
            return values;
        } catch (error) {
            console.error('Error parsing dimension values:', error);
            return [];
        }
    }

    /**
     * Extract entities from Wit.ai response and update conversation data
     */
    async extractAndUpdateConversationData(entities, currentConversationData, messageText = '') {
        try {
            // Skip entity processing only for simple greetings without product information
            if (messageText && this.isGreeting(messageText) && !this.hasProductInformation(messageText)) {
                console.log("üéØ Skipping entity extraction for simple greeting message:", messageText);
                return currentConversationData;
            }

            const updatedData = { ...currentConversationData };
            console.log("Processing entities:", entities);

            // Define processing order for entities
            const customOrder = [
                "category:category",
                "product:product",
                "dimensions:dimensions",
                "material:material",
                "finishes:finishes",
                "quantities:quantities",
                "skus:skus",
                "sku:sku"
            ];

            // Sort entities based on custom order
            const sortedEntityEntries = Object.entries(entities).sort(([a], [b]) => {
                const indexA = customOrder.indexOf(a);
                const indexB = customOrder.indexOf(b);

                // If both are in custom order, sort by their position
                if (indexA !== -1 && indexB !== -1) {
                    return indexA - indexB;
                }
                // If only A is in custom order, A comes first
                if (indexA !== -1) {
                    return -1;
                }
                // If only B is in custom order, B comes first
                if (indexB !== -1) {
                    return 1;
                }
                // If neither is in custom order, maintain original order
                return 0;
            });

            // Process each entity type in sorted order
            for (const [entityType, entityArray] of sortedEntityEntries) {
                console.log(`üîç Processing entity type: ${entityType}`, JSON.stringify(entityArray, null, 2));

                for (const entity of entityArray) {
                    try {
                        const { value, confidence, body } = entity;
                        console.log(`üìù Entity Details - Type: ${entityType}`, { 
                            value, 
                            confidence, 
                            body,
                            fullEntity: JSON.stringify(entity, null, 2)
                        });

                        if (confidence > 0.5) {
                            switch (entityType) {
                                case 'category:category':
                                    // Search for category in ProductCategory schema
                                    const foundCategory = await this.findCategoryByName(value || body);
                                    if (foundCategory) {
                                        updatedData.selectedCategory = {
                                            id: foundCategory._id.toString(),
                                            erp_id: foundCategory.erp_id,
                                            name: foundCategory.name,
                                            description: foundCategory.description
                                        };
                                        
                                        // If this is a greeting message with category, auto-set wantsQuote to true
                                        if (messageText && this.isGreeting(messageText)) {
                                            updatedData.wantsQuote = true;
                                            console.log("üéØ Auto-setting wantsQuote=true for greeting with category:", foundCategory.name);
                                        }
                                        
                                        // Process any stored materials now that we have a category
                                        if (updatedData.requestedMaterial && (!updatedData.selectedMaterial || updatedData.selectedMaterial.length === 0)) {
                                            console.log("üîÑ Processing stored materials with newly selected category:", foundCategory.name);
                                            const storedMaterials = updatedData.requestedMaterial.split(' + ');
                                            const foundMaterials = [];
                                            let newRequestedMaterials = [];
                                            
                                            for (const material of storedMaterials) {
                                                console.log(`üîç Re-processing material "${material}" with category filter: ${foundCategory._id}`);
                                                const findMaterial = await this.findMaterialByName(material.trim(), foundCategory._id.toString());
                                                if (findMaterial) {
                                                    foundMaterials.push({
                                                        _id: findMaterial.erp_id.toString(),
                                                        name: findMaterial.name,
                                                        erp_id: findMaterial.erp_id
                                                    });
                                                    console.log("üö® CATEGORY-FILTERED MATERIAL:", findMaterial.name, "ERP ID:", findMaterial.erp_id);
                                                } else {
                                                    newRequestedMaterials.push(material);
                                                    console.log("Material not found in selected category, keeping as requested:", material);
                                                }
                                            }
                                            
                                            if (foundMaterials.length > 0) {
                                                updatedData.selectedMaterial = foundMaterials;
                                                // Clear requestedMaterial since we found matches
                                                if (newRequestedMaterials.length === 0) {
                                                    updatedData.requestedMaterial = null;
                                                } else {
                                                    updatedData.requestedMaterial = newRequestedMaterials.join(' + ');
                                                }
                                            }
                                        }
                                        
                                        // console.log("Found category:", foundCategory.name);
                                    } else {
                                        updatedData.requestedCategory = value || body;
                                        console.log("Category not found, stored as requested:", value || body);
                                    }
                                    break;

                                case 'product:product':
                                    // Only update product if not already selected (prevent overriding during material/finish selection)
                                    if (!currentConversationData.selectedProduct || !currentConversationData.selectedProduct.id) {
                                        // Search for product in Product schema
                                        const foundProduct = await this.findProductByName(value || body, updatedData);
                                        if (foundProduct) {
                                            updatedData.selectedProduct = {
                                                id: foundProduct._id.toString(),
                                                erp_id: foundProduct.erp_id,
                                                name: foundProduct.name,
                                                description: foundProduct.description,
                                                basePrice: foundProduct.basePrice
                                            };
                                            const foundCategory = await this.findCategoryById(foundProduct.categoryId);
                                            if (foundCategory) {
                                                updatedData.selectedCategory = {
                                                    id: foundCategory._id.toString(),
                                                    erp_id: foundCategory.erp_id,
                                                    name: foundCategory.name,
                                                    description: foundCategory.description
                                                };
                                            }
                                            // If this is a greeting message with product, auto-set wantsQuote to true
                                            if (messageText && this.isGreeting(messageText)) {
                                                updatedData.wantsQuote = true;
                                                console.log("üéØ Auto-setting wantsQuote=true for greeting with product:", foundProduct.name);
                                            }
                                        } else {
                                            updatedData.requestedProductName = value || body;
                                            // console.log("Product not found, stored as requested:", value || body);
                                        }
                                    } else {
                                        console.log("Product already selected, skipping extraction to prevent override:", currentConversationData.selectedProduct.name);
                                    }
                                    break;

                                case 'dimensions:dimensions':
                                    const dimensions = value || body;

                                    // Parse dimension values from the string
                                    const dimensionValues = this.parseDimensionValues(dimensions);

                                    // Check if we have a selected product
                                    if (updatedData.selectedProduct && updatedData.selectedProduct.id) {
                                        try {
                                            // Get the product with dimension fields
                                            const product = await conversationService.getProductById(updatedData.selectedProduct.id);

                                            if (product && product.dimensionFields && dimensionValues.length > 0) {
                                                // Initialize dimensions array if not exists
                                                if (!updatedData.dimensions) {
                                                    updatedData.dimensions = [];
                                                }

                                                // Map dimension values to product dimension fields
                                                product.dimensionFields.forEach((field, index) => {
                                                    if (dimensionValues[index] !== undefined) {
                                                        // Check if dimension already exists
                                                        const existingDimension = updatedData.dimensions.find(d => d.name === field.name);
                                                        if (!existingDimension) {
                                                            updatedData.dimensions.push({
                                                                name: field.name,
                                                                value: dimensionValues[index]
                                                            });
                                                            // console.log("Added dimension:", field.name, "=", dimensionValues[index]);
                                                        }
                                                    }
                                                });

                                                // console.log("Final dimensions array:", updatedData.dimensions);
                                            } else {
                                                console.log("No product dimension fields or no valid dimension values found");
                                            }
                                        } catch (error) {
                                            console.error("Error processing dimensions:", error);
                                        }
                                    } else {
                                        // console.log("No selected product found, skipping dimension processing");
                                    }
                                    break;
                                case 'finishes:finishes':
                                    const finishes = value || body;
                                    const findFinish = await this.findFinishByName(finishes);
                                    if (findFinish) {
                                        // Initialize selectedFinish array if it doesn't exist
                                        if (!updatedData.selectedFinish) {
                                            updatedData.selectedFinish = [];
                                        }
                                        // Check if finish already exists to avoid duplicates
                                        const finishExists = updatedData.selectedFinish.some(f => f._id === findFinish.erp_id.toString());
                                        if (!finishExists) {
                                            // Push only _id and name
                                            updatedData.selectedFinish.push({
                                                _id: findFinish.erp_id.toString(),
                                                name: findFinish.name
                                            });
                                        }
                                    }
                                    break;
                                case 'material:material':
                                    const materials = Array.isArray(entities[entityType]) ? 
                                        entities[entityType].map(e => e.value || e.body) : 
                                        [value || body];
                                    
                                    console.log("üö® MATERIAL ENTITY DETECTED:", {
                                        materials,
                                        originalEntity: entities[entityType],
                                        messageText,
                                        hasExistingMaterial: !!(currentConversationData.selectedMaterial && currentConversationData.selectedMaterial.length > 0)
                                    });
                                    
                                    // Only update materials if not already confirmed
                                    if (!currentConversationData.selectedMaterial || currentConversationData.selectedMaterial.length === 0) {
                                        // Check if we have a category to filter by
                                        const categoryId = updatedData.selectedCategory?.id || currentConversationData.selectedCategory?.id || null;
                                        
                                        if (!categoryId) {
                                            // No category selected yet - store materials as requested for later processing
                                            console.log("‚è≥ No category selected yet, storing materials as requested for later processing");
                                            updatedData.requestedMaterial = materials.join(' + ');
                                        } else {
                                            // Category available - search for materials within that category
                                            const foundMaterials = [];
                                            let requestedMaterials = [];
                                            
                                            for (const material of materials) {
                                                console.log(`üîç Material search for "${material}" with category filter: ${categoryId}`);
                                                const findMaterial = await this.findMaterialByName(material, categoryId);
                                                if (findMaterial) {
                                                    foundMaterials.push({
                                                        _id: findMaterial.erp_id.toString(),
                                                        name: findMaterial.name,
                                                        erp_id: findMaterial.erp_id
                                                    });
                                                    console.log("üö® AUTO-SELECTED MATERIAL:", findMaterial.name, "ERP ID:", findMaterial.erp_id);
                                                } else {
                                                    requestedMaterials.push(material);
                                                    console.log("Material not found in category, storing as requested:", material);
                                                }
                                            }
                                            
                                            if (foundMaterials.length > 0) {
                                                updatedData.selectedMaterial = foundMaterials;
                                            }
                                            if (requestedMaterials.length > 0) {
                                                updatedData.requestedMaterial = requestedMaterials.join(' + ');
                                            }
                                        }
                                    } else {
                                        console.log("Materials already selected, skipping extraction to prevent override");
                                    }
                                    break;
                                case 'quantities:quantities':
                                    // Don't extract quantity if this looks like a dimension string
                                    if (messageText && this.isDimensionMessage(messageText)) {
                                        console.log("Skipping quantity extraction - detected dimension message:", messageText);
                                        break;
                                    }
                                    
                                    const quantities = Array.isArray(entities[entityType]) ? 
                                        entities[entityType].map(e => e.value || e.body) : 
                                        [value || body];
                                    
                                    console.log("üî¢ QUANTITY ENTITIES DETECTED:", {
                                        quantities,
                                        originalEntity: entities[entityType],
                                        messageText
                                    });
                                    
                                    if (!updatedData.quantity) {
                                        updatedData.quantity = [];
                                    }
                                    
                                    for (const quantity of quantities) {
                                        // Convert to number for comparison - handle comma-separated numbers and "k" notation
                                        const cleanQuantity = quantity.toString().replace(/,/g, '');
                                        
                                        // Handle "k" notation (e.g., "19k" -> 19000)
                                        let numericQuantity;
                                        if (cleanQuantity.toLowerCase().includes('k')) {
                                            // Extract number before 'k' and multiply by 1000
                                            const kMatch = cleanQuantity.toLowerCase().match(/(\d+(?:\.\d+)?)k/);
                                            if (kMatch) {
                                                numericQuantity = parseFloat(kMatch[1]) * 1000;
                                                console.log(`Converted "${cleanQuantity}" to ${numericQuantity} (k notation)`);
                                            } else {
                                                numericQuantity = parseInt(cleanQuantity);
                                            }
                                        } else {
                                            numericQuantity = parseInt(cleanQuantity);
                                        }
                                        
                                        if (!isNaN(numericQuantity) && !updatedData.quantity.includes(numericQuantity)) {
                                            updatedData.quantity.push(numericQuantity);
                                            console.log(`Added quantity: ${numericQuantity} (from "${quantity}")`);
                                        }
                                    }
                                    break;
                                case 'skus:skus':
                                case 'sku:sku':
                                    console.log("üéØ Processing SKU entity:", { value, body, confidence });
                                    const skuValue = value || body;
                                    console.log("üì¶ SKU value extracted:", skuValue);
                                    
                                    // Store SKU as single value, not array
                                    const cleanSku = skuValue.toString().replace(/,/g, '');
                                    const skuNum = parseInt(cleanSku);
                                    
                                    console.log("üî¢ SKU number conversion:", { cleanSku, skuNum, isNaN: isNaN(skuNum) });
                                    
                                    if (!isNaN(skuNum)) {
                                        updatedData.skus = skuNum;
                                        console.log("‚úÖ Stored numeric SKU:", skuNum);
                                    } else {
                                        updatedData.skus = skuValue;
                                        console.log("‚úÖ Stored string SKU:", skuValue);
                                    }
                                    
                                    console.log("üìä Current skus value:", updatedData.skus);
                                    break;
                                default:
                                    // Check if this is a SKU-related entity that we missed
                                    if (entityType.includes('sku') || entityType.includes('SKU')) {
                                        console.log("üéØ Processing potential SKU entity (fallback):", { entityType, value, body, confidence });
                                        const skuValue = value || body;
                                        
                                        const cleanSku = skuValue.toString().replace(/,/g, '');
                                        const skuNum = parseInt(cleanSku);
                                        
                                        if (!isNaN(skuNum)) {
                                            updatedData.skus = skuNum;
                                            console.log("‚úÖ Stored SKU via fallback:", skuNum);
                                        } else {
                                            updatedData.skus = skuValue;
                                            console.log("‚úÖ Stored SKU string via fallback:", skuValue);
                                        }
                                    }
                                    break;
                        }
                        }
                    } catch (entityError) {
                        console.error(`Error processing entity ${entityType}:`, entityError);
                        await mongoLogger.logError(entityError, {
                            source: 'entity-processor',
                            entityType: entityType,
                            entity: entity
                        });
                        // Continue processing other entities
                    }
                }
            }

            console.log("‚úÖ Final Updated Conversation Data:", JSON.stringify(updatedData, null, 2));
            console.log("üîç Checking for SKUs in final data:", {
                hasSkus: !!updatedData.skus,
                skusValue: updatedData.skus,
                skusType: typeof updatedData.skus
            });
            return updatedData;
        } catch (error) {
            console.error('Error in extractAndUpdateConversationData:', error);
            await mongoLogger.logError(error, {
                source: 'extract-conversation-data',
                entities: entities
            });
            // Return original data if extraction fails
            return currentConversationData;
        }
    }

    /**
     * Find category by name in ProductCategory schema
     */
    async findCategoryByName(categoryName) {
        try {
            const categories = await conversationService.getProductCategories();

            // Search in name field
            let foundCategory = categories.find(cat =>
                cat.name.toLowerCase().includes(categoryName.toLowerCase())
            );

            // If not found in name, search in sub_names
            if (!foundCategory) {
                foundCategory = categories.find(cat =>
                    cat.sub_names && cat.sub_names.some(subName =>
                        subName.toLowerCase().includes(categoryName.toLowerCase())
                    )
                );
            }

            return foundCategory;
        } catch (error) {
            console.error('Error finding category by name:', error);
            return null;
        }
    }

    /**
     * Find category by ID in ProductCategory schema
     */
    async findCategoryById(categoryId) {
        try {
            // Convert ObjectId to string if needed
            const categoryIdString = categoryId.toString();
            console.log("categoryIdString ", categoryIdString);

            // First try to find by MongoDB ObjectId
            let category = await ProductCategory.findById(categoryIdString);

            // If not found and it's a number, try finding by ERP ID
            if (!category && !isNaN(parseInt(categoryIdString))) {
                category = await ProductCategory.findOne({ erp_id: parseInt(categoryIdString) });
                console.log("Found category by ERP ID:", category?.name);
            }

            return category;
        } catch (error) {
            console.error('Error finding category by ID:', error);
            return null;
        }
    }

    /**
     * Find product by name in Product schema
     */
    async findProductByName(productName, conversationData = {}) {
        try {
            // Search all active products
            const products = await Product.find({ isActive: true }).sort({ sortOrder: 1, name: 1 });

            // Search in name field
            let foundProduct = products.find(product =>
                product.name.toLowerCase().includes(productName.toLowerCase())
            );

            // If not found in name, search in description
            if (!foundProduct) {
                foundProduct = products.find(product =>
                    product.description && product.description.toLowerCase().includes(productName.toLowerCase())
                );
            }

            // If not found in description, search in erp_id
            if (!foundProduct) {
                const erpId = parseInt(productName);
                if (!isNaN(erpId)) {
                    foundProduct = products.find(product => product.erp_id === erpId);
                }
            }

            return foundProduct;
        } catch (error) {
            console.error('Error finding product by name:', error);
            return null;
        }
    }

    async findFinishByName(finishName) {
        try {
            // Search all active finishes
            const finishes = await ProductFinish.find({ isActive: true }).sort({ sortOrder: 1, name: 1 });
            
            // Search in name field
            let foundFinish = finishes.find(finish =>
                finish.name.toLowerCase().includes(finishName.toLowerCase())
            );
            
            // If not found in name, search in description
            if (!foundFinish) {
                foundFinish = finishes.find(finish =>
                    finish.description && finish.description.toLowerCase().includes(finishName.toLowerCase())
                );
            }
            
            // If not found in description, search in erp_id
            if (!foundFinish) {
                const erpId = parseInt(finishName);
                if (!isNaN(erpId)) {
                    foundFinish = finishes.find(finish => finish.erp_id === erpId);
                }
            }
            
            return foundFinish;
        } catch (error) {
            console.error('Error finding finish by name:', error);
            return null;
        }
    }

    async findMaterialByName(materialName, categoryId = null) {
        try {
            console.log("üîç Searching for material:", materialName, categoryId ? `in category: ${categoryId}` : 'across all categories');
            
            // Search materials - filter by category if provided
            const searchQuery = { isActive: true };
            if (categoryId) {
                searchQuery.categoryId = categoryId;
            }
            const materials = await Material.find(searchQuery).sort({ sortOrder: 1, name: 1 });
            console.log("üîç Available materials:", materials.map(m => ({ name: m.name, erp_id: m.erp_id, categoryId: m.categoryId })));
            
            // Search in name field (exact match first)
            let foundMaterial = materials.find(material =>
                material.name.toLowerCase() === materialName.toLowerCase()
            );
            
            if (foundMaterial) {
                console.log("üéØ Found exact match:", foundMaterial.name);
                return foundMaterial;
            }
            
            // If not found, search for partial match in name
            foundMaterial = materials.find(material =>
                material.name.toLowerCase().includes(materialName.toLowerCase())
            );
            
            if (foundMaterial) {
                console.log("üéØ Found partial match in name:", foundMaterial.name);
                return foundMaterial;
            }
            
            // If not found in name, search in description
            foundMaterial = materials.find(material =>
                material.description && material.description.toLowerCase().includes(materialName.toLowerCase())
            );
            
            if (foundMaterial) {
                console.log("üéØ Found match in description:", foundMaterial.name);
                return foundMaterial;
            }
            
            // If not found in description, try searching for composite materials like "PET+MET+PE" or "PET + MPET + PE"
            if (!foundMaterial) {
                console.log("üîç Trying composite material search for:", materialName);
                
                // Split by common separators: +, -, space, etc.
                const materialParts = materialName.split(/[+\-\s,]+/).map(part => part.trim().toUpperCase()).filter(part => part.length > 0);
                console.log("üîç Material parts:", materialParts);
                
                // Try to find a material that contains all the parts
                foundMaterial = materials.find(material => {
                    const materialNameUpper = material.name.toUpperCase();
                    const allPartsPresent = materialParts.every(part => 
                        materialNameUpper.includes(part)
                    );
                    console.log(`üîç Checking material "${material.name}" against parts [${materialParts.join(', ')}]: ${allPartsPresent}`);
                    return allPartsPresent;
                });
                
                // If no material contains all parts, try to find one with most parts
                if (!foundMaterial && materialParts.length > 1) {
                    console.log("üîç No exact composite match, trying partial composite match");
                    let bestMatch = null;
                    let maxMatches = 0;
                    
                    for (const material of materials) {
                        const materialNameUpper = material.name.toUpperCase();
                        const matches = materialParts.filter(part => 
                            materialNameUpper.includes(part)
                        ).length;
                        
                        console.log(`üîç Material "${material.name}" matches ${matches}/${materialParts.length} parts`);
                        
                        if (matches > maxMatches && matches >= Math.ceil(materialParts.length / 2)) {
                            maxMatches = matches;
                            bestMatch = material;
                        }
                    }
                    
                    if (bestMatch) {
                        foundMaterial = bestMatch;
                        console.log(`üéØ Best composite match: ${bestMatch.name} (${maxMatches}/${materialParts.length} parts)`);
                    }
                }
                
                // Fallback: try finding any material containing any of the parts
                if (!foundMaterial) {
                    console.log("üîç Trying fallback search for any part");
                    for (const part of materialParts) {
                        foundMaterial = materials.find(material =>
                            material.name.toUpperCase().includes(part)
                        );
                        if (foundMaterial) {
                            console.log(`üéØ Found material containing "${part}": ${foundMaterial.name}`);
                            break;
                        }
                    }
                }
            }
            
            // If not found, search in erp_id
            if (!foundMaterial) {
                const erpId = parseInt(materialName);
                if (!isNaN(erpId)) {
                    foundMaterial = materials.find(material => material.erp_id === erpId);
                }
            }
            
            console.log("Material search result:", foundMaterial ? foundMaterial.name : "Not found");
            return foundMaterial;
        } catch (error) {
            console.error('Error finding material by name:', error);
            return null;
        }
    }

    /**
     * Check if message is a simple restart/greeting after conversation completion
     */
    isSimpleRestartMessage(messageText) {
        const lowerText = messageText.toLowerCase().trim();
        const restartKeywords = [
            'hi', 'hello', 'hey', 'restart', 'new quote', 'start over', 
            'reset', 'begin again', 'fresh quote', 'another quote', 'new order'
        ];
        
        return restartKeywords.some(keyword => 
            lowerText === keyword || lowerText.includes(keyword)
        );
    }

    /**
     * Handle restart messages for completed conversations
     */
    async handleCompletedConversationRestart(messageText, from, messageId) {
        try {
            const lowerText = messageText.toLowerCase().trim();
            
            // Send comprehensive restart message
            await this.sendMessageOnce(
                messageId,
                from,
                `Hello! üëã I'd be happy to help you with a new quote! 

Please share your complete quote details:

üì¶ **Product Type:** (e.g. stand up pouch, flat pouch, labels, folding cartons)
üìè **Dimensions:** (e.g. 5x8 inches, 10x12x3 cm)
üß± **Material:** (e.g. PET+PE, kraft paper, metallized film)
üî¢ **Quantity:** (e.g. 5000, 10k, 20000 pieces)
‚ú® **Finishes:** (e.g. matte, spot UV, foil, holographic)
üé® **SKUs/Designs:** (e.g. 1, 2, 4 different designs)

*Example: "I need 10,000 stand up pouches, 6x9 inches, metallized material, spot UV finish, 2 designs"*

Or just say 'hi' to be guided step by step! üòä`
            );

            // Reset conversation for new quote
            await conversationService.resetConversation(from);
            
        } catch (error) {
            console.error('Error handling completed conversation restart:', error);
            await mongoLogger.logError(error, {
                source: 'completed-conversation-restart',
                from: from,
                messageText: messageText
            });
        }
    }

    /**
     * Check if message contains simple keywords that don't need ChatGPT processing
     */
    isSimpleKeywordMessage(messageText, currentStep) {
        const lowerText = messageText.toLowerCase().trim();
        
        // Simple yes/no responses
        if (['yes', 'no', 'pdf', 'ok', 'okay'].includes(lowerText)) {
            return true;
        }
        
        // Restart keywords - should always be handled as simple keywords
        const restartKeywords = ['restart', 'new quote', 'start over', 'reset', 'begin again', 'fresh quote', 'another quote', 'new order'];
        if (restartKeywords.some(keyword => lowerText === keyword || lowerText.includes(keyword))) {
            return true;
        }
        
        // Quote generation step specific keywords
        if (currentStep === 'quote_generation') {
            const quoteKeywords = ['generate', 'create quote', 'pdf', 'download', 'send quote'];
            return quoteKeywords.some(keyword => lowerText.includes(keyword));
        }
        
        // Simple greetings in non-start steps
        if (['hi', 'hello', 'hey'].includes(lowerText) && currentStep !== 'start') {
            return true;
        }
        
        return false;
    }

    /**
     * Handle simple keyword messages without ChatGPT processing
     */
    async handleSimpleKeywordMessage(messageText, from, messageId, conversationState) {
        try {
            const lowerText = messageText.toLowerCase().trim();
            const currentStep = conversationState.currentStep;
            
            console.log(`üéØ Handling simple keyword: "${lowerText}" in step: ${currentStep}`);
            
            // Handle PDF requests in quote_generation step
            if (currentStep === 'quote_generation' && lowerText.includes('pdf')) {
                await this.handleQuoteGeneration(messageText, from, conversationState.conversationData, { id: messageId });
                return;
            }
            
            // Handle yes/no responses based on current step
            if (lowerText === 'yes') {
                switch (currentStep) {
                    case 'greeting_response':
                        await this.handleGreetingResponse('yes', from, messageId);
                        break;
                    case 'quote_generation':
                        // User confirmed quote details, pass 'yes' to quote generation handler
                        await this.handleQuoteGeneration('yes', from, conversationState.conversationData, { id: messageId });
                        break;
                    default:
                        await this.sendMessageOnce(
                            messageId,
                            from,
                            "Thank you for confirming! Please provide the specific details I requested above."
                        );
                }
                return;
            }
            
            if (lowerText === 'no') {
                switch (currentStep) {
                    case 'greeting_response':
                        await this.handleGreetingResponse('no', from, messageId);
                        break;
                    default:
                        await this.sendMessageOnce(
                            messageId,
                            from,
                            "No problem! Please let me know how I can help you, or say 'restart' for a new quote."
                        );
                }
                return;
            }
            
            // Handle restart requests
            const restartKeywords = ['restart', 'new quote', 'start over', 'reset', 'begin again', 'fresh quote', 'another quote', 'new order'];
            if (restartKeywords.some(keyword => lowerText === keyword || lowerText.includes(keyword))) {
                console.log(`üîÑ User requested restart: "${lowerText}"`);
                
                // Send restart message asking for complete quote details
                await this.sendMessageOnce(
                    messageId,
                    from,
                    `Starting fresh! üÜï 

Please share your complete quote details:

üì¶ **Product Type:** (e.g. stand up pouch, flat pouch, labels, folding cartons)
üìè **Dimensions:** (e.g. 5x8 inches, 10x12x3 cm)
üß± **Material:** (e.g. PET+PE, kraft paper, metallized film)
üî¢ **Quantity:** (e.g. 5000, 10k, 20000 pieces)
‚ú® **Finishes:** (e.g. matte, spot UV, foil, holographic)
üé® **SKUs/Designs:** (e.g. 1, 2, 4 different designs)

*Example: "I need 10,000 stand up pouches, 6x9 inches, metallized material, spot UV finish, 2 designs"*

Or just say 'hi' to be guided step by step! üòä`
                );
                
                // Reset conversation
                await conversationService.resetConversation(from);
                return;
            }

            // Handle simple greetings in middle of conversation
            if (['hi', 'hello', 'hey'].includes(lowerText)) {
                await this.sendContextualGreeting(from, messageId, currentStep, conversationState.conversationData);
                return;
            }
            
            // Handle other simple keywords
            if (['ok', 'okay'].includes(lowerText)) {
                await this.sendMessageOnce(
                    messageId,
                    from,
                    "Great! Please provide the information I requested above to continue with your quote."
                );
                return;
            }
            
        } catch (error) {
            console.error('Error handling simple keyword message:', error);
            await mongoLogger.logError(error, {
                source: 'simple-keyword-handler',
                from: from,
                messageText: messageText,
                currentStep: conversationState.currentStep
            });
        }
    }

    /**
     * Send contextual greeting based on current conversation step
     */
    async sendContextualGreeting(from, messageId, currentStep, conversationData) {
        let message = "Hello! üëã ";
        
        switch (currentStep) {
            case 'category_selection':
                message += "I'm waiting for you to select a product category from the list above.";
                break;
            case 'product_selection':
                message += `I'm waiting for you to select a product from the ${conversationData?.selectedCategory?.name || 'selected'} category.`;
                break;
            case 'dimension_input':
                message += `I need the dimensions for your ${conversationData?.selectedProduct?.name || 'selected product'}.`;
                break;
            case 'material_selection':
                message += "I'm waiting for you to select the material for your product.";
                break;
            case 'finish_selection':
                message += "I'm waiting for you to select the finish options for your product.";
                break;
            case 'quantity_input':
                message += "I need to know the quantity you're looking for.";
                break;
            case 'quote_generation':
                message += "I have all your details! Say 'pdf' to generate your quote.";
                break;
            default:
                message += "I'm here to help with your quote request. Please provide the details I asked for above.";
        }
        
        await this.sendMessageOnce(messageId, from, message);
    }

    /**
     * Check if a step should be bypassed based on available data
     */
    shouldBypassStep(step, conversationData) {
        switch (step) {
            case 'greeting_response':
                // Bypass greeting_response if we have category data and user wants a quote
                return conversationData.wantsQuote && 
                       ((conversationData.selectedCategory && conversationData.selectedCategory.id) || conversationData.requestedCategory);

            case 'category_selection':
                return (conversationData.selectedCategory && conversationData.selectedCategory.id) || conversationData.requestedCategory;

            case 'product_selection':
                return (conversationData.selectedProduct && conversationData.selectedProduct.id) || conversationData.requestedProductName;

            case 'dimension_input':
                return conversationData.dimensions && conversationData.dimensions.length > 0;

            case 'material_selection':
                return conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0;

            case 'finish_selection':
                return conversationData.selectedFinish && conversationData.selectedFinish.length > 0;

            case 'quantity_input':
                return conversationData.quantity && conversationData.quantity.length > 0;

            default:
                return false;
        }
    }

    /**
     * Get the next step after bypassing current step
     */
    getNextStepAfterBypass(currentStep, conversationData) {
        // Check if all required dimensions are provided
        let hasAllRequiredDimensions = false;
        if (conversationData.selectedProduct && conversationData.dimensions && conversationData.dimensions.length > 0) {
            // Get the product to check required dimensions
            const product = conversationData.selectedProduct;
            if (product.dimensionFields) {
                const requiredDimensionCount = product.dimensionFields.length;
                const providedDimensionCount = conversationData.dimensions.length;
                hasAllRequiredDimensions = providedDimensionCount >= requiredDimensionCount;
                
                console.log('üîç Dimension validation:', {
                    productName: product.name,
                    requiredDimensions: requiredDimensionCount,
                    providedDimensions: providedDimensionCount,
                    hasAllRequired: hasAllRequiredDimensions,
                    requiredFields: product.dimensionFields.map(f => f.name),
                    providedFields: conversationData.dimensions.map(d => d.name)
                });
            } else {
                // No dimension fields defined, consider complete
                hasAllRequiredDimensions = true;
            }
        }
        
        // If we have all required data, go to quote generation
        if (conversationData.selectedProduct &&
            hasAllRequiredDimensions &&
            conversationData.selectedMaterial &&
            conversationData.selectedMaterial.length > 0 &&
            conversationData.selectedFinish &&
            conversationData.selectedFinish.length > 0 &&
            conversationData.quantity &&
            conversationData.quantity.length > 0) {
            return 'quote_generation';
        }

        // Otherwise, move to the next logical step
        switch (currentStep) {
            case 'greeting_response':
                return conversationData.selectedProduct ? 'dimension_input' : 
                       (conversationData.selectedCategory ? 'product_selection' : 'category_selection');

            case 'category_selection':
                return conversationData.selectedProduct ? 'dimension_input' : 'product_selection';

            case 'product_selection':
                return 'dimension_input';

            case 'dimension_input':
                // Check if we have all required dimensions before moving to material selection
                if (conversationData.selectedProduct && conversationData.selectedProduct.dimensionFields) {
                    const requiredCount = conversationData.selectedProduct.dimensionFields.length;
                    const providedCount = conversationData.dimensions ? conversationData.dimensions.length : 0;
                    
                    if (providedCount < requiredCount) {
                        console.log('üîç Staying in dimension_input - missing dimensions:', {
                            required: requiredCount,
                            provided: providedCount,
                            missing: requiredCount - providedCount
                        });
                        return 'dimension_input'; // Stay in dimension input until all are provided
                    }
                }
                return 'material_selection';

            case 'material_selection':
                return 'finish_selection';

            case 'finish_selection':
                return 'quantity_input';

            case 'quantity_input':
                return 'quote_generation';

            default:
                return currentStep;
        }
    }

    /**
     * Determine the next step based on current step and extracted data
     */
    async determineNextStep(currentStep, conversationData, entities) {
        console.log('üîç determineNextStep called with:', {
            currentStep,
            wantsQuote: conversationData.wantsQuote,
            hasSelectedCategory: !!conversationData.selectedCategory?.id,
            selectedCategory: conversationData.selectedCategory
        });

        // Special case: If we're in 'start' step and have selectedCategory, go to product_selection
        if (currentStep === 'start' && conversationData.selectedCategory?.id) {
            console.log('‚úÖ Case 1: start + has selectedCategory ‚Üí product_selection');
            return 'product_selection';
        }

        // Special case: If we're in 'start' step and user wants quote but no category selected, go to greeting_response
        if (currentStep === 'start' && conversationData.wantsQuote && !conversationData.selectedCategory?.id) {
            console.log('‚úÖ Case 2: start + wantsQuote + no category ‚Üí greeting_response');
            return 'greeting_response';
        }

        // Special case: If we're in 'greeting_response' and now have selectedCategory, move to product_selection
        if (currentStep === 'greeting_response' && conversationData.selectedCategory?.id) {
            console.log('‚úÖ Case 3: greeting_response + has selectedCategory ‚Üí product_selection');
            return 'product_selection';
        }

        // Use the bypassing logic to determine next step
        if (this.shouldBypassStep(currentStep, conversationData)) {
            const bypassResult = this.getNextStepAfterBypass(currentStep, conversationData);
            console.log('‚úÖ Case 4: bypass logic ‚Üí', bypassResult);
            return bypassResult;
        }

        console.log('‚úÖ Case 5: no change ‚Üí', currentStep);
        return currentStep; // Keep current step if no advancement possible
    }

    async processConversationFlow(message, messageText, from, conversationState, hasResponded = false) {
        console.log("processConversationFlow ", messageText, from, conversationState);
        try {
            const currentStep = conversationState.currentStep;
            const conversationData = conversationState.conversationData || {};

            // Check if conversation is already completed
            if (conversationData.completed || currentStep === 'completed') {
                console.log(`‚è≠Ô∏è Conversation already completed for ${from}, skipping processing`);
                return;
            }

            await mongoLogger.info('Processing conversation step', { currentStep, from });

            // Check if current step should be bypassed
            if (this.shouldBypassStep(currentStep, conversationData)) {
                await mongoLogger.info(`Bypassing step: ${currentStep}`, {
                    from,
                    conversationData: Object.keys(conversationData)
                });

                const nextStep = this.getNextStepAfterBypass(currentStep, conversationData);

                // Update conversation state to next step
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Recursively process the next step - but don't send duplicate responses
                const updatedState = await conversationService.getConversationState(from);
                return await this.processConversationFlow(message, messageText, from, updatedState, hasResponded);
            }
            
            // Only process step if we haven't already responded
            if (!hasResponded) {
                try {
                    switch (currentStep) {
                        case 'start':
                            await this.handleStartStep(messageText, from, message.id);
                            break;
                        case 'greeting_response':
                            await this.handleGreetingResponse(messageText, from, message.id);
                            break;
                        case 'category_selection':
                            await this.handleCategorySelection(messageText, from);
                            break;
                        case 'product_selection':
                            await this.handleProductSelection(messageText, from);
                            break;
                        case 'dimension_input':
                            await this.handleDimensionInput(messageText, from, conversationData, message);
                            break;
                        case 'material_selection':
                            await this.handleMaterialSelection(messageText, from, conversationData);
                            break;
                        case 'finish_selection':
                            await this.handleFinishSelection(messageText, from, conversationData);
                            break;
                        case 'quantity_input':
                            await this.handleQuantityInput(messageText, from, conversationData);
                            break;
                        case 'quote_generation':
                            await this.handleQuoteGeneration(messageText, from, conversationData, message);
                            break;
                        default:
                            console.log(`Unknown step: ${currentStep}, defaulting to start step`);
                            await this.handleStartStep(messageText, from, message.id);
                    }
                } catch (stepError) {
                    console.error(`Error in step ${currentStep}:`, stepError);
                    await mongoLogger.logError(stepError, {
                        source: 'conversation-step-handler',
                        step: currentStep,
                        from: from,
                        messageText: messageText
                    });

                    // Send user-friendly error message (only once)
                    await this.sendMessageOnce(
                        message.id,
                        from,
                        "Sorry, I encountered an error processing your request. Let me start over."
                    );

                    // Reset conversation to start step
                    await conversationService.updateConversationState(from, {
                        currentStep: 'start',
                        conversationData: {}
                    });
                }
            } else {
                console.log(`Skipping step processing - already responded for ${from}`);
            }
        } catch (error) {
            await mongoLogger.logError(error, { source: 'conversation-flow' });
            // Only send error message if we haven't already responded
            const messageId = message?.id || 'error-flow-' + Date.now();
            if (!(await this.hasResponded(messageId))) {
                await this.sendMessageOnce(
                    messageId,
                    from,
                    "I'm sorry, something went wrong. Let me restart our conversation. Please type 'hi' to begin."
                );
            }
            await conversationService.resetConversation(from);
        }
    }

    async handleStartStep(messageText, from, messageId) {
        try {
            // Process with ChatGPT to detect greeting (with fallback)
            let intent = null;
            try {
                const aiResponse = await this.aiService.processMessage(messageText);
                intent = aiResponse.data?.intents?.[0]?.name;
            } catch (aiError) {
                console.log("ChatGPT not available, using fallback greeting detection");
                await mongoLogger.warn('ChatGPT unavailable in handleStartStep, using fallback', { 
                    messageText, 
                    from,
                    error: aiError.message
                });
            }

            if (intent === 'greeting' || this.isGreeting(messageText)) {
                await this.sendGreetingWithQuoteOption(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'greeting_response'
                });
            } else {
                await this.sendMessageOnce(
                    messageId,
                    from,
                    "Hello! üëã Welcome to our mylar bag service. Please say 'Hi' to get started with your quote request."
                );
                await conversationService.updateConversationState(from, {
                    currentStep: 'greeting_response'
                });
            }
        } catch (error) {
            console.error('Error in handleStartStep:', error);
            await mongoLogger.error('handleStartStep failed', { 
                messageText, 
                from,
                error: error.message,
                stack: error.stack
            });
            
            // Fallback response
            await this.sendMessageOnce(
                messageId,
                from,
                "Hello! üëã Welcome to our mylar bag service. Please say 'Hi' to get started with your quote request."
            );
        }
    }

    async sendGreetingWithQuoteOption(from) {
        const buttons = [
            {
                type: 'reply',
                reply: {
                    id: 'quote_yes',
                    title: 'Yes, Get Quote'
                }
            },
            {
                type: 'reply',
                reply: {
                    id: 'quote_no',
                    title: 'No, Thanks'
                }
            }
        ];

        const bodyText = `Hello! üëã Welcome to our Mylar Bag service! 

We specialize in high-quality mylar bags for all your packaging needs.

Would you like to get a quote for mylar bags today?`;

        await this.whatsappService.sendButtonMessage(from, bodyText, buttons);
    }

    async handleGreetingResponse(messageText, from, messageId = null) {
        const response = messageText.toLowerCase().trim();
        console.log('üéØ handleGreetingResponse called with:', { messageText, response, from });

        // Check if user is making a specific quote request (e.g., "need folding carton quote")
        const isQuoteRequest = response.includes('quote') || response.includes('need') || 
                              response.includes('want') || response.includes('get');
                              
        // Check if user mentioned a specific category
        const hasProductInfo = this.hasProductInformation(messageText);

        if (response.includes('yes') || response === 'quote_yes' || response.includes('get quote') || 
            (isQuoteRequest && hasProductInfo)) {
            console.log('‚úÖ User wants quote, updating state to category_selection or proceeding with extracted category');
            
            await conversationService.updateConversationState(from, {
                currentStep: 'category_selection',
                'conversationData.wantsQuote': true
            });
            
            // Check if we already have category information from entity extraction
            const conversationState = await conversationService.getConversationState(from);
            const selectedCategory = conversationState.conversationData?.selectedCategory;
            
            if (selectedCategory && selectedCategory.id) {
                console.log('üì¶ Category already identified from message, proceeding to product selection');
                
                // Send confirmation that category was detected
                await this.whatsappService.sendMessage(
                    from,
                    `‚úÖ Perfect! I detected you need a quote for **${selectedCategory.name}** products. Let me show you the available options.`
                );
                
                await conversationService.updateConversationState(from, {
                    currentStep: 'product_selection'
                });
                
                // Small delay to ensure messages appear in order
                setTimeout(async () => {
                    await this.sendProductSelection(from);
                }, 1000);
            } else {
                console.log('üì§ No category identified, calling sendCategorySelection');
                await this.sendCategorySelection(from);
            }
        } else if (response.includes('no') || response === 'quote_no') {
            await this.sendMessageOnce(
                messageId,
                from,
                "No problem! If you change your mind or have any questions about our mylar bags, feel free to reach out anytime. Have a great day! üòä"
            );
            await conversationService.updateConversationState(from, {
                currentStep: 'completed',
                isActive: false,
                completedAt: new Date()
            });
        } else {
            await this.sendMessageOnce(
                messageId,
                from,
                "Please reply with 'Yes' if you want a quote or 'No' if you don't need one right now."
            );
        }
    }

    async sendCategorySelection(from, messageId = null) {
        console.log('üéØ sendCategorySelection called for:', from);
        try {
            const categories = await conversationService.getProductCategories();
            console.log('üìã Retrieved categories:', categories?.length || 0);

            if (!categories || categories.length === 0) {
                if (messageId) {
                    await this.sendMessageOnce(
                        messageId,
                        from,
                        "Sorry, no product categories are available at the moment. Please try again later."
                    );
                } else {
                    await this.sendMessageFallback(
                        from,
                        "Sorry, no product categories are available at the moment. Please try again later."
                    );
                }
                return;
            }

            // Ensure we're in category_selection step before sending the list
            await conversationService.updateConversationState(from, {
                currentStep: 'category_selection'
            });

            const sections = [{
                title: "Product Categories",
                rows: categories.map(category => ({
                    id: category.erp_id.toString(),
                    title: category.name,
                    description: category.description
                }))
            }];

            const bodyText = `Perfect! üéØ Let's start by selecting the category that best fits your needs. Which category are you interested in?`;
            console.log('sections ', sections);
            await this.whatsappService.sendListMessage(
                from,
                bodyText,
                "Select Category",
                sections
            );
        } catch (error) {
            await mongoLogger.logError(error, { source: 'send-category-selection' });
            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error loading categories. Please try again later."
            );
        }
    }

    async handleCategorySelection(messageText, from) {
        console.log('üéØ handleCategorySelection called with:', { messageText, from });

        const categories = await conversationService.getProductCategories();
        console.log('üìã Available categories:', categories?.map(c => ({ name: c.name, erp_id: c.erp_id })) || 'No categories found');

        if (!categories || categories.length === 0) {
            await this.whatsappService.sendMessage(
                from,
                "Sorry, no product categories are available at the moment. Please try again later."
            );
            return;
        }

        let selectedCategory = null;

        // Check if it's a direct category ERP ID or find by name
        selectedCategory = categories.find(c =>
            c.erp_id.toString() === messageText ||
            c.name.toLowerCase().includes(messageText.toLowerCase())
        );

        console.log('üîç Category search result:', {
            searchTerm: messageText,
            foundCategory: selectedCategory ? { name: selectedCategory.name, erp_id: selectedCategory.erp_id } : null,
            searchByERP: categories.some(c => c.erp_id.toString() === messageText),
            searchByName: categories.some(c => c.name.toLowerCase().includes(messageText.toLowerCase())),
            allCategoryERPIds: categories.map(c => c.erp_id.toString()),
            exactMatch: categories.find(c => c.erp_id.toString() === messageText)
        });

        if (selectedCategory) {
            console.log('‚úÖ Updating conversation state with selected category:', {
                id: selectedCategory._id,
                erp_id: selectedCategory.erp_id,
                name: selectedCategory.name,
                description: selectedCategory.description
            });
            
            const updatePayload = {
                currentStep: 'product_selection',
                'conversationData.selectedCategory': {
                    id: selectedCategory._id,
                    erp_id: selectedCategory.erp_id,
                    name: selectedCategory.name,
                    description: selectedCategory.description
                }
            };
            console.log('üì§ Update payload:', JSON.stringify(updatePayload, null, 2));
            
            try {
                const updatedState = await conversationService.updateConversationState(from, updatePayload);
                console.log('üì• Update response received:', {
                    success: !!updatedState,
                    currentStep: updatedState?.currentStep,
                    selectedCategory: updatedState?.conversationData?.selectedCategory,
                    hasCategory: !!updatedState?.conversationData?.selectedCategory?.id,
                    fullState: JSON.stringify(updatedState, null, 2)
                });

                // Verify the update was successful by reading back the state
                const verificationState = await conversationService.getConversationState(from);
                console.log('ÔøΩ Verification - state after update:', {
                    currentStep: verificationState?.currentStep,
                    selectedCategory: verificationState?.conversationData?.selectedCategory,
                    hasCategory: !!verificationState?.conversationData?.selectedCategory?.id,
                    categoryId: verificationState?.conversationData?.selectedCategory?.id,
                    categoryName: verificationState?.conversationData?.selectedCategory?.name
                });

                if (!verificationState?.conversationData?.selectedCategory?.id) {
                    console.error('‚ùå CRITICAL: Category update failed to persist in database!');
                    await mongoLogger.logError(new Error('Category selection failed to persist'), {
                        source: 'category-selection-persistence',
                        from: from,
                        selectedCategory: selectedCategory,
                        updatePayload: updatePayload,
                        updatedState: updatedState,
                        verificationState: verificationState
                    });
                    
                    // Retry the update
                    console.log('üîÑ Retrying category update...');
                    const retryState = await conversationService.updateConversationState(from, updatePayload);
                    console.log('üîÑ Retry result:', retryState);
                } else {
                    console.log('‚úÖ Category successfully persisted in database');
                }

                console.log('ÔøΩüì§ Sending product selection for category:', selectedCategory.name);
            await this.sendProductSelection(from);
            } catch (updateError) {
                console.error('‚ùå Error updating conversation state with category:', updateError);
                await mongoLogger.logError(updateError, {
                    source: 'category-selection-update',
                    from: from,
                    selectedCategory: selectedCategory,
                    updatePayload: updatePayload
                });
                
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, I encountered an error saving your category selection. Please try again."
                );
                return;
            }
        } else {
            console.log('‚ùå No category found for:', messageText);
            await this.whatsappService.sendMessage(
                from,
                "I didn't quite catch that. Please select a category from the list above or type the category name."
            );
        }
    }

    async sendProductSelection(from, messageId = null) {
        console.log('üö® sendProductSelection called for:', from, '- This should not be called during greeting response!');
        try {
        // Get conversation state to access selected category
        const conversationState = await conversationService.getConversationState(from);
            console.log('üìã sendProductSelection - Current conversation state:', {
                from: from,
                currentStep: conversationState?.currentStep,
                selectedCategory: conversationState?.conversationData?.selectedCategory,
                hasCategory: !!conversationState?.conversationData?.selectedCategory?.id,
                categoryId: conversationState?.conversationData?.selectedCategory?.id,
                categoryName: conversationState?.conversationData?.selectedCategory?.name,
                fullConversationData: JSON.stringify(conversationState?.conversationData, null, 2)
            });

        const selectedCategory = conversationState.conversationData?.selectedCategory;
        console.log('Selected category ', selectedCategory);

        if (!selectedCategory || !selectedCategory.id) {
                console.error('‚ùå CRITICAL: No selected category found in sendProductSelection!');
                await mongoLogger.logError(new Error('No selected category in sendProductSelection'), {
                    source: 'send-product-selection',
                    from: from,
                    conversationState: conversationState
                });
                
            await this.whatsappService.sendMessage(
                from,
                "Sorry, I couldn't find the selected category. Please start over by selecting a category."
            );
            return;
        }

        // Get products by category ID to validate against
        const allProducts = await conversationService.getProductsByCategory(selectedCategory.id);

        if (!allProducts || allProducts.length === 0) {
            await this.whatsappService.sendMessage(
                from,
                `Sorry, no products are available in the ${selectedCategory.name} category at the moment. Please try another category.`
            );
            return;
        }

        // Get all the information we have so far
        const conversationData = conversationState.conversationData || {};
        
        // Show available products with collected information
        let bodyText = `Perfect! üéØ I see you need a quote for **${selectedCategory.name}** products.\n\n`;
        
        // Show collected information if any
        let hasCollectedInfo = false;
        if ((conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) || conversationData.requestedMaterial) {
            if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
                const materialsText = conversationData.selectedMaterial
                    .map(m => m.name)
                    .join(', ');
                bodyText += `üß± **Materials:** ${materialsText}\n`;
            } else {
                bodyText += `üß± **Material:** ${conversationData.requestedMaterial}\n`;
            }
            hasCollectedInfo = true;
        }
        if (conversationData.quantity?.length > 0) {
            bodyText += `üî¢ **Quantity:** ${conversationData.quantity.join(', ')}\n`;
            hasCollectedInfo = true;
        }
        if (conversationData.dimensions?.length > 0) {
            const dimensionsText = conversationData.dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
            bodyText += `üìè **Dimensions:** ${dimensionsText}\n`;
            hasCollectedInfo = true;
        }
        if (conversationData.selectedFinish?.length > 0) {
            const finishNames = conversationData.selectedFinish.map(f => f.name).join(', ');
            bodyText += `‚ú® **Finishes:** ${finishNames}\n`;
            hasCollectedInfo = true;
        }
        
        if (hasCollectedInfo) {
            bodyText += `\n`;
        }
        
        // Show available products list
        const productList = allProducts.map((product, index) => `${index + 1}. ${product.name}`).join('\n');
        
        bodyText += `Here are the available products in **${selectedCategory.name}**:\n\n${productList}\n\nPlease select a product by:\n‚Ä¢ Typing the product name (e.g., "${allProducts[0].name}")\n‚Ä¢ Or just the number (e.g., "1" for ${allProducts[0].name})`;

        if (messageId) {
            await this.sendMessageOnce(messageId, from, bodyText);
        } else {
            await this.sendMessageFallback(from, bodyText);
        }
    } catch (error) {
        console.error('Error in sendProductSelection:', error);
        await mongoLogger.logError(error, {
            source: 'send-product-selection',
            from: from,
            selectedCategory: selectedCategory
        });
        
        await this.whatsappService.sendMessage(
            from,
            "Sorry, I encountered an error while preparing the product selection. Please try again."
        );
    }
    }

    async handleProductSelection(messageText, from) {
        try {
            // Get conversation state to access selected category
            const conversationState = await conversationService.getConversationState(from);
            const selectedCategory = conversationState.conversationData?.selectedCategory;
            const requestedProductName = conversationState.conversationData?.requestedProductName;

            if (!selectedCategory || !selectedCategory.id) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, I couldn't find the selected category. Please start over by selecting a category."
                );
                return;
            }

            // Get products by category ID
            const products = await conversationService.getProductsByCategory(selectedCategory.id);
            let selectedProduct = null;

            // Use requested product name from Wit.ai if available, otherwise use messageText
            const searchTerm = requestedProductName || messageText;
            
            console.log('üîç Product selection search details:', {
                messageText,
                requestedProductName,
                searchTerm,
                selectedCategory: selectedCategory?.name,
                hasQuantity: !!conversationState.conversationData?.quantity?.length,
                quantity: conversationState.conversationData?.quantity
            });

            // Check if the message contains quantity information but no specific product name
            const hasQuantityInfo = conversationState.conversationData?.quantity?.length > 0;
            const isGenericQuoteRequest = messageText.toLowerCase().includes('quote') && 
                                        messageText.toLowerCase().includes('qty');
            
            if (hasQuantityInfo && isGenericQuoteRequest && !requestedProductName) {
                console.log('üìã User provided quantity but no specific product, asking for product selection');
                
                // Acknowledge the quantity and ask for product selection
                const quantity = conversationState.conversationData?.quantity?.[0];
                const quantityText = quantity ? `${quantity.toLocaleString()} pieces` : 'the specified quantity';
                
                await this.whatsappService.sendMessage(
                    from,
                    `Great! I see you need a quote for ${quantityText}. Now please select a product from the ${selectedCategory.name} category:`
                );
                
                await this.sendProductSelection(from);
                return;
            }

            // Check if it's a numeric selection (e.g., "1", "2", etc.)
            const numericSelection = parseInt(searchTerm);
            if (!isNaN(numericSelection) && numericSelection > 0 && numericSelection <= products.length) {
                selectedProduct = products[numericSelection - 1];
                console.log(`üî¢ Selected product by number: ${numericSelection} -> ${selectedProduct.name}`);
            } else {
                // Check if it's a direct product ERP ID or find by name
                selectedProduct = products.find(p =>
                    p.erp_id.toString() === searchTerm ||
                    p.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }

            if (selectedProduct) {
                await conversationService.updateConversationState(from, {
                    currentStep: 'dimension_input',
                    'conversationData.selectedProduct': {
                        id: selectedProduct.erp_id.toString(),
                        erp_id: selectedProduct.erp_id,
                        name: selectedProduct.name,
                        description: selectedProduct.description,
                        basePrice: selectedProduct.basePrice,
                        dimensionFields: selectedProduct.dimensionFields
                    }
                });

                // Check if dimensions are already provided from Wit.ai
                const conversationData = conversationState.conversationData || {};
                if (conversationData.dimensions && conversationData.dimensions.length > 0) {
                    // Skip dimension input and go to material selection
                    await conversationService.updateConversationState(from, {
                        currentStep: 'material_selection'
                    });
                    await this.sendMaterialSelection(from, selectedProduct);
                } else {
                    await this.sendDimensionRequest(from, selectedProduct);
                }
            } else {
                    // Check if this looks like a quote request rather than a specific product name
                const isQuoteRequest = messageText.toLowerCase().includes('quote') || 
                                     messageText.toLowerCase().includes('need') ||
                                     messageText.toLowerCase().includes('want') ||
                                     messageText.toLowerCase().includes('get');
                
                // Also check if the message contains the category name (likely a generic request)
                const containsCategoryName = selectedCategory.name.toLowerCase().split(' ').some(word => 
                    messageText.toLowerCase().includes(word.toLowerCase())
                );
                
                if (isQuoteRequest || containsCategoryName) {
                    console.log('üéØ Detected generic quote request, showing product list');
                    
                    // Show available products list
                    if (products && products.length > 0) {
                        const productList = products.map((p, index) => `${index + 1}. ${p.name}`).join('\n');
                        
                        await this.whatsappService.sendMessage(
                            from,
                            `Great! I see you need a quote for *${selectedCategory.name}* products. üì¶\n\nHere are the available products:\n\n${productList}\n\nPlease type the name of the product you're interested in, or just the product number (e.g., "1" for ${products[0].name}).`
                        );
                    } else {
                        await this.whatsappService.sendMessage(
                            from,
                            `I understand you need a quote for ${selectedCategory.name}, but no products are available in this category at the moment. Please contact our support team.`
                        );
                    }
                } else {
                    await this.whatsappService.sendMessage(
                        from,
                        `I couldn't find a product named "${searchTerm}" in the ${selectedCategory.name} category. Please try a different product name or check the spelling.`
                    );
                }
            }
        } catch (error) {
            await mongoLogger.logError(error, { source: 'handle-product-selection' });
            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your product selection. Please try again."
            );
        }
    }

    async sendDimensionRequest(from, product) {
        const dimensionFields = product.dimensionFields || [];
        const dimensionNames = dimensionFields.map(field => field.name);

        // Get conversation state to show all collected information
        const conversationState = await conversationService.getConversationState(from);
        const conversationData = conversationState.conversationData || {};

        let message = `Perfect! You selected: **${product.name}** üìè\n\n`;
        
        // Show all collected information
        message += `Here's what I have so far:\n`;
        message += `üìÇ **Category:** ${conversationData.selectedCategory?.name || 'Not specified'}\n`;
        
        // Handle multiple materials (without showing internal ERP IDs)
        if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
            const materialsText = conversationData.selectedMaterial
                .map(m => m.name)
                .join(', ');
            message += `üß± **Materials:** ${materialsText}\n`;
        } else {
            message += `üß± **Material:** ${conversationData.requestedMaterial || 'Not specified'}\n`;
        }
        
        message += `üî¢ **Quantity:** ${conversationData.quantity?.join(', ') || 'Not specified'}\n`;
        message += `üé® **SKUs/Designs:** ${conversationData.skus || 'Not specified'}\n`;
        message += `‚ú® **Finishes:** ${conversationData.selectedFinish?.map(f => f.name).join(', ') || 'Not specified'}\n\n`;
        
        message += `Now I need the ${dimensionNames.length === 1 ? 'dimension' : 'dimensions'} for your product.\n\n`;
        
        // Create appropriate example based on the number of dimensions
        if (dimensionNames.length === 1) {
            message += `üìè **Required:** ${dimensionNames[0]} (Diameter)\n\n`;
            message += `**Examples:**\n‚Ä¢ Just one value: "5"\n‚Ä¢ With label: "${dimensionNames[0]}:5"\n\n`;
        } else if (dimensionNames.length === 2) {
            message += `üìè **Required:** ${dimensionNames.join(' x ')}\n\n`;
            message += `**Examples:**\n‚Ä¢ Two values: "${dimensionNames.map(() => '5').join(' x ')}" or "${dimensionNames.map(() => '5').join(', ')}"\n‚Ä¢ With labels: "${dimensionNames.map((name, i) => `${name}:5`).join(', ')}"\n\n`;
        } else {
            message += `üìè **Required:** ${dimensionNames.join(' x ')}\n\n`;
            message += `**Examples:**\n‚Ä¢ ${dimensionNames.length} values: "${dimensionNames.map(() => '5').join(' x ')}" or "${dimensionNames.map(() => '5').join(', ')}"\n‚Ä¢ With labels: "${dimensionNames.map((name, i) => `${name}:5`).join(', ')}"\n\n`;
        }
        
        message += `All dimensions should be in inches.`;

        await this.whatsappService.sendMessage(from, message);
    }

    async handleDimensionInput(messageText, from, conversationData, message = null) {
        try {
            // Check if we're waiting for dimension confirmation
            if (conversationData.awaitingDimensionConfirmation && conversationData.pendingDimensions) {
                const response = messageText.toLowerCase().trim();
                
                if (response.includes('yes') || response.includes('y') || response.includes('correct') || response.includes('ok')) {
                    // User confirmed the dimensions
                    const dimensions = conversationData.pendingDimensions;
                    const dimensionsList = dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
                    
                    await this.whatsappService.sendMessage(
                        from,
                        `‚úÖ Great! Confirmed dimensions: **${dimensionsList}**\n\nMoving to the next step...`
                    );
                    
                    // Update conversation state with confirmed dimensions
                    await conversationService.updateConversationState(from, {
                        'conversationData.dimensions': dimensions,
                        'conversationData.pendingDimensions': null,
                        'conversationData.awaitingDimensionConfirmation': false
                    });

                    // Move to next step
                    const nextStep = this.getNextStepAfterBypass('dimension_input', { ...conversationData, dimensions });
                    await conversationService.updateConversationState(from, {
                        currentStep: nextStep
                    });

                    // Process the next step
                    const updatedState = await conversationService.getConversationState(from);
                    await this.processConversationFlow(message, messageText, from, updatedState, false);
                    return;
                    
                } else {
                    // User wants to provide different dimensions
                    await conversationService.updateConversationState(from, {
                        'conversationData.pendingDimensions': null,
                        'conversationData.awaitingDimensionConfirmation': false
                    });
                    
                    const product = await conversationService.getProductById(conversationData.selectedProduct.id);
                    const dimensionNames = product.dimensionFields.map(f => f.name);
                    
                    await this.whatsappService.sendMessage(
                        from,
                        `No problem! Please provide the correct dimensions for **${product.name}**:\n\nRequired: **${dimensionNames.join(', ')}**\n\nFormat: **${dimensionNames.join(' x ')}** (e.g., "${dimensionNames.map(() => '5').join(' x ')}")`
                    );
                    return;
                }
            }
            
            // Check if dimensions already exist
            if (conversationData.dimensions && conversationData.dimensions.length > 0) {
                console.log("Dimensions already exist, bypassing dimension input step");

                // Bypass dimension_input and move to next step
                const nextStep = this.getNextStepAfterBypass('dimension_input', conversationData);

                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step
                const updatedState = await conversationService.getConversationState(from);
                await this.processConversationFlow(message, messageText, from, updatedState, false);
                return;
            }

            // Check if we have a selected product
            if (!conversationData.selectedProduct || !conversationData.selectedProduct.id) {
                console.log("No selected product, checking conversation state:", {
                    hasCategory: !!conversationData.selectedCategory?.id,
                    selectedCategory: conversationData.selectedCategory,
                    messageText: messageText
                });

                // Check if we have a selected category
                if (!conversationData.selectedCategory || !conversationData.selectedCategory.id) {
                    console.log("No selected category, asking for category selection");
                    await conversationService.updateConversationState(from, {
                        currentStep: 'category_selection'
                    });
                    await this.sendCategorySelection(from);
                    return;
                } else {
                    console.log("Have category, asking for product selection");
                    await this.sendProductSelection(from);
                    return;
                }
            }

            // Try to extract dimensions from the message using ChatGPT
            console.log("Attempting to extract dimensions from message:", messageText);
            
            try {
                const aiResponse = await this.aiService.processMessage(messageText);
                console.log("ChatGPT response for dimensions:", JSON.stringify(aiResponse, null, 2));

                if (aiResponse.data && aiResponse.data.entities && aiResponse.data.entities['dimensions:dimensions']) {
                    console.log("Found dimensions in ChatGPT response, processing...");
                    
                    // Extract and update conversation data with dimensions
                    const updatedData = await this.extractAndUpdateConversationData(aiResponse.data.entities, conversationData, messageText);
                    
                    if (updatedData.dimensions && updatedData.dimensions.length > 0) {
                        console.log("Successfully extracted dimensions:", updatedData.dimensions);
                        
                        // Update conversation state with dimensions (store in conversationData)
                        await conversationService.updateConversationState(from, {
                            'conversationData.dimensions': updatedData.dimensions
                        });

                        // Move to next step
                        const nextStep = this.getNextStepAfterBypass('dimension_input', updatedData);
                        await conversationService.updateConversationState(from, {
                            currentStep: nextStep
                        });

                        // Process the next step
                        const updatedState = await conversationService.getConversationState(from);
                        await this.processConversationFlow(message, messageText, from, updatedState, false);
                        return;
                    }
                }
            } catch (aiError) {
                console.log("ChatGPT extraction failed, trying manual parsing:", aiError.message);
            }

            // If ChatGPT extraction failed, try manual parsing - but only for simple dimension responses
            // Check if this looks like a complex quote request rather than a dimension response
            const quoteRequestIndicators = ['looking for', 'need', 'want', 'quote', 'pouches', 'bags', 'labels', 'standard size', 'different', 'flavors', 'designs', 'inside'];
            const isComplexQuoteRequest = quoteRequestIndicators.some(indicator => 
                messageText.toLowerCase().includes(indicator)
            );
            
            if (isComplexQuoteRequest) {
                console.log("Detected complex quote request, not parsing as dimensions:", messageText);
                // This is a quote request, not dimension input - ask for dimensions
                const product = await conversationService.getProductById(conversationData.selectedProduct.id);
                if (product && product.dimensionFields) {
                    const dimensionNames = product.dimensionFields.map(f => f.name);
                    await this.whatsappService.sendMessage(
                        from,
                        `Thank you for your quote request! üìã\n\nTo proceed, I need the dimensions for your **${product.name}**.\n\nüìè Required: **${dimensionNames.join(', ')}**\n\n*Format:* **${dimensionNames.join(' x ')}** (e.g., "${dimensionNames.map(() => '5').join(' x ')}")\n\nAll dimensions should be in inches.`
                    );
                }
                return;
            }
            
            const product = await conversationService.getProductById(conversationData.selectedProduct.id);
            if (product && product.dimensionFields) {
                const dimensionNames = product.dimensionFields.map(f => f.name);
                const dimensionValues = this.parseDimensionValues(messageText);
                
                console.log('üîç Dimension matching details:', {
                    productName: product.name,
                    requiredDimensions: dimensionNames,
                    requiredCount: dimensionNames.length,
                    providedValues: dimensionValues,
                    providedCount: dimensionValues.length,
                    messageText
                });
                
                if (dimensionValues.length > 0) {
                    console.log("Manually parsed dimensions:", dimensionValues);
                    
                    // Check if the number of provided values matches required dimensions
                    if (dimensionValues.length > dimensionNames.length) {
                        // Too many dimensions provided
                        const extraDimensions = dimensionValues.slice(dimensionNames.length);
                        await this.whatsappService.sendMessage(
                            from,
                            `I notice you provided ${dimensionValues.length} dimensions (${dimensionValues.join(', ')}), but **${product.name}** only requires **${dimensionNames.length} dimension${dimensionNames.length > 1 ? 's' : ''}**: **${dimensionNames.join(', ')}**.\n\nI'll use the first ${dimensionNames.length} value${dimensionNames.length > 1 ? 's' : ''}: **${dimensionValues.slice(0, dimensionNames.length).join(', ')}**\n\nIs this correct? Reply 'yes' to continue or provide the correct dimension${dimensionNames.length > 1 ? 's' : ''}.`
                        );
                        
                        // Use only the required number of dimensions
                        const limitedValues = dimensionValues.slice(0, dimensionNames.length);
                        const dimensions = [];
                        product.dimensionFields.forEach((field, index) => {
                            if (limitedValues[index] !== undefined) {
                                dimensions.push({
                                    name: field.name,
                                    value: limitedValues[index]
                                });
                            }
                        });
                        
                        // Store the dimensions but wait for user confirmation
                        await conversationService.updateConversationState(from, {
                            'conversationData.pendingDimensions': dimensions,
                            'conversationData.awaitingDimensionConfirmation': true
                        });
                        return;
                        
                    } else if (dimensionValues.length < dimensionNames.length) {
                        // Not enough dimensions provided
                        const missingCount = dimensionNames.length - dimensionValues.length;
                        const providedDimensionsList = dimensionNames.slice(0, dimensionValues.length).map((name, index) => 
                            `${name}: ${dimensionValues[index]}`
                        ).join(', ');
                        const missingDimensions = dimensionNames.slice(dimensionValues.length);
                        
                        await this.whatsappService.sendMessage(
                            from,
                            `I received: **${providedDimensionsList}**\n\nBut **${product.name}** needs **${missingCount} more dimension${missingCount > 1 ? 's' : ''}**: **${missingDimensions.join(', ')}**\n\nPlease provide the missing dimension${missingCount > 1 ? 's' : ''}, or provide all dimensions in this format:\n**${dimensionNames.join(' x ')}** (e.g., "${dimensionNames.map(() => '5').join(' x ')}")`
                        );
                        return;
                        
                    } else {
                        // Perfect match - correct number of dimensions
                        const dimensions = [];
                        product.dimensionFields.forEach((field, index) => {
                            if (dimensionValues[index] !== undefined) {
                                dimensions.push({
                                    name: field.name,
                                    value: dimensionValues[index]
                                });
                            }
                        });

                        if (dimensions.length > 0) {
                            console.log("Successfully parsed dimensions manually:", dimensions);
                            
                            // Send confirmation message
                            const dimensionsList = dimensions.map(d => `${d.name}: ${d.value}`).join(', ');
                            await this.whatsappService.sendMessage(
                                from,
                                `‚úÖ Perfect! I've set your dimensions: **${dimensionsList}**\n\nMoving to the next step...`
                            );
                            
                            // Update conversation state with dimensions (store in conversationData)
                            await conversationService.updateConversationState(from, {
                                'conversationData.dimensions': dimensions
                            });

                            // Move to next step
                            const nextStep = this.getNextStepAfterBypass('dimension_input', { ...conversationData, dimensions });
                            await conversationService.updateConversationState(from, {
                                currentStep: nextStep
                            });

                            // Process the next step
                            const updatedState = await conversationService.getConversationState(from);
                            await this.processConversationFlow(message, messageText, from, updatedState, false);
                            return;
                        }
                    }
                }
            }

            // If no dimensions were extracted, ask for them

            if (!product || !product.dimensionFields) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, this product doesn't have dimension requirements. Let me help you with the next step."
                );
                return;
            }

            // Ask for dimensions with product-specific dimension names
            const dimensionNames = product.dimensionFields.map(f => f.name);
            
            // Create appropriate example based on the number of dimensions
            let exampleFormat = '';
            let exampleValues = '';
            if (dimensionNames.length === 1) {
                exampleFormat = `**${dimensionNames[0]}** (e.g., "5")`;
                exampleValues = `Just one value: "5"`;
            } else if (dimensionNames.length === 2) {
                exampleFormat = `**${dimensionNames.join(' x ')}** (e.g., "5 x 8")`;
                exampleValues = `Two values: "5 x 8" or "5, 8"`;
            } else {
                exampleFormat = `**${dimensionNames.join(' x ')}** (e.g., "5 x 8 x 3")`;
                exampleValues = `${dimensionNames.length} values: "${dimensionNames.map(() => '5').join(' x ')}" or "${dimensionNames.map(() => '5').join(', ')}"`;
            }

            await this.whatsappService.sendMessage(
                from,
                `Please provide the ${dimensionNames.length === 1 ? 'dimension' : 'dimensions'} for your **${product.name}**:\n\nüìè **Required:** ${exampleFormat}\n\n**Examples:**\n‚Ä¢ ${exampleValues}\n‚Ä¢ With labels: "${dimensionNames.map((name, i) => `${name}:5`).join(', ')}"\n\nAll dimensions should be in inches.`
            );
        } catch (error) {
            console.error('Error in handleDimensionInput:', error);
            await mongoLogger.logError(error, {
                source: 'dimension-input-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your dimensions. Please try again."
            );
        }
    }

    async sendMaterialSelection(from, selectedProduct) {
        const product = await conversationService.getProductById(selectedProduct.id);
        
        // Get current conversation data to show what we already have
        const conversationState = await conversationService.getConversationState(from);
        const conversationData = conversationState.conversationData || {};

        const sections = [{
            title: "Available Materials",
            rows: product.availableMaterials.map(material => ({
                id: material.name,
                title: material.name,
                description: `${material.description} - $${material.pricePerUnit}/unit`
            }))
        }];

        // Build acknowledgment message with collected details
        let acknowledgmentText = "Great! I have the following details from your message:\n\n";
        
        if (conversationData.selectedProduct) {
            acknowledgmentText += `‚Ä¢ Product: ${conversationData.selectedProduct.name}\n`;
        }
        
        if (conversationData.quantity && conversationData.quantity.length > 0) {
            const quantity = conversationData.quantity[0];
            acknowledgmentText += `‚Ä¢ Quantity: ${quantity.toLocaleString()} pieces\n`;
        }
        
        if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
            const finishNames = conversationData.selectedFinish.map(f => f.name).join(', ');
            acknowledgmentText += `‚Ä¢ Finishes: ${finishNames}\n`;
        }
        
        if (conversationData.skus) {
            acknowledgmentText += `‚Ä¢ SKUs: ${conversationData.skus}\n`;
        }
        
        acknowledgmentText += `\nNow please select the material for your ${product.name}:`;

        await this.whatsappService.sendListMessage(
            from,
            acknowledgmentText,
            "Select Material",
            sections
        );
    }

    async sendMaterialRequest(from, selectedCategory) {
        try {
            const category = await this.findCategoryById(selectedCategory.id);

            if (!category) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, category not found. Please try again."
                );
                return;
            }

            // Fetch materials for this category from Material model
            const materials = await Material.find({
                categoryId: selectedCategory.id,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!materials || materials.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no materials are available for this category. Please contact support."
                );
                return;
            }

            // Get conversation state to show all collected information
            const conversationState = await conversationService.getConversationState(from);
            const conversationData = conversationState.conversationData || {};

            let message = `Great! Now please select the material for your ${category.name} products.\n\n`;
            
            // Show all collected information
            message += `Here's what I have so far:\n`;
            message += `üìÇ **Category:** ${conversationData.selectedCategory?.name || 'Not specified'}\n`;
            message += `üîß **Product:** ${conversationData.selectedProduct?.name || 'Not specified'}\n`;
            message += `üî¢ **Quantity:** ${conversationData.quantity?.join(', ') || 'Not specified'}\n`;
            message += `üìè **Dimensions:** ${conversationData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'Not specified'}\n`;
            message += `üé® **SKUs/Designs:** ${conversationData.skus || 'Not specified'}\n`;
            message += `‚ú® **Finishes:** ${conversationData.selectedFinish?.map(f => f.name).join(', ') || 'Not specified'}\n\n`;
            message += `Type your material name.`;

            await this.whatsappService.sendMessage(from, message);
        } catch (error) {
            console.error('Error in sendMaterialRequest:', error);
            await mongoLogger.logError(error, {
                source: 'send-material-request',
                from: from
            });

            await this.whatsappService.sendMessage(
                from,
                "Please type the name of the material you want to use."
            );
        }
    }

    async sendFinishRequest(from, conversationData) {
        try {
            const category = await this.findCategoryById(conversationData.selectedCategory.id);

            if (!category) {
                await this.sendCategorySelection(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'category_selection'
                });
                return;
            }
            const product = await conversationService.getProductById(conversationData.selectedProduct.id);
            console.log("product111111111 ", product);

            if (!product) {
                await this.sendProductSelection(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'product_selection'
                });
                return;
            }

            // Fetch finishes for this category from ProductFinish model
            const finishes = await ProductFinish.find({
                productCategoryId: conversationData.selectedCategory.id,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!finishes || finishes.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no finishes are available for this category. Please contact support."
                );
                return;
            }

            await this.whatsappService.sendMessage(
                from,
                `Great! Now please select the finishes for your ${product.name} product.\n\nType your finish names.`
            );
        } catch (error) {
            console.error('Error in sendFinishRequest:', error);
            await mongoLogger.logError(error, {
                source: 'send-finish-request',
                from: from
            });

            await this.whatsappService.sendMessage(
                from,
                "Please type the name of the finish you want to use."
            );
        }
    }

    async handleMaterialSelection(messageText, from, conversationData) {
        try {
            console.log('üîß handleMaterialSelection called:', {
                messageText,
                hasSelectedMaterial: !!(conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0),
                selectedMaterial: conversationData.selectedMaterial,
                selectedMaterialKeys: Object.keys(conversationData.selectedMaterial || {}),
                selectedMaterialName: conversationData.selectedMaterial?.name,
                selectedCategory: conversationData.selectedCategory?.name
            });
            
            // Check if this message looks like a dimension input (e.g., "8x9", "5x5x5")
            const isDimensionMessage = this.isDimensionMessage(messageText);
            
            // Check if we already have material selected
            const hasMaterial = conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0;
            
            // If message looks like dimensions (transitioning from dimension_input step), ask for material
            if (isDimensionMessage) {
                console.log('üéØ Detected dimension message in material selection step, asking for material:', messageText);
                await this.sendMaterialRequest(from, conversationData.selectedCategory);
                return;
            }
            
            // If we already have material, we shouldn't be here - move to next step
            if (hasMaterial) {
                console.log('üéØ Material already selected, moving to next step');
                const nextStep = this.getNextStepAfterBypass('material_selection', conversationData);
                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'material-bypass-' + Date.now() };
                await this.processConversationFlow(mockMessage, messageText, from, updatedState);
                return;
            }

            // User has provided material, process it
            const category = await this.findCategoryById(conversationData.selectedCategory.id);

            if (!category) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, category not found. Please try again."
                );
                return;
            }

            // Fetch materials for this category from Material model
            const materials = await Material.find({
                categoryId: conversationData.selectedCategory.id,
                isActive: true
            }).sort({ sortOrder: 1, name: 1 });

            if (!materials || materials.length === 0) {
                await this.whatsappService.sendMessage(
                    from,
                    "Sorry, no materials are available for this category. Please try again."
                );
                return;
            }

            // Find matching material with improved matching logic
            let selectedMaterial = null;
            
            // First check if user sent a number (list position)
            const trimmedText = messageText.trim();
            const listPosition = parseInt(trimmedText);
            
            if (!isNaN(listPosition) && listPosition >= 1 && listPosition <= materials.length) {
                // User selected by number (1-based indexing)
                selectedMaterial = materials[listPosition - 1];
                console.log(`üî¢ User selected material by number ${listPosition}: ${selectedMaterial.name}`);
            } else {
                // Special handling for "metallized" - map to MPET materials
                if (messageText.toLowerCase().includes('metallized') || messageText.toLowerCase().includes('metallic')) {
                    console.log('üéØ Special handling for metallized material request');
                    
                    // Look for materials containing MPET in order of preference
                    const mpetMaterials = [
                        'PET +  MPET + PE',  // Exact match from logs
                        'PET + MPET + PE',   // Without extra spaces
                        'Kraft + MPET +PE',  // Alternative
                    ];
                    
                    for (const preferredMaterial of mpetMaterials) {
                        selectedMaterial = materials.find(m => 
                            m.name.toLowerCase() === preferredMaterial.toLowerCase()
                        );
                        if (selectedMaterial) {
                            console.log(`üéØ Mapped "metallized" to: ${selectedMaterial.name}`);
                            break;
                        }
                    }
                    
                    // If exact names don't match, look for any material containing MPET
                    if (!selectedMaterial) {
                        selectedMaterial = materials.find(m => 
                            m.name.toLowerCase().includes('mpet')
                        );
                        if (selectedMaterial) {
                            console.log(`üéØ Mapped "metallized" to MPET material: ${selectedMaterial.name}`);
                        }
                    }
                }
                
                // Try exact match first in category materials (if not already found above)
                if (!selectedMaterial) {
                    selectedMaterial = materials.find(m =>
                        m.name.toLowerCase() === messageText.toLowerCase()
                    );
                }
                
                // If no exact match, try partial matching in category materials
                if (!selectedMaterial) {
                    selectedMaterial = materials.find(m =>
                        m.name.toLowerCase().includes(messageText.toLowerCase()) ||
                        messageText.toLowerCase().includes(m.name.toLowerCase())
                    );
                }
                
                // Try matching individual words for complex descriptions in category materials
                if (!selectedMaterial) {
                    const messageWords = messageText.toLowerCase().split(/[\s,+\-_]+/).filter(word => word.length > 2);
                    selectedMaterial = materials.find(m => {
                        const materialWords = m.name.toLowerCase().split(/[\s,+\-_]+/).filter(word => word.length > 2);
                        return messageWords.some(msgWord => 
                            materialWords.some(matWord => 
                                msgWord.includes(matWord) || matWord.includes(msgWord)
                            )
                        );
                    });
                }
                
                // If still not found in category materials, make one more attempt within the category
                if (!selectedMaterial) {
                    console.log(`üîç Material not found in category, doing advanced search within category for: ${messageText}`);
                    selectedMaterial = await this.findMaterialByName(messageText, conversationData.selectedCategory.id);
                    
                    if (selectedMaterial) {
                        console.log(`üéØ Found material across all materials: ${selectedMaterial.name}`);
                        // Convert to the expected format to match category materials structure
                        selectedMaterial = {
                            _id: selectedMaterial._id,
                            name: selectedMaterial.name,
                            erp_id: selectedMaterial.erp_id,
                            description: selectedMaterial.description
                        };
                    }
                }
            }
            
            console.log('üîç Material search result:', {
                searchTerm: messageText,
                foundMaterial: selectedMaterial ? selectedMaterial.name : 'Not found',
                availableMaterials: materials.map(m => m.name)
            });

            if (selectedMaterial) {
                console.log("selectedMaterial ", selectedMaterial);
                
                // Send confirmation message
                await this.whatsappService.sendMessage(
                    from,
                    `‚úÖ Great! I've selected *${selectedMaterial.name}* as your material.\n\nMoving to the next step...`
                );
                
                // Update conversation data with selected material as array
                await conversationService.updateConversationState(from, {
                    'conversationData.selectedMaterial': [{
                        _id: selectedMaterial.erp_id.toString(),
                        name: selectedMaterial.name,
                        erp_id: selectedMaterial.erp_id
                    }]
                });

                // Bypass material_selection and move to next step
                const nextStep = this.getNextStepAfterBypass('material_selection', {
                    ...conversationData,
                    selectedMaterial: [{
                        _id: selectedMaterial.erp_id.toString(),
                        name: selectedMaterial.name,
                        erp_id: selectedMaterial.erp_id
                    }]
                });

                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step
                const updatedState = await conversationService.getConversationState(from);
                const mockMessage = { id: 'material-found-' + Date.now() };
                await this.processConversationFlow(mockMessage, messageText, from, updatedState);
            } else {
                // Material not found - show available materials instead of creating custom ones
                console.log(`‚ùå Material "${messageText}" not found in database, showing available options`);
                
                // Format available materials list
                const materialsList = materials.map((material, index) => 
                    `${index + 1}. ${material.name}`
                ).join('\n');
                
                // Send message with available materials
                await this.whatsappService.sendMessage(
                    from,
                    `‚ùå I couldn't find "${messageText}" in our materials database.

Here are the available materials for ${category.name}:

${materialsList}

Please select a material by:
‚Ä¢ Typing the exact material name
‚Ä¢ Or typing the number (e.g., "1" for ${materials[0]?.name || 'first option'})

*Note: We only use materials from our database to ensure accurate pricing and availability.*`
                );
                return; // Don't proceed to next step
            }
        } catch (error) {
            console.error('Error in handleMaterialSelection:', error);
            await mongoLogger.logError(error, {
                source: 'material-selection-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your material selection. Please try again."
            );
        }
    }

    async sendFinishSelection(from, selectedProduct) {
        const product = await conversationService.getProductById(selectedProduct.id);

        const sections = [{
            title: "Available Finishes",
            rows: product.availableFinishes.map(finish => ({
                id: finish.name,
                title: finish.name,
                description: `${finish.description} - $${finish.pricePerUnit}/unit`
            }))
        }];

        const bodyText = `Excellent! Now please select the finish for your mylar bags:`;

        await this.whatsappService.sendListMessage(
            from,
            bodyText,
            "Select Finish",
            sections
        );
    }

    async handleFinishSelection(messageText, from, conversationData) {
        try {
            // Check if finishes already exist
            if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
                console.log("Finishes already exist, bypassing finish selection step");

                // Bypass finish_selection and move to next step
                const nextStep = this.getNextStepAfterBypass('finish_selection', conversationData);

                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step
                const updatedState = await conversationService.getConversationState(from);
                await this.processConversationFlow(message, messageText, from, updatedState, false);
                return;
            }

            // Check if we have a selected product
            if (!conversationData.selectedProduct || !conversationData.selectedProduct.id) {
                console.log("No selected product, asking for product selection");
                await this.sendProductSelection(from);
                return;
            }
            console.log("sending Finish Request",);

            // We have a product, ask for finishes
            await this.sendFinishRequest(from, conversationData);
        } catch (error) {
            console.error('Error in handleFinishSelection:', error);
            await mongoLogger.logError(error, {
                source: 'finish-selection-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your finish selection. Please try again."
            );
        }
    }

    async sendQuantityRequest(from) {
        const message = `Almost done! üìä

Please tell me the quantity of mylar bags you need:

Examples:
‚Ä¢ "500 pieces"
‚Ä¢ "1000"
‚Ä¢ "2500 bags"

What quantity would you like?`;

        await this.whatsappService.sendMessage(from, message);
    }

    async handleQuantityInput(messageText, from, conversationData) {
        try {
            // Check if quantity already exists
            if (conversationData.quantity && conversationData.quantity.length > 0) {
                console.log("Quantity already exists, bypassing quantity input step");

                // Bypass quantity_input and move to next step
                const nextStep = this.getNextStepAfterBypass('quantity_input', conversationData);

                await conversationService.updateConversationState(from, {
                    currentStep: nextStep
                });

                // Process the next step
                const updatedState = await conversationService.getConversationState(from);
                await this.processConversationFlow(message, messageText, from, updatedState, false);
                return;
            }

            // Check if we have all required data for quote generation
            if (!conversationData.selectedProduct || !conversationData.selectedMaterial ||
                !conversationData.selectedFinish || conversationData.selectedFinish.length === 0) {
                console.log("Missing required data for quote generation");

                // Guide user to complete missing steps
                if (!conversationData.selectedProduct) {
                    await this.sendProductSelection(from);
                    return;
                }
                if (!conversationData.selectedMaterial) {
                    await this.sendMaterialRequest(from, conversationData.selectedCategory);
                    return;
                }
                if (!conversationData.selectedFinish || conversationData.selectedFinish.length === 0) {
                    await this.sendFinishRequest(from, conversationData);
                    return;
                }
            }

            // We have all required data, ask for quantity
            await this.sendQuantityRequest(from);
        } catch (error) {
            console.error('Error in handleQuantityInput:', error);
            await mongoLogger.logError(error, {
                source: 'quantity-input-handler',
                from: from,
                messageText: messageText
            });

            await this.whatsappService.sendMessage(
                from,
                "Sorry, I encountered an error processing your quantity. Please try again."
            );
        }
    }

    async handleQuoteGeneration(messageText, from, conversationData, message) {
        console.log("conversationData111111111 ", conversationData);
        try {
            // Check if this looks like a dimension message (e.g., "5x5x5", "10,8,3", etc.)
            const isDimensionMessage = this.isDimensionMessage(messageText);
            if (isDimensionMessage && (!conversationData.dimensions || conversationData.dimensions.length === 0)) {
                console.log("Detected dimension message in quote generation, processing as dimensions");
                
                // Get the product to know what dimensions are needed
                const product = conversationData.selectedProduct;
                if (product && product.dimensionFields) {
                    const dimensionNames = product.dimensionFields.map(f => f.name);
                    const parsedDimensions = await this.parseDimensionsManually(messageText, dimensionNames);
                    
                    if (parsedDimensions.length > 0) {
                        console.log("Successfully parsed dimensions from quote generation:", parsedDimensions);
                        
                        // Update conversation state with dimensions (store in conversationData)
                        await conversationService.updateConversationState(from, {
                            'conversationData.dimensions': parsedDimensions
                        });
                        
                        // Verify dimensions were stored
                        const verifyState = await conversationService.getConversationState(from);
                        console.log('üîç Dimensions after storage:', verifyState.conversationData?.dimensions);
                        
                        // Move back to quote generation to continue
                        await conversationService.updateConversationState(from, {
                            currentStep: 'quote_generation'
                        });
                        
                        // Verify dimensions are still there after step update
                        const finalState = await conversationService.getConversationState(from);
                        console.log('üîç Dimensions after step update:', finalState.conversationData?.dimensions);
                        
                        // Process the next step
                        const updatedState = await conversationService.getConversationState(from);
                        await this.processConversationFlow(message, messageText, from, updatedState, false);
                        return;
                    }
                }
            }
            
            // Set default SKU value if not provided
            if (!conversationData.skus) {
                await conversationService.updateConversationState(from, {
                    'conversationData.skus': 1
                });
                // Update local reference
                conversationData.skus = 1;
            }

            // Validate required data before showing acknowledgment
            const validationResult = this.validateQuoteData(conversationData);
            if (!validationResult.isValid) {
                console.log("Missing required data for quote generation:", validationResult.missingFields);
                
                // Send helpful message about what's missing
                const missingMessage = `I need more information to generate your quote. Please provide:\n\n${validationResult.missingFields.join('\n')}\n\nLet's go back and collect this information.`;
                
                await this.whatsappService.sendMessage(from, missingMessage);
                
                // Reset to appropriate step based on what's missing
                const resetStep = this.getResetStepForMissingData(validationResult.missingFields, conversationData);
                await conversationService.updateConversationState(from, {
                    currentStep: resetStep,
                    'conversationData.quoteAcknowledged': false // Reset acknowledgment so user gets fresh confirmation when data is complete
                });
                
                return;
            }

            // Check if this is the first time in quote generation (acknowledge selections)
            if (!conversationData.quoteAcknowledged) {
                // Format the acknowledgment message
                const categoryName = conversationData.selectedCategory?.name || 'Not specified';
                const productName = conversationData.selectedProduct?.name || 'Not specified';
                // Format materials (without showing internal ERP IDs)
                const materialName = (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) 
                    ? conversationData.selectedMaterial.map(m => m.name).join(', ')
                    : conversationData.requestedMaterial || 'Not specified';

                // Format finishes
                const finishNames = conversationData.selectedFinish?.map(f => f.name).join(', ') || 'Not specified';

                // Format dimensions
                const dimensionsText = conversationData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'Not specified';

                // Format quantities
                const quantitiesText = conversationData.quantity?.join(', ') || 'Not specified';

                // Format SKUs - default to 1 if not specified
                const skusText = conversationData.skus ? conversationData.skus.toString() : '1';

                const acknowledgmentMessage = `Perfect! üéØ Let me confirm your selections:

üì¶ **Category:** ${categoryName}
üîß **Product:** ${productName}
üß± **Materials:** ${materialName}
‚ú® **Finishes:** ${finishNames}
üìè **Dimensions:** ${dimensionsText}
üî¢ **Quantities:** ${quantitiesText}
üé® **SKUs/Designs:** ${skusText}

Based on the information you've provided, would you like me to generate pricing for your quote? 

Please reply with "Yes" to get pricing details, or "No" if you'd like to make any changes.`;

                await this.sendMessageOnce(
                    message?.id || 'auto-generated-' + Date.now(),
                    from,
                    acknowledgmentMessage
                );

                // Mark as acknowledged and wait for response
                await conversationService.updateConversationState(from, {
                    'conversationData.quoteAcknowledged': true
                });

            } else {
                // Process user's response
                const response = messageText.toLowerCase().trim();
                const safeMessageId = message?.id || 'quote-response-' + Date.now();
                
                console.log(`üéØ Processing user response: "${response}"`);
                console.log(`üéØ pricing_done: ${conversationData.pricing_done}, wantsPdf: ${conversationData.wantsPdf}`);
                console.log(`üéØ pricing_done type: ${typeof conversationData.pricing_done}`);
                console.log(`üéØ Condition 1 (pricing_done && !wantsPdf): ${conversationData.pricing_done && !conversationData.wantsPdf}`);
                console.log(`üéØ Condition 2 (!pricing_done): ${!conversationData.pricing_done}`);

                // Check if user is responding to document request after pricing is done
                if (conversationData.pricing_done && !conversationData.wantsPdf) {
                    if (response.includes('pdf') || response.includes('yes') || response.includes('generate')) {
                        // Check if already completed to prevent duplicate processing
                        if (conversationData.completed) {
                            console.log(`‚è≠Ô∏è Conversation already completed for ${from}, skipping duplicate PDF generation`);
                            return;
                        }

                        // User wants PDF, generate and send it
                        await conversationService.updateConversationState(from, {
                            'conversationData.wantsPdf': true
                        });

                        await this.generateAndSendPDF(from, conversationData, safeMessageId);
                        
                        // Send completion message
                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            `‚úÖ **Quote Complete!** 

Thank you for using our quote system! Your PDF quote has been generated and sent.

Need another quote? Just say "Hi" or "New Quote" anytime! üåü`
                        );

                        // Mark as fully completed
                        await conversationService.updateConversationState(from, {
                            'conversationData.completed': true,
                            currentStep: 'completed',
                            isActive: false
                        });

                    } else if (response.includes('no') || response.includes('n') || response.includes('not')) {
                        // Check if already completed to prevent duplicate processing
                        if (conversationData.completed) {
                            console.log(`‚è≠Ô∏è Conversation already completed for ${from}, skipping duplicate completion`);
                            return;
                        }

                        // User doesn't want PDF, end conversation
                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            `‚úÖ **Quote Complete!** 

Thank you for using our quote system! 

Need another quote? Just say "Hi" or "New Quote" anytime! üåü`
                        );

                        // Mark as completed without PDF
                        await conversationService.updateConversationState(from, {
                            'conversationData.completed': true,
                            currentStep: 'completed',
                            isActive: false
                        });
                    } else {
                        // Unclear response to document question
                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            `üìÑ Would you like me to generate a PDF quote for you?\n\n‚Ä¢ Reply "Yes" or "PDF" to get your quote\n‚Ä¢ Reply "No" to finish without the document`
                        );
                    }
                } else if (!conversationData.pricing_done) {
                    console.log(`üéØ Taking pricing branch - pricing not done yet`);
                    // Check if user is providing additional information (like SKUs) before confirming
                    if (messageText.toLowerCase().includes('sku') && !response.includes('yes') && !response.includes('no')) {
                        // Extract SKU information
                        const skuMatch = messageText.match(/sku\s*(?:is\s*)?(\d+)/i);
                        if (skuMatch) {
                            const skuValue = parseInt(skuMatch[1]);
                            
                            // Update conversation data with SKU
                            await conversationService.updateConversationState(from, {
                                'conversationData.skus': skuValue
                            });
                            
                            // Re-send confirmation with updated information
                            const updatedState = await conversationService.getConversationState(from);
                            const updatedData = updatedState.conversationData;
                            
                            // Format the updated acknowledgment message
                            const categoryName = updatedData.selectedCategory?.name || 'Not specified';
                            const productName = updatedData.selectedProduct?.name || 'Not specified';
                            const materialName = (updatedData.selectedMaterial && updatedData.selectedMaterial.length > 0) 
                                ? updatedData.selectedMaterial.map(m => m.name).join(', ')
                                : updatedData.requestedMaterial || 'Not specified';
                            const finishNames = updatedData.selectedFinish?.map(f => f.name).join(', ') || 'Not specified';
                            const dimensionsText = updatedData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'Not specified';
                            const quantitiesText = updatedData.quantity?.join(', ') || 'Not specified';
                            const skusText = updatedData.skus ? updatedData.skus.toString() : '1';

                            const updatedAcknowledgmentMessage = `Perfect! üéØ Let me confirm your updated selections:

üì¶ **Category:** ${categoryName}
üîß **Product:** ${productName}
üß± **Materials:** ${materialName}
‚ú® **Finishes:** ${finishNames}
üìè **Dimensions:** ${dimensionsText}
üî¢ **Quantities:** ${quantitiesText}
üé® **SKUs/Designs:** ${skusText}

Based on the information you've provided, would you like me to generate pricing for your quote? 

Please reply with "Yes" to get pricing details, or "No" if you'd like to make any changes.`;

                            await this.sendMessageOnce(
                                safeMessageId,
                                from,
                                updatedAcknowledgmentMessage
                            );
                            return;
                        }
                    }
                    
                    // User is responding to initial pricing question
                    console.log(`üîç Checking pricing response: "${response}" vs "yes"`);
                    console.log(`üîç pricing_done: ${conversationData.pricing_done}, includes yes: ${response.includes('yes')}`);
                    if (response.includes('yes') || response.includes('y') || response.includes('sure') || response.includes('ok')) {
                        // User wants pricing, generate and send quote
                        try {
                            console.log("User wants pricing, calling getPricingForQuote...");
                            const pricing = await this.getPricingForQuote(conversationData);
                            console.log("Pricing result:", pricing);

                            if (pricing && !pricing.error) {
                                // Store pricing in conversation data
                                await conversationService.updateConversationState(from, {
                                   
                                    'conversationData.pricingData': pricing,
                                    'conversationData.pricing_done': true
                                });

                                // Send beautiful pricing table
                                await this.sendPricingTable(from, conversationData, pricing, safeMessageId);
                            } else {
                                // Handle pricing error
                                await this.sendMessageOnce(
                                    safeMessageId,
                                    from,
                                    "Sorry, I couldn't get pricing information at the moment. Please try again later or contact our support team."
                                );
                            }
                        } catch (pricingError) {
                            console.error("Error in pricing generation:", pricingError);
                            await mongoLogger.logError(pricingError, {
                                source: 'pricing-generation',
                                from: from,
                                conversationData: conversationData
                            });
                            
                            await this.sendMessageOnce(
                                safeMessageId,
                                from,
                                "Sorry, I encountered an error generating your pricing. Please try again later or contact our support team."
                            );
                        }
                    } else if (response.includes('no') || response.includes('n') || response.includes('not')) {
                        // User doesn't want pricing, end conversation gracefully
                        const goodbyeMessage = `No problem! üòä 

I'm always here to help you whenever you need a quote. Just say "Hi" or "Get Quote" anytime you're ready, and I'll be happy to assist you with pricing for your products.

Have a great day! üåü`;

                        await this.sendMessageOnce(
                            safeMessageId,
                            from,
                            goodbyeMessage
                        );

                        // Inactivate conversation
                        await conversationService.updateConversationState(from, {
                            currentStep: 'completed',
                            isActive: false,
                            'conversationData.completed': true
                        });

                    } else {
                        // Unclear response - check if they're trying to provide additional information
                        if (messageText.length > 2 && (messageText.toLowerCase().includes('sku') || 
                            messageText.toLowerCase().includes('design') || 
                            messageText.toLowerCase().includes('quantity') ||
                            messageText.toLowerCase().includes('material') ||
                            messageText.toLowerCase().includes('finish'))) {
                            
                            await this.sendMessageOnce(
                                message.id,
                                from,
                                "I see you want to update some information. To make changes, please reply with 'No' and I'll help you update your quote details. Or reply with 'Yes' to proceed with the current information for pricing."
                            );
                        } else {
                            // Unclear response, ask for clarification
                            await this.sendMessageOnce(
                                message.id,
                                from,
                                "I didn't quite catch that. Please reply with 'Yes' if you'd like pricing details, or 'No' if you'd like to make changes."
                            );
                        }
                    }
                } else {
                    console.log(`üéØ Taking fallback branch - pricing done but unclear response`);
                    // Unclear response, ask for clarification
                    await this.sendMessageOnce(
                        message.id,
                        from,
                        "I didn't quite catch that. Please reply with 'Yes' if you'd like pricing details, or 'No' if you'd like to make changes."
                    );
                }
            }

        } catch (error) {
            console.error('Error in handleQuoteGeneration:', error);
            await mongoLogger.logError(error, {
                source: 'quote-generation-handler',
                from: from,
                messageText: messageText
            });

            await this.sendMessageOnce(
                message?.id || 'error-response-' + Date.now(),
                from,
                "Sorry, I encountered an error processing your request. Please try again or type 'hi' to restart."
            );
        }
    }

    async getPricingForQuote(conversationData) {
        try {
            console.log("getPricingForQuote - conversationData:", JSON.stringify(conversationData, null, 2));
            
            // Prepare the payload for the pricing API
            const payload = {
                file_type: conversationData.selectedCategory?.erp_id?.toString() || "1",
                product_id: conversationData.selectedProduct?.erp_id,
                material_id: conversationData.selectedMaterial?.[0]?.erp_id,
                finishes: conversationData.selectedFinish?.map(finish => {
                    console.log("Processing finish:", finish);
                    const finishId = parseInt(finish._id);
                    if (isNaN(finishId)) {
                        console.error("Invalid finish ID:", finish._id);
                        throw new Error(`Invalid finish ID: ${finish._id}`);
                    }
                    return {
                        id: finishId,
                        value: null
                    };
                }) || [],
                quantities: conversationData.quantity || [],
                dimensions: conversationData.dimensions?.map(dim => dim.value) || []
            };


            console.log("payload", payload);
            console.log("Pricing API Payload:", JSON.stringify(payload, null, 2));

            // Make API call to get pricing
            console.log("Making API call to:", `${process.env.ERP_API_BASE_URL}/api/get-quote-price-for-whatsapp`);
            
            const response = await fetch(`${process.env.ERP_API_BASE_URL}/api/get-quote-price-for-whatsapp`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // 'Authorization': `Bearer ${process.env.PRICING_API_TOKEN || ''}`,
                    // Add any other required headers
                },
                body: JSON.stringify(payload)
            });

            console.log("API Response status:", response.status, response.statusText);

            if (!response.ok) {
                const errorText = await response.text();
                console.error("API Error Response:", errorText);
                throw new Error(`Pricing API error: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const pricingData = await response.json();
            console.log("Pricing API Response:", pricingData);

            return pricingData;

        } catch (error) {
            console.error('Error getting pricing for quote:', error);
            await mongoLogger.logError(error, {
                source: 'pricing-api-call',
                conversationData: conversationData
            });
            
            // Return a default pricing structure or null
            return {
                error: true,
                message: 'Failed to get pricing information',
                details: error.message
            };
        }
    }

    async sendPricingTable(from, conversationData, pricingData, messageId = null) {
        try {
            const { qty, unit_cost } = pricingData;
            
            // Create beautiful pricing table
            let pricingMessage = `üéâ **Your Quote is Ready!** üéâ\n\n`;
            
            // Add product details
            pricingMessage += `üì¶ **Product:** ${conversationData.selectedProduct?.name || 'N/A'}\n`;
            if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
                const materialsText = conversationData.selectedMaterial
                    .map(m => m.name)
                    .join(', ');
                pricingMessage += `üß± **Materials:** ${materialsText}\n`;
            } else {
                pricingMessage += `üß± **Material:** ${conversationData.requestedMaterial || 'N/A'}\n`;
            }
            pricingMessage += `‚ú® **Finishes:** ${conversationData.selectedFinish?.map(f => f.name).join(', ') || 'N/A'}\n`;
            pricingMessage += `üìè **Dimensions:** ${conversationData.dimensions?.map(d => `${d.name}: ${d.value}`).join(', ') || 'N/A'}\n\n`;
            
            // Create pricing table
            pricingMessage += `üí∞ **PRICING BREAKDOWN**\n`;
            pricingMessage += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n`;
            pricingMessage += `‚îÇ    Tier     ‚îÇ  Quantity   ‚îÇ Unit Price  ‚îÇ\n`;
            pricingMessage += `‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n`;
            
            // Add each tier
            qty.forEach((quantity, index) => {
                const tier = index + 1;
                const unitPrice = unit_cost[index];
                const totalPrice = (quantity * unitPrice).toFixed(2);
                
                pricingMessage += `‚îÇ   Tier ${tier}    ‚îÇ   ${quantity.toLocaleString()}   ‚îÇ   $${unitPrice.toFixed(3)}   ‚îÇ\n`;
            });
            
            pricingMessage += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n`;
            
            // Add total calculation for each tier
            pricingMessage += `üìä **TOTAL COST BY TIER**\n`;
            qty.forEach((quantity, index) => {
                const tier = index + 1;
                const unitPrice = unit_cost[index];
                const totalPrice = (quantity * unitPrice).toFixed(2);
                
                pricingMessage += `Tier ${tier}: ${quantity.toLocaleString()} units √ó $${unitPrice.toFixed(3)} = **$${totalPrice}**\n`;
            });
            
            pricingMessage += `\n‚ú® **Best Value:** Tier ${qty.length} at $${unit_cost[qty.length - 1].toFixed(3)} per unit\n\n`;
            
            // Ask for PDF quote
            pricingMessage += `üìÑ Would you like me to generate a detailed PDF quote for your records?\n\n`;
            pricingMessage += `‚Ä¢ Reply "Yes" or "PDF" to get your quote document\n`;
            pricingMessage += `‚Ä¢ Reply "No" to finish without the document`;

            if (messageId) {
                await this.sendMessageOnce(messageId, from, pricingMessage);
            } else {
                await this.whatsappService.sendMessage(from, pricingMessage);
            }

        } catch (error) {
            console.error('Error sending pricing table:', error);
            await mongoLogger.logError(error, {
                source: 'pricing-table-sender',
                from: from,
                pricingData: pricingData
            });

            // Fallback message
            await this.whatsappService.sendMessage(
                from,
                "Here's your pricing information:\n\n" +
                `Quantities: ${pricingData.qty.join(', ')}\n` +
                `Unit Costs: $${pricingData.unit_cost.join(', $')}\n\n` +
                "üìÑ Would you like a PDF quote?\n" +
                "‚Ä¢ Reply 'Yes' or 'PDF' for your quote\n" +
                "‚Ä¢ Reply 'No' to finish"
            );
        }
    }

    async generateAndSendPSF(from, conversationData, messageId = null) {
        try {
            console.log("Generating PSF for:", from);
            console.log("Conversation data for PSF:", JSON.stringify(conversationData, null, 2));
            
            // Create PSF document using PDFKit
            console.log("Creating PSF document...");
            const psfBuffer = await this.createPSFDocument(conversationData);
            console.log("PSF document created, buffer size:", psfBuffer.length);
            
            // For Vercel compatibility, try buffer approach first
            try {
                console.log("Attempting to send PSF via buffer...");
                // Send PSF directly from buffer (Vercel-friendly)
                await this.whatsappService.sendDocument(from, {
                    buffer: psfBuffer,
                    filename: `PSF_${Date.now()}.pdf`,
                    caption: "üìã Here's your Product Specification Form (PSF)!"
                });
                
                console.log("PSF sent successfully via buffer to:", from);
                
            } catch (bufferError) {
                console.error("Buffer upload failed:", bufferError);
                console.log("Trying file approach...");
                
                // Fallback to file approach
                const tempPath = await this.createTempPDF(psfBuffer, from, 'PSF');
                console.log("Temp PSF created at:", tempPath);
                
                // Send PSF via WhatsApp
                await this.whatsappService.sendDocument(from, {
                    link: tempPath,
                    filename: `PSF_${Date.now()}.pdf`,
                    caption: "üìã Here's your Product Specification Form (PSF)!"
                });
                
                console.log("PSF sent successfully via file to:", from);
            }
            
        } catch (error) {
            console.error('Error generating/sending PSF:', error);
            await mongoLogger.logError(error, {
                source: 'psf-generation',
                from: from
            });
            
            // Fallback message
            await this.sendMessageOnce(
                messageId || 'psf-error',
                from,
                "Sorry, I couldn't generate the PSF at the moment. However, you have all the product specification information above. Please contact our support if you need assistance."
            );
        }
    }

    async generateAndSendPDF(from, conversationData, messageId = null) {
        try {
            console.log("Generating PDF for:", from);
            console.log("Conversation data for PDF:", JSON.stringify(conversationData, null, 2));
            
            // Create PDF document using PDFKit
            console.log("Creating PDF document...");
            const pdfBuffer = await this.createPDFDocument(conversationData);
            console.log("PDF document created, buffer size:", pdfBuffer.length);
            
            // For Vercel compatibility, try buffer approach first
            try {
                console.log("Attempting to send PDF via buffer...");
                // Send PDF directly from buffer (Vercel-friendly)
                await this.whatsappService.sendDocument(from, {
                    buffer: pdfBuffer,
                    filename: `Quote_${Date.now()}.pdf`,
                    caption: "üìÑ Here's your detailed quote PDF!"
                });
                
                console.log("PDF sent successfully via buffer to:", from);
                
            } catch (bufferError) {
                console.error("Buffer upload failed:", bufferError);
                console.log("Trying file approach...");
                
                // Fallback to file approach
                const tempPath = await this.createTempPDF(pdfBuffer, from);
                console.log("Temp PDF created at:", tempPath);
                
                // Send PDF via WhatsApp
                await this.whatsappService.sendDocument(from, {
                    link: tempPath,
                    filename: `Quote_${Date.now()}.pdf`,
                    caption: "üìÑ Here's your detailed quote PDF!"
                });
                
                console.log("PDF sent successfully via file to:", from);
            }
            
        } catch (error) {
            console.error('Error generating/sending PDF:', error);
            await mongoLogger.logError(error, {
                source: 'pdf-generation',
                from: from
            });
            
            // Fallback message - use sendMessageOnce to prevent duplicates
            await this.sendMessageOnce(
                messageId || 'pdf-error',
                from,
                "Sorry, I couldn't generate the PDF at the moment. However, you have all the pricing information above. Please contact our support if you need assistance."
            );
        }
    }

    async createPSFDocument(conversationData) {
        try {
            console.log("Starting PSF creation...");
            console.log("Conversation data:", JSON.stringify(conversationData, null, 2));
            
            // Import PDFKit dynamically
            console.log("Importing PDFKit...");
            const PDFDocument = (await import('pdfkit')).default;
            console.log("PDFKit imported successfully");
            
            const doc = new PDFDocument({ 
                size: 'A4',
                margin: 0,
                layout: 'portrait'
            });
            const chunks = [];
            
            // Collect PDF data
            doc.on('data', chunk => chunks.push(chunk));
            doc.on('end', () => {
                console.log("PSF generation completed");
            });
            
            const pageWidth = doc.page.width;
            const pageHeight = doc.page.height;
            
            // Set up colors
            const primaryColor = '#000000';
            const secondaryColor = '#333333';
            const accentColor = '#0066CC'; // Blue for PSF highlights
            const headerColor = '#F0F8FF'; // Light blue header background
            
            // Background
            doc.rect(0, 0, pageWidth, pageHeight).fill('#FFFFFF');
            
            // Header background
            doc.rect(0, 0, pageWidth, 120).fill(headerColor);
            
            // Vertical PSF text on the left
            doc.save()
               .translate(30, 120)
               .rotate(-90)
               .fontSize(48)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('PSF', 0, 0)
               .restore();
            
            // Header section with logo area
            const headerY = 30;
            const contentStartX = 120;
            
            // Company logo using logo.png image
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Get the absolute path to the logo image
                const logoPath = path.join(process.cwd(), 'public', 'logo.png');
                
                // Check if logo exists
                await fs.access(logoPath);
                
                // Add the logo.png image in PSF header
                doc.image(logoPath, contentStartX, headerY - 10, {
                    width: 120,
                    height: 50
                });
                
            } catch (logoError) {
                console.log('Could not load logo.png for PSF, falling back to text');
                // Fallback to text if logo fails
                doc.fontSize(28)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Print247', contentStartX, headerY)
                   .fontSize(18)
                   .font('Helvetica')
                   .text('.us', contentStartX + 100, headerY + 5);
            }
            
            // PSF Title
            doc.fontSize(24)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('Product Specification Form', contentStartX, headerY + 40);
            
            // Document info
            doc.fontSize(12)
               .fillColor(secondaryColor)
               .font('Helvetica')
               .text(`PSF No: PSF-${Date.now()}`, contentStartX, headerY + 70)
               .text(`Date: ${new Date().toLocaleDateString('en-US')}`, pageWidth - 150, headerY + 70);
            
            // Main content area
            let currentY = 150;
            const leftCol = contentStartX;
            const rightCol = contentStartX + 250;
            const lineHeight = 25;
            
            // Product Information Section
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('üì¶ PRODUCT INFORMATION', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 200)
               .stroke('#E0E0E0');
            
            const productInfo = [
                ['Category:', conversationData.selectedCategory?.name || 'Not specified'],
                ['Product Type:', conversationData.selectedProduct?.name || 'Not specified'],
                ['Job Name:', conversationData.selectedProduct?.name || 'Custom Product'],
                ['SKUs/Designs:', conversationData.skus?.toString() || '1'],
                ['Estimated Turnaround:', '12 - 15 Business Days'],
                ['Shipping Method:', 'DAP (Delivered At Place)']
            ];
            
            productInfo.forEach(([label, value]) => {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text(label, leftCol, currentY)
                   .font('Helvetica')
                   .text(value, leftCol + 120, currentY);
                currentY += lineHeight;
            });
            
            // Materials & Specifications Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('üß± MATERIALS & SPECIFICATIONS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 150)
               .stroke('#E0E0E0');
            
            // Materials
            if (conversationData.selectedMaterial && conversationData.selectedMaterial.length > 0) {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Materials:', leftCol, currentY);
                
                conversationData.selectedMaterial.forEach((material, index) => {
                    doc.font('Helvetica')
                       .text(`‚Ä¢ ${material.name}`, leftCol + 120, currentY + (index * 15));
                });
                currentY += (conversationData.selectedMaterial.length * 15) + 10;
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Materials:', leftCol, currentY)
                   .font('Helvetica')
                   .text(conversationData.requestedMaterial || 'Standard Material', leftCol + 120, currentY);
                currentY += lineHeight;
            }
            
            // Dimensions
            if (conversationData.dimensions && conversationData.dimensions.length > 0) {
                const dimensionsText = conversationData.dimensions
                    .map(d => `${d.name}: ${d.value}"`)
                    .join(' √ó ');
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Dimensions:', leftCol, currentY)
                   .font('Helvetica')
                   .text(dimensionsText, leftCol + 120, currentY);
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Dimensions:', leftCol, currentY)
                   .font('Helvetica')
                   .text('Custom Size', leftCol + 120, currentY);
            }
            currentY += lineHeight;
            
            // Finishes Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('‚ú® FINISHES & TREATMENTS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 100)
               .stroke('#E0E0E0');
            
            if (conversationData.selectedFinish && conversationData.selectedFinish.length > 0) {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Selected Finishes:', leftCol, currentY);
                
                conversationData.selectedFinish.forEach((finish, index) => {
                    doc.font('Helvetica')
                       .text(`‚Ä¢ ${finish.name}`, leftCol + 120, currentY + (index * 15));
                });
                currentY += (conversationData.selectedFinish.length * 15) + 10;
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Finishes:', leftCol, currentY)
                   .font('Helvetica')
                   .text('Standard Finish', leftCol + 120, currentY);
                currentY += lineHeight;
            }
            
            // Quantity Requirements Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('üî¢ QUANTITY REQUIREMENTS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 80)
               .stroke('#E0E0E0');
            
            if (conversationData.quantity && conversationData.quantity.length > 0) {
                const quantitiesText = conversationData.quantity.map(q => q.toLocaleString()).join(', ');
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Requested Quantities:', leftCol, currentY)
                   .font('Helvetica')
                   .text(`${quantitiesText} pieces`, leftCol + 120, currentY);
            } else {
                doc.fontSize(11)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Quantities:', leftCol, currentY)
                   .font('Helvetica')
                   .text('To be determined', leftCol + 120, currentY);
            }
            currentY += lineHeight + 10;
            
            // Notes Section
            currentY += 20;
            doc.fontSize(16)
               .fillColor(accentColor)
               .font('Helvetica-Bold')
               .text('üìù NOTES & REQUIREMENTS', leftCol, currentY);
            
            currentY += 35;
            
            // Draw section border
            doc.rect(leftCol - 10, currentY - 10, pageWidth - leftCol - 40, 100)
               .stroke('#E0E0E0');
            
            doc.fontSize(10)
               .fillColor(secondaryColor)
               .font('Helvetica')
               .text('‚Ä¢ This PSF contains the specifications as discussed via WhatsApp', leftCol, currentY)
               .text('‚Ä¢ Final specifications may be adjusted based on artwork review', leftCol, currentY + 15)
               .text('‚Ä¢ Please confirm all specifications before proceeding to production', leftCol, currentY + 30)
               .text('‚Ä¢ Contact us for any clarifications or modifications needed', leftCol, currentY + 45);
            
            // Footer section
            const footerY = pageHeight - 120;
            
            // Use print247usa.png image instead of text circle
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Get the absolute path to the image
                const imagePath = path.join(process.cwd(), 'public', 'print247usa.png');
                
                // Check if image exists
                await fs.access(imagePath);
                
                // Add the print247usa.png image
                doc.image(imagePath, leftCol + 15, footerY - 35, {
                    width: 70,
                    height: 70
                });
                
            } catch (imageError) {
                console.log('Could not load print247usa.png for PSF, falling back to text');
                // Fallback to circle and text if image fails
                doc.circle(leftCol + 50, footerY, 35)
                   .stroke(primaryColor);
                
                doc.fontSize(8)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('PRODUCT SPEC', leftCol + 20, footerY - 15, { align: 'center' })
                   .text('APPROVED BY', leftCol + 20, footerY - 7, { align: 'center' })
                   .text('Print247.us', leftCol + 20, footerY + 1, { align: 'center' })
                   .text('PSF DEPT', leftCol + 20, footerY + 9, { align: 'center' });
            }
            
            // Authorization section
            doc.fontSize(10)
               .font('Helvetica-Bold')
               .text('Customer Approval:', leftCol + 150, footerY - 20)
               .text('_____________________', leftCol + 150, footerY)
               .text('Signature & Date', leftCol + 150, footerY + 20);
            
            // PSF ID and Date
            doc.fontSize(8)
               .fillColor(secondaryColor)
               .text(`PSF-${Date.now()}`, pageWidth - 150, footerY - 20)
               .text(`Generated: ${new Date().toLocaleString('en-US')}`, pageWidth - 150, footerY)
               .text('This is a computer generated document', pageWidth - 150, footerY + 20);
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be ready
            return new Promise((resolve) => {
                doc.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            });
            
        } catch (error) {
            console.error('Error creating PSF document:', error);
            throw error;
        }
    }

    async createPDFDocument(conversationData) {
        try {
            console.log("Starting PDF creation...");
            console.log("Conversation data:", JSON.stringify(conversationData, null, 2));
            
            // Import PDFKit dynamically
            console.log("Importing PDFKit...");
            const PDFDocument = (await import('pdfkit')).default;
            console.log("PDFKit imported successfully");
            
            const doc = new PDFDocument({ 
                size: 'A4',
                margin: 0,
                layout: 'portrait'
            });
            const chunks = [];
            
            // Collect PDF data
            doc.on('data', chunk => chunks.push(chunk));
            doc.on('end', () => {
                console.log("PDF generation completed");
            });
            
            const pageWidth = doc.page.width;
            const pageHeight = doc.page.height;
            
            // Set up colors to match reference
            const primaryColor = '#000000';
            const grayColor = '#666666';
            const lightGrayColor = '#CCCCCC';
            const headerBgColor = '#F8F8F8';
            
            // Background
            doc.rect(0, 0, pageWidth, pageHeight).fill('#FFFFFF');
            
            // Header section with light gray background
            doc.rect(0, 0, pageWidth, 80).fill(headerBgColor);
            
            // Date and Version in top right (matching reference)
            const currentDate = new Date().toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: '2-digit', 
                year: 'numeric' 
            }).replace(/\//g, '/');
            
            doc.fontSize(9)
               .fillColor(primaryColor)
               .font('Helvetica')
               .text(currentDate, pageWidth - 100, 15)
               .text(`${Math.floor(Date.now()/1000)}-${Math.floor(Math.random()*1000)} (Version 2)`, pageWidth - 150, 30);
            
        // Print247 logo using logo.png image
        try {
            const fs = await import('fs/promises');
            const path = await import('path');
            
            // Get the absolute path to the logo image
            const logoPath = path.join(process.cwd(), 'public', 'logo.png');
            
            // Check if logo exists
            await fs.access(logoPath);
            
            // Add the logo.png image in header
            doc.image(logoPath, 50, 15, {
                width: 120,
                height: 50
            });
            
        } catch (logoError) {
            console.log('Could not load logo.png, falling back to text');
            // Fallback to text if logo fails
            doc.fontSize(28)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('Print247', 50, 25);
            
            doc.fontSize(16)
               .fillColor('#0066CC')
               .font('Helvetica')
               .text('.us', 165, 30);
        }            // Vertical QUOTE text on the left side
            doc.save()
               .translate(25, 150)
               .rotate(-90)
               .fontSize(48)
               .fillColor(lightGrayColor)
               .font('Helvetica-Bold')
               .text('QUOTE', 0, 0)
               .restore();
            
            // Disclaimer section (matching reference layout)
            const disclaimerY = 90;
            const contentStartX = 80;
            
            doc.fontSize(9)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('Disclaimer:', contentStartX, disclaimerY);
            
            const disclaimerText = 'We want to emphasize that our estimate is comprehensive, encompassing all essential operations and materials in line with industry standards. If you have any queries, please don\'t hesitate to reach out. The estimate remains valid for 30 days from the specified date, and pricing adjustments may occur after a final artwork inspection. The countdown for delivery initiation starts upon design file approval and payment receipt. We value your business and eagerly anticipate the opportunity to serve you in the future. Feel free to contact us for any further information or clarification you may need. Any additional tariff, duty, and taxes on goods at the time of arrival, if applicable, shall be paid by the receiver/customer.';
            
            doc.fontSize(8)
               .font('Helvetica')
               .text(disclaimerText, contentStartX, disclaimerY + 15, {
                   width: pageWidth - contentStartX - 50,
                   align: 'justify',
                   lineGap: 2
               });
            
            // Quote details section (matching reference layout)
            const detailsY = disclaimerY + 130;
            
            // Materials processing for display
            let materialText = 'Standard Material';
            if (conversationData.selectedMaterials && Array.isArray(conversationData.selectedMaterials)) {
                materialText = conversationData.selectedMaterials.map(m => m.name).join(', ');
            } else if (conversationData.selectedMaterial?.name) {
                materialText = conversationData.selectedMaterial.name;
            }
            
            // Finishes processing for display
            let finishText = 'Standard Finish';
            if (conversationData.selectedFinishes && Array.isArray(conversationData.selectedFinishes)) {
                finishText = conversationData.selectedFinishes.map(f => f.name).join(', ');
            } else if (conversationData.selectedFinish?.name) {
                finishText = conversationData.selectedFinish.name;
            }
            
            // Quantities processing for display
            let quantityText = '1';
            if (conversationData.quantities && Array.isArray(conversationData.quantities)) {
                quantityText = conversationData.quantities.join(', ');
            } else if (conversationData.quantity) {
                quantityText = conversationData.quantity.toString();
            }
            
            const details = [
                ['Query No:', `QT-${Date.now().toString().slice(-8)}`],
                ['Customer:', 'WhatsApp Customer'],
                ['Job Name:', conversationData.selectedProduct?.name || 'Custom Product'],
                ['Materials:', materialText],
                ['Quantities:', quantityText],
                ['No of SKU\'s:', conversationData.skus?.toString() || '1'],
                ['Turnaround Time:', '12 - 15 Business Days (*T&C Applies)'],
                ['Shipping:', 'DAP (Delivered At Place)'],
                ['Finished Size:', conversationData.dimensions?.map(d => `${d.value}`).join(' x ') || 'Custom Size'],
                ['Print Specification:', 'CMYK 4/0 + DIE CUTTING + STRAIGHT LINE GLUING'],
                ['Extra Finishes:', finishText],
                ['Representative:', 'AI Assistant - WhatsApp Bot']
            ];
            
            let currentY = detailsY;
            details.forEach(([label, value]) => {
                // Draw horizontal line
                doc.moveTo(contentStartX, currentY)
                   .lineTo(pageWidth - 50, currentY)
                   .stroke('#CCCCCC');
                
                // Label and value
                doc.fontSize(10)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text(label, contentStartX, currentY + 5)
                   .font('Helvetica-Bold')
                   .text(value, contentStartX + 200, currentY + 5);
                
                currentY += 25;
            });
            
            // Final line
            doc.moveTo(contentStartX, currentY)
               .lineTo(pageWidth - 50, currentY)
               .stroke('#CCCCCC');
            
            // Pricing table (matching reference layout)
            const tableY = currentY + 40;
            const tableStartX = contentStartX;
            const tableWidth = pageWidth - contentStartX - 50;
            const colWidth = tableWidth / 4;
            
            if (conversationData.pricingData) {
                console.log("Pricing data found:", conversationData.pricingData);
                const { qty, unit_cost } = conversationData.pricingData;
                
                if (!qty || !unit_cost) {
                    console.error("Invalid pricing data structure:", { qty, unit_cost });
                    throw new Error("Invalid pricing data structure");
                }
                
                // Table border
                doc.rect(tableStartX, tableY - 5, tableWidth, 90)
                   .stroke('#CCCCCC');
                
                // Header background
                doc.rect(tableStartX, tableY - 5, tableWidth, 20)
                   .fillAndStroke('#F0F0F0', '#CCCCCC');
                
                // Table headers with proper alignment
                doc.fontSize(10)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Tier\'s', tableStartX + 5, tableY + 2, { width: colWidth - 10, align: 'left' })
                   .text('Tier 1', tableStartX + colWidth + 5, tableY + 2, { width: colWidth - 10, align: 'center' })
                   .text('Tier 2', tableStartX + colWidth * 2 + 5, tableY + 2, { width: colWidth - 10, align: 'center' })
                   .text('Tier 3', tableStartX + colWidth * 3 + 5, tableY + 2, { width: colWidth - 10, align: 'center' });
                
                // Vertical lines for columns
                for (let i = 1; i < 4; i++) {
                    doc.moveTo(tableStartX + colWidth * i, tableY - 5)
                       .lineTo(tableStartX + colWidth * i, tableY + 85)
                       .stroke('#CCCCCC');
                }
                
                // Quantities row
                doc.fontSize(9)
                   .font('Helvetica-Bold')
                   .text('Quantities:', tableStartX + 5, tableY + 25);
                
                qty.forEach((quantity, index) => {
                    doc.text(quantity.toLocaleString(), tableStartX + colWidth * (index + 1) + 5, tableY + 25, { 
                        width: colWidth - 10, 
                        align: 'center' 
                    });
                });
                
                // Unit Cost row
                const unitCostY = tableY + 40;
                doc.moveTo(tableStartX, unitCostY - 5)
                   .lineTo(tableStartX + tableWidth, unitCostY - 5)
                   .stroke('#CCCCCC');
                
                doc.text('Unit Cost:', tableStartX + 5, unitCostY);
                unit_cost.forEach((cost, index) => {
                    doc.text(`$${cost.toFixed(3)}`, tableStartX + colWidth * (index + 1) + 5, unitCostY, { 
                        width: colWidth - 10, 
                        align: 'center' 
                    });
                });
                
                // Estimate Price row
                const priceY = tableY + 55;
                doc.moveTo(tableStartX, priceY - 5)
                   .lineTo(tableStartX + tableWidth, priceY - 5)
                   .stroke('#CCCCCC');
                
                doc.text('Estimate Price:', tableStartX + 5, priceY);
                qty.forEach((quantity, index) => {
                    const totalPrice = (quantity * unit_cost[index]);
                    doc.text(`$${totalPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, 
                        tableStartX + colWidth * (index + 1) + 5, priceY, { 
                        width: colWidth - 10, 
                        align: 'center' 
                    });
                });
            } else {
                console.log("No pricing data available for PDF");
                // Add a message indicating no pricing data
                doc.fontSize(12)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('Pricing information not available', tableStartX, tableY);
            }
            
            // Notes section (matching reference)
            const notesY = tableY + 120;
            doc.fontSize(10)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('Notes:', contentStartX, notesY);
            
            const notesText = `‚Ä¢ Final pricing may vary based on artwork complexity and material specifications
‚Ä¢ This quote is valid for 30 days from the date above
‚Ä¢ Production time starts after artwork approval and payment confirmation
‚Ä¢ Shipping costs are included for DAP delivery within the continental US
‚Ä¢ Custom packaging options available upon request
‚Ä¢ All materials meet industry quality standards`;
            
            doc.fontSize(9)
               .font('Helvetica')
               .text(notesText, contentStartX, notesY + 15, {
                   width: pageWidth - contentStartX - 50,
                   lineGap: 3
               });
            
            // Footer section (matching reference)
            const footerY = pageHeight - 120;
            
            // Use print247usa.png image instead of text
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Get the absolute path to the image
                const imagePath = path.join(process.cwd(), 'public', 'print247usa.png');
                
                // Check if image exists
                await fs.access(imagePath);
                
                // Add the print247usa.png image
                doc.image(imagePath, contentStartX + 25, footerY - 5, {
                    width: 70,
                    height: 70
                });
                
            } catch (imageError) {
                console.log('Could not load print247usa.png, falling back to text');
                // Fallback to circle and text if image fails
                doc.circle(contentStartX + 60, footerY + 20, 35)
                   .stroke(primaryColor)
                   .lineWidth(2);
                
                doc.fontSize(7)
                   .fillColor(primaryColor)
                   .font('Helvetica-Bold')
                   .text('PROUDLY BASED', contentStartX + 25, footerY + 5, { width: 70, align: 'center' })
                   .text('IN THE USA', contentStartX + 25, footerY + 15, { width: 70, align: 'center' });
                
                doc.fontSize(8)
                   .font('Helvetica-Bold')
                   .fillColor('#0066CC')
                   .text('Print247.us', contentStartX + 25, footerY + 30, { width: 70, align: 'center' });
            }
            
            // Authorization section with proper formatting
            doc.fontSize(10)
               .fillColor(primaryColor)
               .font('Helvetica-Bold')
               .text('S.M. Authorized By:', contentStartX + 150, footerY)
               .fontSize(9)
               .font('Helvetica')
               .text('_________________________________', contentStartX + 150, footerY + 15);
            
            // Date section
            doc.fontSize(10)
               .font('Helvetica-Bold')
               .text('Date:', pageWidth - 150, footerY)
               .fontSize(9)
               .font('Helvetica')
               .text('_________________________________', pageWidth - 150, footerY + 15)
               .text(new Date().toLocaleDateString('en-US', { 
                   month: '2-digit',
                   day: '2-digit', 
                   year: 'numeric' 
               }), pageWidth - 150, footerY + 30);
            
            // Footer line
            doc.moveTo(contentStartX, footerY + 50)
               .lineTo(pageWidth - 50, footerY + 50)
               .stroke('#CCCCCC');
            
            // Footer text
            doc.fontSize(8)
               .fillColor(grayColor)
               .font('Helvetica')
               .text('This quote is valid for 30 days from the date above. Final pricing subject to artwork review.', 
                     contentStartX, footerY + 60, { 
                         width: pageWidth - contentStartX - 50, 
                         align: 'center' 
                     });
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be ready
            return new Promise((resolve) => {
                doc.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            });
            
        } catch (error) {
            console.error('Error creating PDF document:', error);
            throw error;
        }
    }

    async createTempPDF(pdfBuffer, from, type = 'quote') {
        try {
            // Check if we're in Vercel environment
            if (process.env.VERCEL) {
                // For Vercel, use /tmp directory which is writable
                const fs = await import('fs/promises');
                const path = await import('path');
                const os = await import('os');
                
                // Use system temp directory
                const tempDir = path.join(os.tmpdir(), 'whatsapp-pdfs');
                await fs.mkdir(tempDir, { recursive: true });
                
                // Generate unique filename
                const filename = `${type.toLowerCase()}_${from}_${Date.now()}.pdf`;
                const filepath = path.join(tempDir, filename);
                
                // Save PDF file
                await fs.writeFile(filepath, pdfBuffer);
                
                console.log('PDF saved to Vercel temp:', filepath);
                return filepath;
            } else {
                // For local development, use the existing temp directory
                const fs = await import('fs/promises');
                const path = await import('path');
                
                // Create temp directory if it doesn't exist
                const tempDir = path.join(process.cwd(), 'temp', 'pdfs');
                await fs.mkdir(tempDir, { recursive: true });
                
                // Generate unique filename
                const filename = `${type.toLowerCase()}_${from}_${Date.now()}.pdf`;
                const filepath = path.join(tempDir, filename);
                
                // Save PDF file
                await fs.writeFile(filepath, pdfBuffer);
                
                console.log(`${type} saved to local temp:`, filepath);
                return filepath;
            }
            
        } catch (error) {
            console.error('Error creating temp PDF file:', error);
            throw error;
        }
    }

    async generateAndSendQuote(from, conversationData) {
        try {
            // Generate the quote
            const quote = await conversationService.generateQuote(from, conversationData);

            // Format and send the quote
            const quoteMessage = conversationService.formatQuoteMessage(quote);
            await this.whatsappService.sendMessage(from, quoteMessage);

            // Send follow-up options
            const buttons = [
                {
                    type: 'reply',
                    reply: {
                        id: 'new_quote',
                        title: 'New Quote'
                    }
                },
                {
                    type: 'reply',
                    reply: {
                        id: 'contact_us',
                        title: 'Contact Us'
                    }
                }
            ];

            const followUpText = `Thank you for using our quote service! üéâ

Would you like to:`;

            await this.whatsappService.sendButtonMessage(from, followUpText, buttons);

            // Mark conversation as completed
            await conversationService.updateConversationState(from, {
                currentStep: 'completed',
                isActive: false,
                completedAt: new Date()
            });

        } catch (error) {
            await mongoLogger.logError(error, { source: 'quote-generation' });
            await this.whatsappService.sendMessage(
                from,
                "I'm sorry, there was an error generating your quote. Please contact our support team for assistance."
            );
        }
    }

    // Helper methods
    isGreeting(message) {
        const greetings = ['hi', 'hello', 'hey', 'greetings', 'good morning', 'good afternoon', 'good evening', 'hi there', 'hello there', 'hey there', 'howdy', 'hiya', 'sup', 'yo'];
        const lowerMessage = message.toLowerCase().trim();
        
        // Check for exact matches first
        if (lowerMessage === 'hi' || lowerMessage === 'hello' || lowerMessage === 'hey') {
            return true;
        }
        
        // Check for simple greetings (not complex messages with product info)
        const isSimpleGreeting = greetings.some(greeting => {
            if (greeting.length <= 3) {
                // For short greetings, require exact word match
                return lowerMessage === greeting;
            } else {
                // For longer greetings, allow partial match but not in the middle of words
                return lowerMessage.includes(greeting);
            }
        });
        
        // If it's a simple greeting, return true
        if (isSimpleGreeting) {
            return true;
        }
        
        // If the message contains product-related keywords, it's not a simple greeting
        const productKeywords = ['looking for', 'need', 'want', 'quote', 'price', 'pouches', 'boxes', 'labels', 'carton', 'quantity', 'size', 'flavors', 'uv', 'foil', 'white', 'inside'];
        const hasProductInfo = productKeywords.some(keyword => lowerMessage.includes(keyword));
        
        // If it has product info, it's not a simple greeting
        if (hasProductInfo) {
            return false;
        }
        
        return false;
    }

    hasProductInformation(message) {
        const lowerMessage = message.toLowerCase().trim();
        
        // Check for product-related keywords that indicate useful information
        const productKeywords = [
            'looking for', 'need', 'want', 'quote', 'price', 'pouches', 'boxes', 'labels', 'carton',
            'quantity', 'size', 'flavors', 'uv', 'foil', 'white', 'inside', 'standup', 'folding',
            'rigid', 'mylor', 'bag', 'label', 'dimensions', 'width', 'height', 'length', 'thickness',
            'material', 'finish', 'coating', 'printing', 'colors', 'design', 'custom', 'specifications'
        ];
        
        const hasProductInfo = productKeywords.some(keyword => lowerMessage.includes(keyword));
        
        // Also check for numbers (quantities, dimensions)
        const hasNumbers = /\d+/.test(message);
        
        // Check for measurement units
        const hasUnits = /(mm|cm|inches?|ft|feet|meters?|kg|g|lb|pounds?|pieces?|units?|pcs|k|thousand)/i.test(message);
        
        return hasProductInfo || (hasNumbers && hasUnits);
    }

    isDimensionMessage(message) {
        const trimmedMessage = message.trim();
        
        // Check for common dimension patterns
        const dimensionPatterns = [
            /^\d+x\d+x\d+$/,           // 5x5x5
            /^\d+,\d+,\d+$/,           // 5,5,5
            /^\d+\s+\d+\s+\d+$/,       // 5 5 5
            /^\d+\.\d+x\d+\.\d+x\d+\.\d+$/, // 5.5x5.5x5.5
            /^\d+\.\d+,\d+\.\d+,\d+\.\d+$/, // 5.5,5.5,5.5
            /^[a-zA-Z]:\d+[x,]\d+[x,]\d+$/i, // L:5x5x5 or L:5,5,5
        ];
        
        return dimensionPatterns.some(pattern => pattern.test(trimmedMessage));
    }

    async parseDimensionsManually(dimensionString, dimensionNames) {
        try {
            const values = [];
            const dimensionStringLower = dimensionString.toLowerCase().trim();

            // Handle format: "5x7x3" or "5,7,3" or "5 7 3"
            let numbers = [];

            if (dimensionStringLower.includes('x')) {
                numbers = dimensionStringLower.split('x').map(v => parseFloat(v.trim()));
            } else if (dimensionStringLower.includes(',')) {
                numbers = dimensionStringLower.split(',').map(v => parseFloat(v.trim()));
            } else {
                // Extract all numbers from the string
                const matches = dimensionStringLower.match(/\d+(?:\.\d+)?/g);
                if (matches) {
                    numbers = matches.map(n => parseFloat(n));
                }
            }

            // Map values to dimension names
            const result = [];
            for (let i = 0; i < dimensionNames.length && i < numbers.length; i++) {
                if (!isNaN(numbers[i]) && numbers[i] > 0) {
                    result.push({
                        name: dimensionNames[i],
                        value: numbers[i]
                    });
                }
            }

            return result.length === dimensionNames.length ? result : [];
        } catch (error) {
            await mongoLogger.logError(error, { source: 'dimension-parsing' });
            return [];
        }
    }

    async handleImageMessage(message, from) {
        await mongoLogger.info('Received image message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for sharing the image! üì∏ Our team will review it and get back to you."
        );
    }

    async handleDocumentMessage(message, from) {
        await mongoLogger.info('Received document message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for the document! üìÑ We've received it and will review it shortly."
        );
    }

    /**
     * Validate that all required data is present for quote generation
     */
    validateQuoteData(conversationData) {
        const missingFields = [];
        let isValid = true;

        // Check for selected category
        if (!conversationData.selectedCategory || !conversationData.selectedCategory.id) {
            missingFields.push("‚Ä¢ Product category selection");
            isValid = false;
        }

        // Check for selected product
        if (!conversationData.selectedProduct || !conversationData.selectedProduct.id) {
            missingFields.push("‚Ä¢ Product selection");
            isValid = false;
        }

        // Check for selected material
        if (!conversationData.selectedMaterial || conversationData.selectedMaterial.length === 0) {
            missingFields.push("‚Ä¢ Material selection");
            isValid = false;
        }

        // Check for selected finishes
        if (!conversationData.selectedFinish || conversationData.selectedFinish.length === 0) {
            missingFields.push("‚Ä¢ Finish selection");
            isValid = false;
        }

        // Check for dimensions - must have ALL required dimensions
        if (!conversationData.dimensions || conversationData.dimensions.length === 0) {
            missingFields.push("‚Ä¢ Product dimensions");
            isValid = false;
        } else if (conversationData.selectedProduct && conversationData.selectedProduct.dimensionFields) {
            // Check if all required dimensions are provided
            const requiredDimensions = conversationData.selectedProduct.dimensionFields.filter(field => field.isRequired);
            const providedDimensions = conversationData.dimensions || [];
            
            const missingDimensions = requiredDimensions.filter(reqDim => 
                !providedDimensions.some(provDim => provDim.name === reqDim.name)
            );
            
            if (missingDimensions.length > 0) {
                const missingDimNames = missingDimensions.map(d => d.name).join(', ');
                missingFields.push(`‚Ä¢ Missing required dimensions: ${missingDimNames}`);
                isValid = false;
                
                console.log('üîç validateQuoteData - Missing dimensions:', {
                    productName: conversationData.selectedProduct.name,
                    requiredDimensions: requiredDimensions.length,
                    providedDimensions: providedDimensions.length,
                    missingDimensions: missingDimNames
                });
            }
        }

        // Check for quantity
        if (!conversationData.quantity || conversationData.quantity.length === 0) {
            missingFields.push("‚Ä¢ Quantity specification");
            isValid = false;
        }

        return {
            isValid,
            missingFields
        };
    }

    /**
     * Determine which step to reset to based on missing data
     */
    getResetStepForMissingData(missingFields, conversationData) {
        // Priority order: category -> product -> dimensions -> material -> finish -> quantity
        if (missingFields.some(field => field.includes("category"))) {
            return 'category_selection';
        }
        if (missingFields.some(field => field.includes("product"))) {
            return 'product_selection';
        }
        if (missingFields.some(field => field.includes("dimensions"))) {
            return 'dimension_input';
        }
        if (missingFields.some(field => field.includes("material"))) {
            return 'material_selection';
        }
        if (missingFields.some(field => field.includes("finish"))) {
            return 'finish_selection';
        }
        if (missingFields.some(field => field.includes("quantity"))) {
            return 'quantity_input';
        }

        // Default fallback
        return 'start';
    }

    async handleAudioMessage(message, from) {
        await mongoLogger.info('Received audio message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for the voice message! üéµ Our team will listen to it and respond accordingly."
        );
    }

    async handleVideoMessage(message, from) {
        await mongoLogger.info('Received video message', { from });
        await this.whatsappService.sendMessage(
            from,
            "Thank you for the video! üé• We've received it and will review it shortly."
        );
    }

    async handleInteractiveMessage(message, from) {
        await mongoLogger.info('Received interactive message', { from });

        if (message.interactive.type === 'button_reply') {
            const buttonId = message.interactive.button_reply.id;
            const buttonTitle = message.interactive.button_reply.title;
            await mongoLogger.info('Button clicked', { buttonId, buttonTitle, from });

            // Get current conversation state
            const conversationState = await conversationService.getConversationState(from);

            // Handle button responses
            if (buttonId === 'quote_yes') {
                await conversationService.updateConversationState(from, {
                    currentStep: 'product_selection',
                    'conversationData.wantsQuote': true
                });
                await this.sendProductSelection(from);
            } else if (buttonId === 'quote_no') {
                await this.whatsappService.sendMessage(
                    from,
                    "No problem! If you change your mind or have any questions about our mylar bags, feel free to reach out anytime. Have a great day! üòä"
                );
                await conversationService.updateConversationState(from, {
                    currentStep: 'completed',
                    isActive: false,
                    completedAt: new Date()
                });
            } else if (buttonId === 'new_quote') {
                await conversationService.resetConversation(from);
                await this.sendGreetingWithQuoteOption(from);
                await conversationService.updateConversationState(from, {
                    currentStep: 'greeting_response'
                });
            } else if (buttonId === 'contact_us') {
                await this.handleContactInfo(from);
            } else {
                await this.whatsappService.sendMessage(
                    from,
                    `You selected: ${buttonTitle}. Thank you for your choice!`
                );
            }
        } else if (message.interactive.type === 'list_reply') {
            const listId = message.interactive.list_reply.id;
            const listTitle = message.interactive.list_reply.title;
            await mongoLogger.info('List item selected', { listId, listTitle, from });

            // Get current conversation state before processing
            const conversationState = await conversationService.getConversationState(from);
            console.log('üîç Current conversation state before list reply:', {
                currentStep: conversationState.currentStep,
                hasSelectedCategory: !!conversationState.conversationData?.selectedCategory,
                selectedCategory: conversationState.conversationData?.selectedCategory,
                conversationData: Object.keys(conversationState.conversationData || {})
            });

            console.log('üìã Processing list reply:', {
                listId,
                listTitle,
                currentStep: conversationState.currentStep,
                messageText: listId,
                isNumeric: !isNaN(parseInt(listId)),
                parsedId: parseInt(listId)
            });

            // Smart routing: Determine what type of selection this is based on the listId
            const routingResult = await this.determineListReplyRouting(listId, listTitle, conversationState);
            console.log('üéØ List reply routing result:', routingResult);

            if (routingResult.shouldOverrideStep) {
                console.log('üîÑ Overriding step from', conversationState.currentStep, 'to', routingResult.correctStep);
                // Override the current step and process with the correct handler
                await conversationService.updateConversationState(from, {
                    currentStep: routingResult.correctStep
                });

                // Get updated state
                const updatedState = await conversationService.getConversationState(from);
                console.log('üîÑ Updated state after step override:', {
                    currentStep: updatedState.currentStep,
                    selectedCategory: updatedState.conversationData?.selectedCategory,
                    hasCategory: !!updatedState.conversationData?.selectedCategory?.id
                });

                // Process with the correct step
                await this.processConversationFlow(message, listId, from, updatedState);
            } else {
                console.log('‚û°Ô∏è Processing with current step:', conversationState.currentStep);
                // Process normally with current step
            await this.processConversationFlow(message, listId, from, conversationState);
            }
        }
    }

    // Helper methods for contact info
    async handleContactInfo(from) {
        const contactMessage = `üìû *Contact Information*

üè¢ *Business Hours:*
Monday - Friday: 9:00 AM - 6:00 PM
Saturday: 9:00 AM - 2:00 PM
Sunday: Closed

üì± *Phone:* [YOUR_PHONE_NUMBER]
üìß *Email:* [YOUR_EMAIL]
üåê *Website:* [YOUR_WEBSITE]
üìç *Address:* [YOUR_ADDRESS]

Feel free to reach out anytime!`;

        await this.whatsappService.sendMessage(from, contactMessage);
    }

    /**
     * Determine the correct routing for a list reply based on its content and current state
     */
    async determineListReplyRouting(listId, listTitle, conversationState) {
        const currentStep = conversationState.currentStep;
        const conversationData = conversationState.conversationData || {};

        console.log('üîç Determining list reply routing:', {
            listId,
            listTitle,
            currentStep,
            hasCategory: !!conversationData.selectedCategory?.id,
            hasProduct: !!conversationData.selectedProduct?.id
        });

        // If listId is numeric, it could be a category ERP ID
        if (!isNaN(parseInt(listId))) {
            const numericId = parseInt(listId);

            // Check if this matches a category ERP ID
            try {
                const categories = await conversationService.getProductCategories();
                const matchingCategory = categories.find(cat => cat.erp_id === numericId);

                if (matchingCategory) {
                    console.log('‚úÖ List reply matches category:', matchingCategory.name);

                    // If we're not in category selection and don't have a category, this should be treated as category selection
                    if (currentStep !== 'category_selection' && !conversationData.selectedCategory?.id) {
                        return {
                            shouldOverrideStep: true,
                            correctStep: 'category_selection',
                            reason: 'List reply matches category but current step is not category_selection'
                        };
                    }

                    // If we already have a category but this is a different one, treat it as category selection
                    if (conversationData.selectedCategory?.erp_id && conversationData.selectedCategory.erp_id !== numericId) {
                        return {
                            shouldOverrideStep: true,
                            correctStep: 'category_selection',
                            reason: 'List reply matches different category than currently selected'
                        };
                    }
                }
            } catch (error) {
                console.log('Error checking categories:', error.message);
            }
        }

        // Check if listId could be a product name or ID
        if (conversationData.selectedCategory?.id) {
            try {
                const products = await conversationService.getProductsByCategory(conversationData.selectedCategory.id);
                const matchingProduct = products.find(prod =>
                    prod.erp_id.toString() === listId ||
                    prod.name.toLowerCase().includes(listTitle.toLowerCase())
                );

                if (matchingProduct) {
                    console.log('‚úÖ List reply matches product:', matchingProduct.name);

                    // If we're not in product selection and don't have a product, this should be treated as product selection
                    if (currentStep !== 'product_selection' && !conversationData.selectedProduct?.id) {
                        return {
                            shouldOverrideStep: true,
                            correctStep: 'product_selection',
                            reason: 'List reply matches product but current step is not product_selection'
                        };
                    }
                }
            } catch (error) {
                console.log('Error checking products:', error.message);
            }
        }

        // Check for corrupted state: user in dimension_input but no category/product selected
        if (currentStep === 'dimension_input' && !conversationData.selectedCategory?.id && !conversationData.selectedProduct?.id) {
            console.log('üö® Corrupted state detected: in dimension_input but no category/product selected');

            // Try to determine if this is actually a category selection
            if (!isNaN(parseInt(listId))) {
                return {
                    shouldOverrideStep: true,
                    correctStep: 'category_selection',
                    reason: 'Corrupted state: user in dimension_input with no selections, treating as category selection'
                };
            }
        }

        // Check for other corrupted states
        if (currentStep === 'material_selection' && !conversationData.selectedProduct?.id) {
            console.log('üö® Corrupted state detected: in material_selection but no product selected');
            return {
                shouldOverrideStep: true,
                correctStep: 'product_selection',
                reason: 'Corrupted state: user in material_selection with no product selected'
            };
        }

        if (currentStep === 'finish_selection' && !conversationData.selectedProduct?.id) {
            console.log('üö® Corrupted state detected: in finish_selection but no product selected');
            return {
                shouldOverrideStep: true,
                correctStep: 'product_selection',
                reason: 'Corrupted state: user in finish_selection with no product selected'
            };
        }

        if (currentStep === 'quantity_input' && !conversationData.selectedFinish?.length) {
            console.log('üö® Corrupted state detected: in quantity_input but no finishes selected');
            return {
                shouldOverrideStep: true,
                correctStep: 'finish_selection',
                reason: 'Corrupted state: user in quantity_input with no finishes selected'
            };
        }

        // Default: don't override, process with current step
        return {
            shouldOverrideStep: false,
            correctStep: currentStep,
            reason: 'No override needed, processing with current step'
        };
    }
}

export default MessageHandler;
